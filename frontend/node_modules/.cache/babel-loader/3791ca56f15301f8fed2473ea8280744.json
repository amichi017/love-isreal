{"ast":null,"code":"import { DateTime } from 'luxon';\nimport { MathUtils, TimeZone } from '../polyfills/Utils';\nimport { IllegalArgumentException, UnsupportedError } from '../polyfills/errors';\n/**\r\n * A class that contains location information such as latitude and longitude required for astronomical calculations. The\r\n * elevation field may not be used by some calculation engines and would be ignored if set. Check the documentation for\r\n * specific implementations of the {@link AstronomicalCalculator} to see if elevation is calculated as part of the\r\n * algorithm.\r\n *\r\n * @author &copy; Eliyahu Hershfeld 2004 - 2016\r\n * @version 1.1\r\n */\n\nexport class GeoLocation {\n  constructor(name = 'Greenwich, England', latitude = 51.4772, longitude = 0, elevationOrTimeZoneId, timeZoneId) {\n    this.locationName = null;\n    let elevation = 0;\n\n    if (timeZoneId) {\n      elevation = elevationOrTimeZoneId;\n    } else {\n      timeZoneId = elevationOrTimeZoneId;\n    }\n\n    this.setLocationName(name);\n    this.setLatitude(latitude);\n    this.setLongitude(longitude);\n    this.setElevation(elevation);\n    this.setTimeZone(timeZoneId);\n  }\n  /**\r\n   * Method to get the elevation in Meters.\r\n   *\r\n   * @return Returns the elevation in Meters.\r\n   */\n\n\n  getElevation() {\n    return this.elevation;\n  }\n  /**\r\n   * Method to set the elevation in Meters <b>above </b> sea level.\r\n   *\r\n   * @param elevation\r\n   *            The elevation to set in Meters. An IllegalArgumentException will be thrown if the value is a negative.\r\n   */\n\n\n  setElevation(elevation) {\n    if (elevation < 0) {\n      throw new IllegalArgumentException('Elevation cannot be negative');\n    }\n\n    this.elevation = elevation;\n  }\n\n  setLatitude(degreesOrLatitude, minutes, seconds, direction) {\n    if (!minutes) {\n      const latitude = degreesOrLatitude;\n\n      if (latitude > 90 || latitude < -90) {\n        throw new IllegalArgumentException('Latitude must be between -90 and  90');\n      }\n\n      this.latitude = latitude;\n    } else {\n      const degrees = degreesOrLatitude;\n      let tempLat = degrees + (minutes + seconds / 60) / 60;\n\n      if (tempLat > 90 || tempLat < 0) {\n        // FIXME An exception should be thrown if degrees, minutes or seconds are negative\n        throw new IllegalArgumentException('Latitude must be between 0 and  90. Use direction of S instead of negative.');\n      }\n\n      if (direction === 'S') {\n        tempLat *= -1;\n      } else if (!(direction === 'N')) {\n        throw new IllegalArgumentException('Latitude direction must be N or S');\n      }\n\n      this.latitude = tempLat;\n    }\n  }\n  /**\r\n   * @return Returns the latitude.\r\n   */\n\n\n  getLatitude() {\n    return this.latitude;\n  }\n\n  setLongitude(degreesOrLongitude, minutes, seconds, direction) {\n    if (!minutes) {\n      const longitude = degreesOrLongitude;\n\n      if (longitude > 180 || longitude < -180) {\n        throw new IllegalArgumentException('Longitude must be between -180 and  180');\n      }\n\n      this.longitude = longitude;\n    } else {\n      const degrees = degreesOrLongitude;\n      let longTemp = degrees + (minutes + seconds / 60) / 60;\n\n      if (longTemp > 180 || this.longitude < 0) {\n        // FIXME An exception should be thrown if degrees, minutes or seconds are negative\n        throw new IllegalArgumentException('Longitude must be between 0 and  180.  Use a direction of W instead of negative.');\n      }\n\n      if (direction === 'W') {\n        longTemp *= -1;\n      } else if (!(direction === 'E')) {\n        throw new IllegalArgumentException('Longitude direction must be E or W');\n      }\n\n      this.longitude = longTemp;\n    }\n  }\n  /**\r\n   * @return Returns the longitude.\r\n   */\n\n\n  getLongitude() {\n    return this.longitude;\n  }\n  /**\r\n   * @return Returns the location name.\r\n   */\n\n\n  getLocationName() {\n    return this.locationName;\n  }\n  /**\r\n   * @param name\r\n   *            The setter method for the display name.\r\n   */\n\n\n  setLocationName(name) {\n    this.locationName = name;\n  }\n  /**\r\n   * @return Returns the timeZone.\r\n   */\n\n\n  getTimeZone() {\n    return this.timeZoneId;\n  }\n  /**\r\n   * Method to set the TimeZone. If this is ever set after the GeoLocation is set in the\r\n   * {@link net.sourceforge.zmanim.AstronomicalCalendar}, it is critical that\r\n   * {@link net.sourceforge.zmanim.AstronomicalCalendar#getCalendar()}.\r\n   * {@link java.util.Calendar#setTimeZone(TimeZone) setTimeZone(TimeZone)} be called in order for the\r\n   * AstronomicalCalendar to output times in the expected offset. This situation will arise if the\r\n   * AstronomicalCalendar is ever {@link net.sourceforge.zmanim.AstronomicalCalendar#clone() cloned}.\r\n   *\r\n   * @param timeZone\r\n   *            The timeZone to set.\r\n   */\n\n\n  setTimeZone(timeZoneId) {\n    this.timeZoneId = timeZoneId;\n  }\n  /**\r\n   * A method that will return the location's local mean time offset in milliseconds from local <a\r\n   * href=\"http://en.wikipedia.org/wiki/Standard_time\">standard time</a>. The globe is split into 360&deg;, with\r\n   * 15&deg; per hour of the day. For a local that is at a longitude that is evenly divisible by 15 (longitude % 15 ==\r\n   * 0), at solar {@link net.sourceforge.zmanim.AstronomicalCalendar#getSunTransit() noon} (with adjustment for the <a\r\n   * href=\"http://en.wikipedia.org/wiki/Equation_of_time\">equation of time</a>) the sun should be directly overhead,\r\n   * so a user who is 1&deg; west of this will have noon at 4 minutes after standard time noon, and conversely, a user\r\n   * who is 1&deg; east of the 15&deg; longitude will have noon at 11:56 AM. Lakewood, N.J., whose longitude is\r\n   * -74.2094, is 0.7906 away from the closest multiple of 15 at -75&deg;. This is multiplied by 4 to yield 3 minutes\r\n   * and 10 seconds earlier than standard time. The offset returned does not account for the <a\r\n   * href=\"http://en.wikipedia.org/wiki/Daylight_saving_time\">Daylight saving time</a> offset since this class is\r\n   * unaware of dates.\r\n   *\r\n   * @return the offset in milliseconds not accounting for Daylight saving time. A positive value will be returned\r\n   *         East of the 15&deg; timezone line, and a negative value West of it.\r\n   * @since 1.1\r\n   */\n\n\n  getLocalMeanTimeOffset() {\n    return this.getLongitude() * 4 * GeoLocation.MINUTE_MILLIS - TimeZone.getRawOffset(this.getTimeZone());\n  }\n  /**\r\n   * Adjust the date for <a href=\"https://en.wikipedia.org/wiki/180th_meridian\">antimeridian</a> crossover. This is\r\n   * needed to deal with edge cases such as Samoa that use a different calendar date than expected based on their\r\n   * geographic location.\r\n   *\r\n   * The actual Time Zone offset may deviate from the expected offset based on the longitude. Since the 'absolute time'\r\n   * calculations are always based on longitudinal offset from UTC for a given date, the date is presumed to only\r\n   * increase East of the Prime Meridian, and to only decrease West of it. For Time Zones that cross the antimeridian,\r\n   * the date will be artificially adjusted before calculation to conform with this presumption.\r\n   *\r\n   * For example, Apia, Samoa with a longitude of -171.75 uses a local offset of +14:00.  When calculating sunrise for\r\n   * 2018-02-03, the calculator should operate using 2018-02-02 since the expected zone is -11.  After determining the\r\n   * UTC time, the local DST offset of <a href=\"https://en.wikipedia.org/wiki/UTC%2B14:00\">UTC+14:00</a> should be applied\r\n   * to bring the date back to 2018-02-03.\r\n   *\r\n   * @return the number of days to adjust the date This will typically be 0 unless the date crosses the antimeridian\r\n   */\n\n\n  getAntimeridianAdjustment() {\n    const localHoursOffset = this.getLocalMeanTimeOffset() / GeoLocation.HOUR_MILLIS; // if the offset is 20 hours or more in the future (never expected anywhere other\n    // than a location using a timezone across the anti meridian to the east such as Samoa)\n\n    if (localHoursOffset >= 20) {\n      // roll the date forward a day\n      return 1;\n    } else if (localHoursOffset <= -20) {\n      // if the offset is 20 hours or more in the past (no current location is known\n      // that crosses the antimeridian to the west, but better safe than sorry)\n      // roll the date back a day\n      return -1;\n    } // 99.999% of the world will have no adjustment\n\n\n    return 0;\n  }\n  /**\r\n   * Calculate the initial <a href=\"http://en.wikipedia.org/wiki/Great_circle\">geodesic</a> bearing between this\r\n   * Object and a second Object passed to this method using <a\r\n   * href=\"http://en.wikipedia.org/wiki/Thaddeus_Vincenty\">Thaddeus Vincenty's</a> inverse formula See T Vincenty, \"<a\r\n   * href=\"http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf\">Direct and Inverse Solutions of Geodesics on the Ellipsoid\r\n   * with application of nested equations</a>\", Survey Review, vol XXII no 176, 1975\r\n   *\r\n   * @param location\r\n   *            the destination location\r\n   * @return the initial bearing\r\n   */\n\n\n  getGeodesicInitialBearing(location) {\n    return this.vincentyFormula(location, GeoLocation.INITIAL_BEARING);\n  }\n  /**\r\n   * Calculate the final <a href=\"http://en.wikipedia.org/wiki/Great_circle\">geodesic</a> bearing between this Object\r\n   * and a second Object passed to this method using <a href=\"http://en.wikipedia.org/wiki/Thaddeus_Vincenty\">Thaddeus\r\n   * Vincenty's</a> inverse formula See T Vincenty, \"<a href=\"http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf\">Direct and\r\n   * Inverse Solutions of Geodesics on the Ellipsoid with application of nested equations</a>\", Survey Review, vol\r\n   * XXII no 176, 1975\r\n   *\r\n   * @param location\r\n   *            the destination location\r\n   * @return the final bearing\r\n   */\n\n\n  getGeodesicFinalBearing(location) {\n    return this.vincentyFormula(location, GeoLocation.FINAL_BEARING);\n  }\n  /**\r\n   * Calculate <a href=\"http://en.wikipedia.org/wiki/Great-circle_distance\">geodesic distance</a> in Meters between\r\n   * this Object and a second Object passed to this method using <a\r\n   * href=\"http://en.wikipedia.org/wiki/Thaddeus_Vincenty\">Thaddeus Vincenty's</a> inverse formula See T Vincenty, \"<a\r\n   * href=\"http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf\">Direct and Inverse Solutions of Geodesics on the Ellipsoid\r\n   * with application of nested equations</a>\", Survey Review, vol XXII no 176, 1975\r\n   *\r\n   * @see #vincentyFormula(GeoLocation, int)\r\n   * @param location\r\n   *            the destination location\r\n   * @return the geodesic distance in Meters\r\n   */\n\n\n  getGeodesicDistance(location) {\n    return this.vincentyFormula(location, GeoLocation.DISTANCE);\n  }\n  /**\r\n   * Calculate <a href=\"http://en.wikipedia.org/wiki/Great-circle_distance\">geodesic distance</a> in Meters between\r\n   * this Object and a second Object passed to this method using <a\r\n   * href=\"http://en.wikipedia.org/wiki/Thaddeus_Vincenty\">Thaddeus Vincenty's</a> inverse formula See T Vincenty, \"<a\r\n   * href=\"http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf\">Direct and Inverse Solutions of Geodesics on the Ellipsoid\r\n   * with application of nested equations</a>\", Survey Review, vol XXII no 176, 1975\r\n   *\r\n   * @param location\r\n   *            the destination location\r\n   * @param formula\r\n   *            This formula calculates initial bearing ({@link #INITIAL_BEARING}), final bearing (\r\n   *            {@link #FINAL_BEARING}) and distance ({@link #DISTANCE}).\r\n   * @return geodesic distance in Meters\r\n   */\n\n\n  vincentyFormula(location, formula) {\n    const a = 6378137;\n    const b = 6356752.3142;\n    const f = 1 / 298.257223563; // WGS-84 ellipsiod\n\n    const L = MathUtils.degreesToRadians(location.getLongitude() - this.getLongitude());\n    const U1 = Math.atan((1 - f) * Math.tan(MathUtils.degreesToRadians(this.getLatitude())));\n    const U2 = Math.atan((1 - f) * Math.tan(MathUtils.degreesToRadians(location.getLatitude())));\n    const sinU1 = Math.sin(U1);\n    const cosU1 = Math.cos(U1);\n    const sinU2 = Math.sin(U2);\n    const cosU2 = Math.cos(U2);\n    let lambda = L;\n    let lambdaP = 2 * Math.PI;\n    let iterLimit = 20;\n    let sinLambda = 0;\n    let cosLambda = 0;\n    let sinSigma = 0;\n    let cosSigma = 0;\n    let sigma = 0;\n    let sinAlpha = 0;\n    let cosSqAlpha = 0;\n    let cos2SigmaM = 0;\n    let C;\n\n    while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0) {\n      sinLambda = Math.sin(lambda);\n      cosLambda = Math.cos(lambda);\n      sinSigma = Math.sqrt(cosU2 * sinLambda * (cosU2 * sinLambda) + (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));\n      if (sinSigma === 0) return 0; // co-incident points\n\n      cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;\n      sigma = Math.atan2(sinSigma, cosSigma);\n      sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;\n      cosSqAlpha = 1 - sinAlpha * sinAlpha;\n      cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;\n      if (Number.isNaN(cos2SigmaM)) cos2SigmaM = 0; // equatorial line: cosSqAlpha=0 (§6)\n\n      C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));\n      lambdaP = lambda;\n      lambda = L + (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));\n    }\n\n    if (iterLimit === 0) return Number.NaN; // formula failed to converge\n\n    const uSq = cosSqAlpha * (a * a - b * b) / (b * b);\n    const A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));\n    const B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));\n    const deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));\n    const distance = b * A * (sigma - deltaSigma); // initial bearing\n\n    const fwdAz = MathUtils.radiansToDegrees(Math.atan2(cosU2 * sinLambda, cosU1 * sinU2 - sinU1 * cosU2 * cosLambda)); // final bearing\n\n    const revAz = MathUtils.radiansToDegrees(Math.atan2(cosU1 * sinLambda, -sinU1 * cosU2 + cosU1 * sinU2 * cosLambda));\n\n    if (formula === GeoLocation.DISTANCE) {\n      return distance;\n    } else if (formula === GeoLocation.INITIAL_BEARING) {\n      return fwdAz;\n    } else if (formula === GeoLocation.FINAL_BEARING) {\n      return revAz;\n    } // should never happen\n\n\n    return Number.NaN;\n  }\n  /**\r\n   * Returns the <a href=\"http://en.wikipedia.org/wiki/Rhumb_line\">rhumb line</a> bearing from the current location to\r\n   * the GeoLocation passed in.\r\n   *\r\n   * @param location\r\n   *            destination location\r\n   * @return the bearing in degrees\r\n   */\n\n\n  getRhumbLineBearing(location) {\n    let dLon = MathUtils.degreesToRadians(location.getLongitude() - this.getLongitude());\n    const dPhi = Math.log(Math.tan(MathUtils.degreesToRadians(location.getLatitude()) / 2 + Math.PI / 4) / Math.tan(MathUtils.degreesToRadians(this.getLatitude()) / 2 + Math.PI / 4));\n    if (Math.abs(dLon) > Math.PI) dLon = dLon > 0 ? -(2 * Math.PI - dLon) : 2 * Math.PI + dLon;\n    return MathUtils.radiansToDegrees(Math.atan2(dLon, dPhi));\n  }\n  /**\r\n   * Returns the <a href=\"http://en.wikipedia.org/wiki/Rhumb_line\">rhumb line</a> distance from the current location\r\n   * to the GeoLocation passed in.\r\n   *\r\n   * @param location\r\n   *            the destination location\r\n   * @return the distance in Meters\r\n   */\n\n\n  getRhumbLineDistance(location) {\n    const earthRadius = 6378137; // earth's mean radius in km\n\n    const dLat = MathUtils.degreesToRadians(location.getLatitude()) - MathUtils.degreesToRadians(this.getLatitude());\n    let dLon = Math.abs(MathUtils.degreesToRadians(location.getLongitude()) - MathUtils.degreesToRadians(this.getLongitude()));\n    const dPhi = Math.log(Math.tan(MathUtils.degreesToRadians(location.getLatitude()) / 2 + Math.PI / 4) / Math.tan(MathUtils.degreesToRadians(this.getLatitude()) / 2 + Math.PI / 4));\n    let q = dLat / dPhi;\n\n    if (!Number.isFinite(q)) {\n      q = Math.cos(MathUtils.degreesToRadians(this.getLatitude()));\n    } // if dLon over 180° take shorter rhumb across 180° meridian:\n\n\n    if (dLon > Math.PI) {\n      dLon = 2 * Math.PI - dLon;\n    }\n\n    const d = Math.sqrt(dLat * dLat + q * q * dLon * dLon);\n    return d * earthRadius;\n  }\n  /**\r\n   * A method that returns an XML formatted <code>String</code> representing the serialized <code>Object</code>. Very\r\n   * similar to the toString method but the return value is in an xml format. The format currently used (subject to\r\n   * change) is:\r\n   *\r\n   * <pre>\r\n   *   &lt;GeoLocation&gt;\r\n   *        &lt;LocationName&gt;Lakewood, NJ&lt;/LocationName&gt;\r\n   *        &lt;Latitude&gt;40.0828&amp;deg&lt;/Latitude&gt;\r\n   *        &lt;Longitude&gt;-74.2094&amp;deg&lt;/Longitude&gt;\r\n   *        &lt;Elevation&gt;0 Meters&lt;/Elevation&gt;\r\n   *        &lt;TimezoneName&gt;America/New_York&lt;/TimezoneName&gt;\r\n   *        &lt;TimeZoneDisplayName&gt;Eastern Standard Time&lt;/TimeZoneDisplayName&gt;\r\n   *        &lt;TimezoneGMTOffset&gt;-5&lt;/TimezoneGMTOffset&gt;\r\n   *        &lt;TimezoneDSTOffset&gt;1&lt;/TimezoneDSTOffset&gt;\r\n   *   &lt;/GeoLocation&gt;\r\n   * </pre>\r\n   *\r\n   * @return The XML formatted <code>String</code>.\r\n   * @deprecated\r\n   */\n  // eslint-disable-next-line class-methods-use-this\n\n\n  toXML() {\n    throw new UnsupportedError('This method is deprecated');\n  }\n  /**\r\n   * @see java.lang.Object#equals(Object)\r\n   */\n\n\n  equals(object) {\n    if (this === object) return true;\n    if (!(object instanceof GeoLocation)) return false;\n    const geo = object;\n    return this.latitude === geo.latitude && this.longitude === geo.longitude && this.elevation === geo.elevation && this.locationName === geo.locationName && this.timeZoneId === geo.getTimeZone();\n  }\n  /**\r\n   * @see java.lang.Object#toString()\r\n   */\n\n\n  toString() {\n    return `Location Name:\\t\\t\\t${this.getLocationName()}`.concat(`\\nLatitude:\\t\\t\\t${this.getLatitude().toString()}\\u00B0`).concat(`\\nLongitude:\\t\\t\\t${this.getLongitude().toString()}\\u00B0`).concat(`\\nElevation:\\t\\t\\t${this.getElevation().toString()} Meters`).concat(`\\nTimezone ID:\\t\\t\\t${this.getTimeZone()}`).concat(`\\nTimezone Display Name:\\t\\t${TimeZone.getDisplayName(this.getTimeZone())}`).concat(` (${TimeZone.getDisplayName(this.getTimeZone(), DateTime.local(), true)})`).concat(`\\nTimezone GMT Offset:\\t\\t${(TimeZone.getRawOffset(this.getTimeZone()) / GeoLocation.HOUR_MILLIS).toString()}`).concat(`\\nTimezone DST Offset:\\t\\t${(TimeZone.getDSTSavings(this.getTimeZone()) / GeoLocation.HOUR_MILLIS).toString()}`);\n  }\n  /**\r\n   * An implementation of the {@link java.lang.Object#clone()} method that creates a <a\r\n   * href=\"http://en.wikipedia.org/wiki/Object_copy#Deep_copy\">deep copy</a> of the object.\r\n   * <b>Note:</b> If the {@link java.util.TimeZone} in the clone will be changed from the original, it is critical\r\n   * that {@link net.sourceforge.zmanim.AstronomicalCalendar#getCalendar()}.\r\n   * {@link java.util.Calendar#setTimeZone(TimeZone) setTimeZone(TimeZone)} is called after cloning in order for the\r\n   * AstronomicalCalendar to output times in the expected offset.\r\n   *\r\n   * @see java.lang.Object#clone()\r\n   * @since 1.1\r\n   */\n\n\n  clone() {\n    return JSON.parse(JSON.stringify(this));\n  }\n\n}\nGeoLocation.DISTANCE = 0;\nGeoLocation.INITIAL_BEARING = 1;\nGeoLocation.FINAL_BEARING = 2;\n/** constant for milliseconds in a minute (60,000) */\n\nGeoLocation.MINUTE_MILLIS = 60 * 1000;\n/** constant for milliseconds in an hour (3,600,000) */\n\nGeoLocation.HOUR_MILLIS = GeoLocation.MINUTE_MILLIS * 60;","map":{"version":3,"sources":["../../../src/util/GeoLocation.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { DateTime } from 'luxon';\r\nimport { MathUtils, TimeZone } from '../polyfills/Utils';\r\nimport { IllegalArgumentException, UnsupportedError } from '../polyfills/errors';\r\n/**\r\n * A class that contains location information such as latitude and longitude required for astronomical calculations. The\r\n * elevation field may not be used by some calculation engines and would be ignored if set. Check the documentation for\r\n * specific implementations of the {@link AstronomicalCalculator} to see if elevation is calculated as part of the\r\n * algorithm.\r\n *\r\n * @author &copy; Eliyahu Hershfeld 2004 - 2016\r\n * @version 1.1\r\n */\r\nexport class GeoLocation {\r\n    constructor(name = 'Greenwich, England', latitude = 51.4772, longitude = 0, elevationOrTimeZoneId, timeZoneId) {\r\n        this.locationName = null;\r\n        let elevation = 0;\r\n        if (timeZoneId) {\r\n            elevation = elevationOrTimeZoneId;\r\n        }\r\n        else {\r\n            timeZoneId = elevationOrTimeZoneId;\r\n        }\r\n        this.setLocationName(name);\r\n        this.setLatitude(latitude);\r\n        this.setLongitude(longitude);\r\n        this.setElevation(elevation);\r\n        this.setTimeZone(timeZoneId);\r\n    }\r\n    /**\r\n     * Method to get the elevation in Meters.\r\n     *\r\n     * @return Returns the elevation in Meters.\r\n     */\r\n    getElevation() {\r\n        return this.elevation;\r\n    }\r\n    /**\r\n     * Method to set the elevation in Meters <b>above </b> sea level.\r\n     *\r\n     * @param elevation\r\n     *            The elevation to set in Meters. An IllegalArgumentException will be thrown if the value is a negative.\r\n     */\r\n    setElevation(elevation) {\r\n        if (elevation < 0) {\r\n            throw new IllegalArgumentException('Elevation cannot be negative');\r\n        }\r\n        this.elevation = elevation;\r\n    }\r\n    setLatitude(degreesOrLatitude, minutes, seconds, direction) {\r\n        if (!minutes) {\r\n            const latitude = degreesOrLatitude;\r\n            if (latitude > 90 || latitude < -90) {\r\n                throw new IllegalArgumentException('Latitude must be between -90 and  90');\r\n            }\r\n            this.latitude = latitude;\r\n        }\r\n        else {\r\n            const degrees = degreesOrLatitude;\r\n            let tempLat = degrees + ((minutes + (seconds / 60)) / 60);\r\n            if (tempLat > 90 || tempLat < 0) { // FIXME An exception should be thrown if degrees, minutes or seconds are negative\r\n                throw new IllegalArgumentException('Latitude must be between 0 and  90. Use direction of S instead of negative.');\r\n            }\r\n            if (direction === 'S') {\r\n                tempLat *= -1;\r\n            }\r\n            else if (!(direction === 'N')) {\r\n                throw new IllegalArgumentException('Latitude direction must be N or S');\r\n            }\r\n            this.latitude = tempLat;\r\n        }\r\n    }\r\n    /**\r\n     * @return Returns the latitude.\r\n     */\r\n    getLatitude() {\r\n        return this.latitude;\r\n    }\r\n    setLongitude(degreesOrLongitude, minutes, seconds, direction) {\r\n        if (!minutes) {\r\n            const longitude = degreesOrLongitude;\r\n            if (longitude > 180 || longitude < -180) {\r\n                throw new IllegalArgumentException('Longitude must be between -180 and  180');\r\n            }\r\n            this.longitude = longitude;\r\n        }\r\n        else {\r\n            const degrees = degreesOrLongitude;\r\n            let longTemp = degrees + ((minutes + (seconds / 60)) / 60);\r\n            if (longTemp > 180 || this.longitude < 0) { // FIXME An exception should be thrown if degrees, minutes or seconds are negative\r\n                throw new IllegalArgumentException('Longitude must be between 0 and  180.  Use a direction of W instead of negative.');\r\n            }\r\n            if (direction === 'W') {\r\n                longTemp *= -1;\r\n            }\r\n            else if (!(direction === 'E')) {\r\n                throw new IllegalArgumentException('Longitude direction must be E or W');\r\n            }\r\n            this.longitude = longTemp;\r\n        }\r\n    }\r\n    /**\r\n     * @return Returns the longitude.\r\n     */\r\n    getLongitude() {\r\n        return this.longitude;\r\n    }\r\n    /**\r\n     * @return Returns the location name.\r\n     */\r\n    getLocationName() {\r\n        return this.locationName;\r\n    }\r\n    /**\r\n     * @param name\r\n     *            The setter method for the display name.\r\n     */\r\n    setLocationName(name) {\r\n        this.locationName = name;\r\n    }\r\n    /**\r\n     * @return Returns the timeZone.\r\n     */\r\n    getTimeZone() {\r\n        return this.timeZoneId;\r\n    }\r\n    /**\r\n     * Method to set the TimeZone. If this is ever set after the GeoLocation is set in the\r\n     * {@link net.sourceforge.zmanim.AstronomicalCalendar}, it is critical that\r\n     * {@link net.sourceforge.zmanim.AstronomicalCalendar#getCalendar()}.\r\n     * {@link java.util.Calendar#setTimeZone(TimeZone) setTimeZone(TimeZone)} be called in order for the\r\n     * AstronomicalCalendar to output times in the expected offset. This situation will arise if the\r\n     * AstronomicalCalendar is ever {@link net.sourceforge.zmanim.AstronomicalCalendar#clone() cloned}.\r\n     *\r\n     * @param timeZone\r\n     *            The timeZone to set.\r\n     */\r\n    setTimeZone(timeZoneId) {\r\n        this.timeZoneId = timeZoneId;\r\n    }\r\n    /**\r\n     * A method that will return the location's local mean time offset in milliseconds from local <a\r\n     * href=\"http://en.wikipedia.org/wiki/Standard_time\">standard time</a>. The globe is split into 360&deg;, with\r\n     * 15&deg; per hour of the day. For a local that is at a longitude that is evenly divisible by 15 (longitude % 15 ==\r\n     * 0), at solar {@link net.sourceforge.zmanim.AstronomicalCalendar#getSunTransit() noon} (with adjustment for the <a\r\n     * href=\"http://en.wikipedia.org/wiki/Equation_of_time\">equation of time</a>) the sun should be directly overhead,\r\n     * so a user who is 1&deg; west of this will have noon at 4 minutes after standard time noon, and conversely, a user\r\n     * who is 1&deg; east of the 15&deg; longitude will have noon at 11:56 AM. Lakewood, N.J., whose longitude is\r\n     * -74.2094, is 0.7906 away from the closest multiple of 15 at -75&deg;. This is multiplied by 4 to yield 3 minutes\r\n     * and 10 seconds earlier than standard time. The offset returned does not account for the <a\r\n     * href=\"http://en.wikipedia.org/wiki/Daylight_saving_time\">Daylight saving time</a> offset since this class is\r\n     * unaware of dates.\r\n     *\r\n     * @return the offset in milliseconds not accounting for Daylight saving time. A positive value will be returned\r\n     *         East of the 15&deg; timezone line, and a negative value West of it.\r\n     * @since 1.1\r\n     */\r\n    getLocalMeanTimeOffset() {\r\n        return this.getLongitude() * 4 * GeoLocation.MINUTE_MILLIS - TimeZone.getRawOffset(this.getTimeZone());\r\n    }\r\n    /**\r\n     * Adjust the date for <a href=\"https://en.wikipedia.org/wiki/180th_meridian\">antimeridian</a> crossover. This is\r\n     * needed to deal with edge cases such as Samoa that use a different calendar date than expected based on their\r\n     * geographic location.\r\n     *\r\n     * The actual Time Zone offset may deviate from the expected offset based on the longitude. Since the 'absolute time'\r\n     * calculations are always based on longitudinal offset from UTC for a given date, the date is presumed to only\r\n     * increase East of the Prime Meridian, and to only decrease West of it. For Time Zones that cross the antimeridian,\r\n     * the date will be artificially adjusted before calculation to conform with this presumption.\r\n     *\r\n     * For example, Apia, Samoa with a longitude of -171.75 uses a local offset of +14:00.  When calculating sunrise for\r\n     * 2018-02-03, the calculator should operate using 2018-02-02 since the expected zone is -11.  After determining the\r\n     * UTC time, the local DST offset of <a href=\"https://en.wikipedia.org/wiki/UTC%2B14:00\">UTC+14:00</a> should be applied\r\n     * to bring the date back to 2018-02-03.\r\n     *\r\n     * @return the number of days to adjust the date This will typically be 0 unless the date crosses the antimeridian\r\n     */\r\n    getAntimeridianAdjustment() {\r\n        const localHoursOffset = this.getLocalMeanTimeOffset() / GeoLocation.HOUR_MILLIS;\r\n        // if the offset is 20 hours or more in the future (never expected anywhere other\r\n        // than a location using a timezone across the anti meridian to the east such as Samoa)\r\n        if (localHoursOffset >= 20) {\r\n            // roll the date forward a day\r\n            return 1;\r\n        }\r\n        else if (localHoursOffset <= -20) {\r\n            // if the offset is 20 hours or more in the past (no current location is known\r\n            // that crosses the antimeridian to the west, but better safe than sorry)\r\n            // roll the date back a day\r\n            return -1;\r\n        }\r\n        // 99.999% of the world will have no adjustment\r\n        return 0;\r\n    }\r\n    /**\r\n     * Calculate the initial <a href=\"http://en.wikipedia.org/wiki/Great_circle\">geodesic</a> bearing between this\r\n     * Object and a second Object passed to this method using <a\r\n     * href=\"http://en.wikipedia.org/wiki/Thaddeus_Vincenty\">Thaddeus Vincenty's</a> inverse formula See T Vincenty, \"<a\r\n     * href=\"http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf\">Direct and Inverse Solutions of Geodesics on the Ellipsoid\r\n     * with application of nested equations</a>\", Survey Review, vol XXII no 176, 1975\r\n     *\r\n     * @param location\r\n     *            the destination location\r\n     * @return the initial bearing\r\n     */\r\n    getGeodesicInitialBearing(location) {\r\n        return this.vincentyFormula(location, GeoLocation.INITIAL_BEARING);\r\n    }\r\n    /**\r\n     * Calculate the final <a href=\"http://en.wikipedia.org/wiki/Great_circle\">geodesic</a> bearing between this Object\r\n     * and a second Object passed to this method using <a href=\"http://en.wikipedia.org/wiki/Thaddeus_Vincenty\">Thaddeus\r\n     * Vincenty's</a> inverse formula See T Vincenty, \"<a href=\"http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf\">Direct and\r\n     * Inverse Solutions of Geodesics on the Ellipsoid with application of nested equations</a>\", Survey Review, vol\r\n     * XXII no 176, 1975\r\n     *\r\n     * @param location\r\n     *            the destination location\r\n     * @return the final bearing\r\n     */\r\n    getGeodesicFinalBearing(location) {\r\n        return this.vincentyFormula(location, GeoLocation.FINAL_BEARING);\r\n    }\r\n    /**\r\n     * Calculate <a href=\"http://en.wikipedia.org/wiki/Great-circle_distance\">geodesic distance</a> in Meters between\r\n     * this Object and a second Object passed to this method using <a\r\n     * href=\"http://en.wikipedia.org/wiki/Thaddeus_Vincenty\">Thaddeus Vincenty's</a> inverse formula See T Vincenty, \"<a\r\n     * href=\"http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf\">Direct and Inverse Solutions of Geodesics on the Ellipsoid\r\n     * with application of nested equations</a>\", Survey Review, vol XXII no 176, 1975\r\n     *\r\n     * @see #vincentyFormula(GeoLocation, int)\r\n     * @param location\r\n     *            the destination location\r\n     * @return the geodesic distance in Meters\r\n     */\r\n    getGeodesicDistance(location) {\r\n        return this.vincentyFormula(location, GeoLocation.DISTANCE);\r\n    }\r\n    /**\r\n     * Calculate <a href=\"http://en.wikipedia.org/wiki/Great-circle_distance\">geodesic distance</a> in Meters between\r\n     * this Object and a second Object passed to this method using <a\r\n     * href=\"http://en.wikipedia.org/wiki/Thaddeus_Vincenty\">Thaddeus Vincenty's</a> inverse formula See T Vincenty, \"<a\r\n     * href=\"http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf\">Direct and Inverse Solutions of Geodesics on the Ellipsoid\r\n     * with application of nested equations</a>\", Survey Review, vol XXII no 176, 1975\r\n     *\r\n     * @param location\r\n     *            the destination location\r\n     * @param formula\r\n     *            This formula calculates initial bearing ({@link #INITIAL_BEARING}), final bearing (\r\n     *            {@link #FINAL_BEARING}) and distance ({@link #DISTANCE}).\r\n     * @return geodesic distance in Meters\r\n     */\r\n    vincentyFormula(location, formula) {\r\n        const a = 6378137;\r\n        const b = 6356752.3142;\r\n        const f = 1 / 298.257223563; // WGS-84 ellipsiod\r\n        const L = MathUtils.degreesToRadians(location.getLongitude() - this.getLongitude());\r\n        const U1 = Math.atan((1 - f) * Math.tan(MathUtils.degreesToRadians(this.getLatitude())));\r\n        const U2 = Math.atan((1 - f) * Math.tan(MathUtils.degreesToRadians(location.getLatitude())));\r\n        const sinU1 = Math.sin(U1);\r\n        const cosU1 = Math.cos(U1);\r\n        const sinU2 = Math.sin(U2);\r\n        const cosU2 = Math.cos(U2);\r\n        let lambda = L;\r\n        let lambdaP = 2 * Math.PI;\r\n        let iterLimit = 20;\r\n        let sinLambda = 0;\r\n        let cosLambda = 0;\r\n        let sinSigma = 0;\r\n        let cosSigma = 0;\r\n        let sigma = 0;\r\n        let sinAlpha = 0;\r\n        let cosSqAlpha = 0;\r\n        let cos2SigmaM = 0;\r\n        let C;\r\n        while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0) {\r\n            sinLambda = Math.sin(lambda);\r\n            cosLambda = Math.cos(lambda);\r\n            sinSigma = Math.sqrt((cosU2 * sinLambda) * (cosU2 * sinLambda)\r\n                + (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));\r\n            if (sinSigma === 0)\r\n                return 0; // co-incident points\r\n            cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;\r\n            sigma = Math.atan2(sinSigma, cosSigma);\r\n            sinAlpha = (cosU1 * cosU2 * sinLambda) / sinSigma;\r\n            cosSqAlpha = 1 - sinAlpha * sinAlpha;\r\n            cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;\r\n            if (Number.isNaN(cos2SigmaM))\r\n                cos2SigmaM = 0; // equatorial line: cosSqAlpha=0 (§6)\r\n            C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));\r\n            lambdaP = lambda;\r\n            lambda = L + (1 - C) * f * sinAlpha\r\n                * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));\r\n        }\r\n        if (iterLimit === 0)\r\n            return Number.NaN; // formula failed to converge\r\n        const uSq = cosSqAlpha * (a * a - b * b) / (b * b);\r\n        const A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));\r\n        const B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));\r\n        const deltaSigma = B * sinSigma\r\n            * (cos2SigmaM + B / 4\r\n                * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM\r\n                    * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));\r\n        const distance = b * A * (sigma - deltaSigma);\r\n        // initial bearing\r\n        const fwdAz = MathUtils.radiansToDegrees(Math.atan2(cosU2 * sinLambda, cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));\r\n        // final bearing\r\n        const revAz = MathUtils.radiansToDegrees(Math.atan2(cosU1 * sinLambda, -sinU1 * cosU2 + cosU1 * sinU2 * cosLambda));\r\n        if (formula === GeoLocation.DISTANCE) {\r\n            return distance;\r\n        }\r\n        else if (formula === GeoLocation.INITIAL_BEARING) {\r\n            return fwdAz;\r\n        }\r\n        else if (formula === GeoLocation.FINAL_BEARING) {\r\n            return revAz;\r\n        }\r\n        // should never happen\r\n        return Number.NaN;\r\n    }\r\n    /**\r\n     * Returns the <a href=\"http://en.wikipedia.org/wiki/Rhumb_line\">rhumb line</a> bearing from the current location to\r\n     * the GeoLocation passed in.\r\n     *\r\n     * @param location\r\n     *            destination location\r\n     * @return the bearing in degrees\r\n     */\r\n    getRhumbLineBearing(location) {\r\n        let dLon = MathUtils.degreesToRadians(location.getLongitude() - this.getLongitude());\r\n        const dPhi = Math.log(Math.tan(MathUtils.degreesToRadians(location.getLatitude()) / 2 + Math.PI / 4)\r\n            / Math.tan(MathUtils.degreesToRadians(this.getLatitude()) / 2 + Math.PI / 4));\r\n        if (Math.abs(dLon) > Math.PI)\r\n            dLon = dLon > 0 ? -(2 * Math.PI - dLon) : (2 * Math.PI + dLon);\r\n        return MathUtils.radiansToDegrees(Math.atan2(dLon, dPhi));\r\n    }\r\n    /**\r\n     * Returns the <a href=\"http://en.wikipedia.org/wiki/Rhumb_line\">rhumb line</a> distance from the current location\r\n     * to the GeoLocation passed in.\r\n     *\r\n     * @param location\r\n     *            the destination location\r\n     * @return the distance in Meters\r\n     */\r\n    getRhumbLineDistance(location) {\r\n        const earthRadius = 6378137; // earth's mean radius in km\r\n        const dLat = MathUtils.degreesToRadians(location.getLatitude()) - MathUtils.degreesToRadians(this.getLatitude());\r\n        let dLon = Math.abs(MathUtils.degreesToRadians(location.getLongitude()) - MathUtils.degreesToRadians(this.getLongitude()));\r\n        const dPhi = Math.log(Math.tan(MathUtils.degreesToRadians(location.getLatitude()) / 2 + Math.PI / 4)\r\n            / Math.tan(MathUtils.degreesToRadians(this.getLatitude()) / 2 + Math.PI / 4));\r\n        let q = dLat / dPhi;\r\n        if (!Number.isFinite(q)) {\r\n            q = Math.cos(MathUtils.degreesToRadians(this.getLatitude()));\r\n        }\r\n        // if dLon over 180° take shorter rhumb across 180° meridian:\r\n        if (dLon > Math.PI) {\r\n            dLon = 2 * Math.PI - dLon;\r\n        }\r\n        const d = Math.sqrt(dLat * dLat + q * q * dLon * dLon);\r\n        return d * earthRadius;\r\n    }\r\n    /**\r\n     * A method that returns an XML formatted <code>String</code> representing the serialized <code>Object</code>. Very\r\n     * similar to the toString method but the return value is in an xml format. The format currently used (subject to\r\n     * change) is:\r\n     *\r\n     * <pre>\r\n     *   &lt;GeoLocation&gt;\r\n     *        &lt;LocationName&gt;Lakewood, NJ&lt;/LocationName&gt;\r\n     *        &lt;Latitude&gt;40.0828&amp;deg&lt;/Latitude&gt;\r\n     *        &lt;Longitude&gt;-74.2094&amp;deg&lt;/Longitude&gt;\r\n     *        &lt;Elevation&gt;0 Meters&lt;/Elevation&gt;\r\n     *        &lt;TimezoneName&gt;America/New_York&lt;/TimezoneName&gt;\r\n     *        &lt;TimeZoneDisplayName&gt;Eastern Standard Time&lt;/TimeZoneDisplayName&gt;\r\n     *        &lt;TimezoneGMTOffset&gt;-5&lt;/TimezoneGMTOffset&gt;\r\n     *        &lt;TimezoneDSTOffset&gt;1&lt;/TimezoneDSTOffset&gt;\r\n     *   &lt;/GeoLocation&gt;\r\n     * </pre>\r\n     *\r\n     * @return The XML formatted <code>String</code>.\r\n     * @deprecated\r\n     */\r\n    // eslint-disable-next-line class-methods-use-this\r\n    toXML() {\r\n        throw new UnsupportedError('This method is deprecated');\r\n    }\r\n    /**\r\n     * @see java.lang.Object#equals(Object)\r\n     */\r\n    equals(object) {\r\n        if (this === object)\r\n            return true;\r\n        if (!(object instanceof GeoLocation))\r\n            return false;\r\n        const geo = object;\r\n        return this.latitude === geo.latitude\r\n            && this.longitude === geo.longitude\r\n            && this.elevation === geo.elevation\r\n            && this.locationName === geo.locationName\r\n            && this.timeZoneId === geo.getTimeZone();\r\n    }\r\n    /**\r\n     * @see java.lang.Object#toString()\r\n     */\r\n    toString() {\r\n        return (`Location Name:\\t\\t\\t${this.getLocationName()}`)\r\n            .concat(`\\nLatitude:\\t\\t\\t${this.getLatitude().toString()}\\u00B0`)\r\n            .concat(`\\nLongitude:\\t\\t\\t${this.getLongitude().toString()}\\u00B0`)\r\n            .concat(`\\nElevation:\\t\\t\\t${this.getElevation().toString()} Meters`)\r\n            .concat(`\\nTimezone ID:\\t\\t\\t${this.getTimeZone()}`)\r\n            .concat(`\\nTimezone Display Name:\\t\\t${TimeZone.getDisplayName(this.getTimeZone())}`)\r\n            .concat(` (${TimeZone.getDisplayName(this.getTimeZone(), DateTime.local(), true)})`)\r\n            .concat(`\\nTimezone GMT Offset:\\t\\t${(TimeZone.getRawOffset(this.getTimeZone()) / GeoLocation.HOUR_MILLIS).toString()}`)\r\n            .concat(`\\nTimezone DST Offset:\\t\\t${(TimeZone.getDSTSavings(this.getTimeZone()) / GeoLocation.HOUR_MILLIS).toString()}`);\r\n    }\r\n    /**\r\n     * An implementation of the {@link java.lang.Object#clone()} method that creates a <a\r\n     * href=\"http://en.wikipedia.org/wiki/Object_copy#Deep_copy\">deep copy</a> of the object.\r\n     * <b>Note:</b> If the {@link java.util.TimeZone} in the clone will be changed from the original, it is critical\r\n     * that {@link net.sourceforge.zmanim.AstronomicalCalendar#getCalendar()}.\r\n     * {@link java.util.Calendar#setTimeZone(TimeZone) setTimeZone(TimeZone)} is called after cloning in order for the\r\n     * AstronomicalCalendar to output times in the expected offset.\r\n     *\r\n     * @see java.lang.Object#clone()\r\n     * @since 1.1\r\n     */\r\n    clone() {\r\n        return JSON.parse(JSON.stringify(this));\r\n    }\r\n}\r\nGeoLocation.DISTANCE = 0;\r\nGeoLocation.INITIAL_BEARING = 1;\r\nGeoLocation.FINAL_BEARING = 2;\r\n/** constant for milliseconds in a minute (60,000) */\r\nGeoLocation.MINUTE_MILLIS = 60 * 1000;\r\n/** constant for milliseconds in an hour (3,600,000) */\r\nGeoLocation.HOUR_MILLIS = GeoLocation.MINUTE_MILLIS * 60;\r\n//# sourceMappingURL=GeoLocation.js.map"]},"metadata":{},"sourceType":"module"}