{"ast":null,"code":"import { AstronomicalCalculator } from './AstronomicalCalculator';\nimport { MathUtils } from '../polyfills/Utils';\n/**\r\n * Implementation of sunrise and sunset methods to calculate astronomical times. This calculator uses the Java algorithm\r\n * written by <a href=\"http://web.archive.org/web/20090531215353/http://www.kevinboone.com/suntimes.html\">Kevin\r\n * Boone</a> that is based on the <a href = \"http://aa.usno.navy.mil/\">US Naval Observatory's</a><a\r\n * href=\"http://aa.usno.navy.mil/publications/docs/asa.php\">Almanac</a> for Computer algorithm ( <a\r\n * href=\"http://www.amazon.com/exec/obidos/tg/detail/-/0160515106/\">Amazon</a>, <a\r\n * href=\"http://search.barnesandnoble.com/booksearch/isbnInquiry.asp?isbn=0160515106\">Barnes &amp; Noble</a>) and is\r\n * used with his permission. Added to Kevin's code is adjustment of the zenith to account for elevation.\r\n *\r\n * @author &copy; Eliyahu Hershfeld 2004 - 2019\r\n * @author &copy; Kevin Boone 2000\r\n * @version 1.1\r\n */\n\nexport class SunTimesCalculator extends AstronomicalCalculator {\n  /**\r\n   * @see net.sourceforge.zmanim.util.AstronomicalCalculator#getCalculatorName()\r\n   */\n  // eslint-disable-next-line class-methods-use-this\n  getCalculatorName() {\n    return 'US Naval Almanac Algorithm';\n  }\n  /**\r\n   * @see net.sourceforge.zmanim.util.AstronomicalCalculator#getUTCSunrise(Calendar, GeoLocation, double, boolean)\r\n   */\n\n\n  getUTCSunrise(date, geoLocation, zenith, adjustForElevation) {\n    const elevation = adjustForElevation ? geoLocation.getElevation() : 0;\n    const adjustedZenith = this.adjustZenith(zenith, elevation);\n    const doubleTime = SunTimesCalculator.getTimeUTC(date, geoLocation.getLongitude(), geoLocation.getLatitude(), adjustedZenith, true);\n    return doubleTime;\n  }\n  /**\r\n   * @see net.sourceforge.zmanim.util.AstronomicalCalculator#getUTCSunset(Calendar, GeoLocation, double, boolean)\r\n   */\n\n\n  getUTCSunset(date, geoLocation, zenith, adjustForElevation) {\n    const elevation = adjustForElevation ? geoLocation.getElevation() : 0;\n    const adjustedZenith = this.adjustZenith(zenith, elevation);\n    const doubleTime = SunTimesCalculator.getTimeUTC(date, geoLocation.getLongitude(), geoLocation.getLatitude(), adjustedZenith, false);\n    return doubleTime;\n  }\n  /**\r\n   * sin of an angle in degrees\r\n   */\n\n\n  static sinDeg(deg) {\n    // return Math.sin(deg * 2 * Math.PI / 360);\n    return Math.sin(MathUtils.degreesToRadians(deg));\n  }\n  /**\r\n   * acos of an angle, result in degrees\r\n   */\n\n\n  static acosDeg(x) {\n    // return Math.acos(x) * 360 / (2 * Math.PI);\n    return MathUtils.radiansToDegrees(Math.acos(x));\n  }\n  /**\r\n   * asin of an angle, result in degrees\r\n   */\n\n\n  static asinDeg(x) {\n    // return Math.asin(x) * 360 / (2 * Math.PI);\n    return MathUtils.radiansToDegrees(Math.asin(x));\n  }\n  /**\r\n   * tan of an angle in degrees\r\n   */\n\n\n  static tanDeg(deg) {\n    // return Math.tan(deg * 2 * Math.PI / 360);\n    return Math.tan(MathUtils.degreesToRadians(deg));\n  }\n  /**\r\n   * Calculate cosine of the angle in degrees\r\n   *\r\n   * @param deg degrees\r\n   * @return cosine of the angle in degrees\r\n   */\n\n\n  static cosDeg(deg) {\n    // return Math.cos(deg * 2 * Math.PI / 360);\n    return Math.cos(MathUtils.degreesToRadians(deg));\n  }\n  /**\r\n   * Get time difference between location's longitude and the Meridian, in hours. West of Meridian has a negative time\r\n   * difference\r\n   */\n\n\n  static getHoursFromMeridian(longitude) {\n    return longitude / SunTimesCalculator.DEG_PER_HOUR;\n  }\n  /**\r\n   * Calculate the approximate time of sunset or sunrise in days since midnight Jan 1st, assuming 6am and 6pm events. We\r\n   * need this figure to derive the Sun's mean anomaly.\r\n   *\r\n   * @param dayOfYear the day of year\r\n   * @param hoursFromMeridian hours from the meridian\r\n   * @param isSunrise true for sunrise and false for sunset\r\n   *\r\n   * @return the approximate time of sunset or sunrise in days since midnight Jan 1st, assuming 6am and 6pm events. We\r\n   * need this figure to derive the Sun's mean anomaly.\r\n   */\n\n\n  static getApproxTimeDays(dayOfYear, hoursFromMeridian, isSunrise) {\n    if (isSunrise) {\n      return dayOfYear + (6 - hoursFromMeridian) / 24;\n    } // sunset\n\n\n    return dayOfYear + (18 - hoursFromMeridian) / 24;\n  }\n  /**\r\n   * Calculate the Sun's mean anomaly in degrees, at sunrise or sunset, given the longitude in degrees\r\n   *\r\n   * @param dayOfYear the day of the year\r\n   * @param longitude longitude\r\n   * @param isSunrise true for sunrise and false for sunset\r\n   * @return the Sun's mean anomaly in degrees\r\n   */\n\n\n  static getMeanAnomaly(dayOfYear, longitude, isSunrise) {\n    return 0.9856 * SunTimesCalculator.getApproxTimeDays(dayOfYear, SunTimesCalculator.getHoursFromMeridian(longitude), isSunrise) - 3.289;\n  }\n  /**\r\n   * Calculates the Sun's true longitude in degrees. The result is an angle gte 0 and lt 360. Requires the Sun's mean\r\n   * anomaly, also in degrees\r\n   */\n\n\n  static getSunTrueLongitude(sunMeanAnomaly) {\n    let l = sunMeanAnomaly + 1.916 * SunTimesCalculator.sinDeg(sunMeanAnomaly) + 0.020 * SunTimesCalculator.sinDeg(2 * sunMeanAnomaly) + 282.634; // get longitude into 0-360 degree range\n\n    if (l >= 360) {\n      l = l - 360;\n    }\n\n    if (l < 0) {\n      l = l + 360;\n    }\n\n    return l;\n  }\n  /**\r\n   * Calculates the Sun's right ascension in hours, given the Sun's true longitude in degrees. Input and output are\r\n   * angles gte 0 and lt 360.\r\n   */\n\n\n  static getSunRightAscensionHours(sunTrueLongitude) {\n    const a = 0.91764 * SunTimesCalculator.tanDeg(sunTrueLongitude);\n    let ra = 360 / (2 * Math.PI) * Math.atan(a);\n    const lQuadrant = Math.floor(sunTrueLongitude / 90) * 90;\n    const raQuadrant = Math.floor(ra / 90) * 90;\n    ra += lQuadrant - raQuadrant;\n    return ra / SunTimesCalculator.DEG_PER_HOUR; // convert to hours\n  }\n  /**\r\n   * Calculate the cosine of the Sun's local hour angle\r\n   *\r\n   * @param sunTrueLongitude the sun's true longitude\r\n   * @param latitude the latitude\r\n   * @param zenith the zenith\r\n   * @return the cosine of the Sun's local hour angle\r\n   */\n\n\n  static getCosLocalHourAngle(sunTrueLongitude, latitude, zenith) {\n    const sinDec = 0.39782 * SunTimesCalculator.sinDeg(sunTrueLongitude);\n    const cosDec = SunTimesCalculator.cosDeg(SunTimesCalculator.asinDeg(sinDec));\n    return (SunTimesCalculator.cosDeg(zenith) - sinDec * SunTimesCalculator.sinDeg(latitude)) / (cosDec * SunTimesCalculator.cosDeg(latitude));\n  }\n  /**\r\n   * Calculate local mean time of rising or setting. By `local' is meant the exact time at the location, assuming that\r\n   * there were no time zone. That is, the time difference between the location and the Meridian depended entirely on\r\n   * the longitude. We can't do anything with this time directly; we must convert it to UTC and then to a local time.\r\n   * The result is expressed as a fractional number of hours since midnight\r\n   *\r\n   * @param localHour the local hour\r\n   * @param sunRightAscensionHours the sun's right ascention in hours\r\n   * @param approxTimeDays approximate time days\r\n   *\r\n   * @return the fractional number of hours since midnight as a double\r\n   */\n\n\n  static getLocalMeanTime(localHour, sunRightAscensionHours, approxTimeDays) {\n    return localHour + sunRightAscensionHours - 0.06571 * approxTimeDays - 6.622;\n  }\n  /**\r\n   * Get sunrise or sunset time in UTC, according to flag.\r\n   *\r\n   * @param year\r\n   *            4-digit year\r\n   * @param month\r\n   *            month, 1-12 (not the zero based Java month\r\n   * @param day\r\n   *            day of month, 1-31\r\n   * @param longitude\r\n   *            in degrees, longitudes west of Meridian are negative\r\n   * @param latitude\r\n   *            in degrees, latitudes south of equator are negative\r\n   * @param zenith\r\n   *            Sun's zenith, in degrees\r\n   * @param type\r\n   *            type of calculation to carry out {@link #TYPE_SUNRISE} or {@link #TYPE_SUNRISE}.\r\n   *\r\n   * @return the time as a double. If an error was encountered in the calculation (expected behavior for some\r\n   *         locations such as near the poles, {@link Double.NaN} will be returned.\r\n   */\n\n\n  static getTimeUTC(date, longitude, latitude, zenith, isSunrise) {\n    const dayOfYear = date.ordinal;\n    const sunMeanAnomaly = SunTimesCalculator.getMeanAnomaly(dayOfYear, longitude, isSunrise);\n    const sunTrueLong = SunTimesCalculator.getSunTrueLongitude(sunMeanAnomaly);\n    const sunRightAscensionHours = SunTimesCalculator.getSunRightAscensionHours(sunTrueLong);\n    const cosLocalHourAngle = SunTimesCalculator.getCosLocalHourAngle(sunTrueLong, latitude, zenith);\n    let localHourAngle;\n\n    if (isSunrise) {\n      localHourAngle = 360 - SunTimesCalculator.acosDeg(cosLocalHourAngle);\n    } else {\n      // sunset\n      localHourAngle = SunTimesCalculator.acosDeg(cosLocalHourAngle);\n    }\n\n    const localHour = localHourAngle / SunTimesCalculator.DEG_PER_HOUR;\n    const localMeanTime = SunTimesCalculator.getLocalMeanTime(localHour, sunRightAscensionHours, SunTimesCalculator.getApproxTimeDays(dayOfYear, SunTimesCalculator.getHoursFromMeridian(longitude), isSunrise));\n    let processedTime = localMeanTime - SunTimesCalculator.getHoursFromMeridian(longitude);\n\n    while (processedTime < 0) {\n      processedTime += 24;\n    }\n\n    while (processedTime >= 24) {\n      processedTime -= 24;\n    }\n\n    return processedTime;\n  }\n\n}\n/**\r\n * The number of degrees of longitude that corresponds to one hour time difference.\r\n */\n\nSunTimesCalculator.DEG_PER_HOUR = 360 / 24;","map":{"version":3,"sources":["../../../src/util/SunTimesCalculator.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { AstronomicalCalculator } from './AstronomicalCalculator';\r\nimport { MathUtils } from '../polyfills/Utils';\r\n/**\r\n * Implementation of sunrise and sunset methods to calculate astronomical times. This calculator uses the Java algorithm\r\n * written by <a href=\"http://web.archive.org/web/20090531215353/http://www.kevinboone.com/suntimes.html\">Kevin\r\n * Boone</a> that is based on the <a href = \"http://aa.usno.navy.mil/\">US Naval Observatory's</a><a\r\n * href=\"http://aa.usno.navy.mil/publications/docs/asa.php\">Almanac</a> for Computer algorithm ( <a\r\n * href=\"http://www.amazon.com/exec/obidos/tg/detail/-/0160515106/\">Amazon</a>, <a\r\n * href=\"http://search.barnesandnoble.com/booksearch/isbnInquiry.asp?isbn=0160515106\">Barnes &amp; Noble</a>) and is\r\n * used with his permission. Added to Kevin's code is adjustment of the zenith to account for elevation.\r\n *\r\n * @author &copy; Eliyahu Hershfeld 2004 - 2019\r\n * @author &copy; Kevin Boone 2000\r\n * @version 1.1\r\n */\r\nexport class SunTimesCalculator extends AstronomicalCalculator {\r\n    /**\r\n     * @see net.sourceforge.zmanim.util.AstronomicalCalculator#getCalculatorName()\r\n     */\r\n    // eslint-disable-next-line class-methods-use-this\r\n    getCalculatorName() {\r\n        return 'US Naval Almanac Algorithm';\r\n    }\r\n    /**\r\n     * @see net.sourceforge.zmanim.util.AstronomicalCalculator#getUTCSunrise(Calendar, GeoLocation, double, boolean)\r\n     */\r\n    getUTCSunrise(date, geoLocation, zenith, adjustForElevation) {\r\n        const elevation = adjustForElevation ? geoLocation.getElevation() : 0;\r\n        const adjustedZenith = this.adjustZenith(zenith, elevation);\r\n        const doubleTime = SunTimesCalculator.getTimeUTC(date, geoLocation.getLongitude(), geoLocation.getLatitude(), adjustedZenith, true);\r\n        return doubleTime;\r\n    }\r\n    /**\r\n     * @see net.sourceforge.zmanim.util.AstronomicalCalculator#getUTCSunset(Calendar, GeoLocation, double, boolean)\r\n     */\r\n    getUTCSunset(date, geoLocation, zenith, adjustForElevation) {\r\n        const elevation = adjustForElevation ? geoLocation.getElevation() : 0;\r\n        const adjustedZenith = this.adjustZenith(zenith, elevation);\r\n        const doubleTime = SunTimesCalculator.getTimeUTC(date, geoLocation.getLongitude(), geoLocation.getLatitude(), adjustedZenith, false);\r\n        return doubleTime;\r\n    }\r\n    /**\r\n     * sin of an angle in degrees\r\n     */\r\n    static sinDeg(deg) {\r\n        // return Math.sin(deg * 2 * Math.PI / 360);\r\n        return Math.sin(MathUtils.degreesToRadians(deg));\r\n    }\r\n    /**\r\n     * acos of an angle, result in degrees\r\n     */\r\n    static acosDeg(x) {\r\n        // return Math.acos(x) * 360 / (2 * Math.PI);\r\n        return MathUtils.radiansToDegrees(Math.acos(x));\r\n    }\r\n    /**\r\n     * asin of an angle, result in degrees\r\n     */\r\n    static asinDeg(x) {\r\n        // return Math.asin(x) * 360 / (2 * Math.PI);\r\n        return MathUtils.radiansToDegrees(Math.asin(x));\r\n    }\r\n    /**\r\n     * tan of an angle in degrees\r\n     */\r\n    static tanDeg(deg) {\r\n        // return Math.tan(deg * 2 * Math.PI / 360);\r\n        return Math.tan(MathUtils.degreesToRadians(deg));\r\n    }\r\n    /**\r\n     * Calculate cosine of the angle in degrees\r\n     *\r\n     * @param deg degrees\r\n     * @return cosine of the angle in degrees\r\n     */\r\n    static cosDeg(deg) {\r\n        // return Math.cos(deg * 2 * Math.PI / 360);\r\n        return Math.cos(MathUtils.degreesToRadians(deg));\r\n    }\r\n    /**\r\n     * Get time difference between location's longitude and the Meridian, in hours. West of Meridian has a negative time\r\n     * difference\r\n     */\r\n    static getHoursFromMeridian(longitude) {\r\n        return longitude / SunTimesCalculator.DEG_PER_HOUR;\r\n    }\r\n    /**\r\n     * Calculate the approximate time of sunset or sunrise in days since midnight Jan 1st, assuming 6am and 6pm events. We\r\n     * need this figure to derive the Sun's mean anomaly.\r\n     *\r\n     * @param dayOfYear the day of year\r\n     * @param hoursFromMeridian hours from the meridian\r\n     * @param isSunrise true for sunrise and false for sunset\r\n     *\r\n     * @return the approximate time of sunset or sunrise in days since midnight Jan 1st, assuming 6am and 6pm events. We\r\n     * need this figure to derive the Sun's mean anomaly.\r\n     */\r\n    static getApproxTimeDays(dayOfYear, hoursFromMeridian, isSunrise) {\r\n        if (isSunrise) {\r\n            return dayOfYear + ((6 - hoursFromMeridian) / 24);\r\n        }\r\n        // sunset\r\n        return dayOfYear + ((18 - hoursFromMeridian) / 24);\r\n    }\r\n    /**\r\n     * Calculate the Sun's mean anomaly in degrees, at sunrise or sunset, given the longitude in degrees\r\n     *\r\n     * @param dayOfYear the day of the year\r\n     * @param longitude longitude\r\n     * @param isSunrise true for sunrise and false for sunset\r\n     * @return the Sun's mean anomaly in degrees\r\n     */\r\n    static getMeanAnomaly(dayOfYear, longitude, isSunrise) {\r\n        return (0.9856 * SunTimesCalculator.getApproxTimeDays(dayOfYear, SunTimesCalculator.getHoursFromMeridian(longitude), isSunrise)) - 3.289;\r\n    }\r\n    /**\r\n     * Calculates the Sun's true longitude in degrees. The result is an angle gte 0 and lt 360. Requires the Sun's mean\r\n     * anomaly, also in degrees\r\n     */\r\n    static getSunTrueLongitude(sunMeanAnomaly) {\r\n        let l = sunMeanAnomaly + (1.916 * SunTimesCalculator.sinDeg(sunMeanAnomaly)) + (0.020 * SunTimesCalculator.sinDeg(2 * sunMeanAnomaly)) + 282.634;\r\n        // get longitude into 0-360 degree range\r\n        if (l >= 360) {\r\n            l = l - 360;\r\n        }\r\n        if (l < 0) {\r\n            l = l + 360;\r\n        }\r\n        return l;\r\n    }\r\n    /**\r\n     * Calculates the Sun's right ascension in hours, given the Sun's true longitude in degrees. Input and output are\r\n     * angles gte 0 and lt 360.\r\n     */\r\n    static getSunRightAscensionHours(sunTrueLongitude) {\r\n        const a = 0.91764 * SunTimesCalculator.tanDeg(sunTrueLongitude);\r\n        let ra = 360 / (2 * Math.PI) * Math.atan(a);\r\n        const lQuadrant = Math.floor(sunTrueLongitude / 90) * 90;\r\n        const raQuadrant = Math.floor(ra / 90) * 90;\r\n        ra += (lQuadrant - raQuadrant);\r\n        return ra / SunTimesCalculator.DEG_PER_HOUR; // convert to hours\r\n    }\r\n    /**\r\n     * Calculate the cosine of the Sun's local hour angle\r\n     *\r\n     * @param sunTrueLongitude the sun's true longitude\r\n     * @param latitude the latitude\r\n     * @param zenith the zenith\r\n     * @return the cosine of the Sun's local hour angle\r\n     */\r\n    static getCosLocalHourAngle(sunTrueLongitude, latitude, zenith) {\r\n        const sinDec = 0.39782 * SunTimesCalculator.sinDeg(sunTrueLongitude);\r\n        const cosDec = SunTimesCalculator.cosDeg(SunTimesCalculator.asinDeg(sinDec));\r\n        return (SunTimesCalculator.cosDeg(zenith) - (sinDec * SunTimesCalculator.sinDeg(latitude))) / (cosDec * SunTimesCalculator.cosDeg(latitude));\r\n    }\r\n    /**\r\n     * Calculate local mean time of rising or setting. By `local' is meant the exact time at the location, assuming that\r\n     * there were no time zone. That is, the time difference between the location and the Meridian depended entirely on\r\n     * the longitude. We can't do anything with this time directly; we must convert it to UTC and then to a local time.\r\n     * The result is expressed as a fractional number of hours since midnight\r\n     *\r\n     * @param localHour the local hour\r\n     * @param sunRightAscensionHours the sun's right ascention in hours\r\n     * @param approxTimeDays approximate time days\r\n     *\r\n     * @return the fractional number of hours since midnight as a double\r\n     */\r\n    static getLocalMeanTime(localHour, sunRightAscensionHours, approxTimeDays) {\r\n        return localHour + sunRightAscensionHours - (0.06571 * approxTimeDays) - 6.622;\r\n    }\r\n    /**\r\n     * Get sunrise or sunset time in UTC, according to flag.\r\n     *\r\n     * @param year\r\n     *            4-digit year\r\n     * @param month\r\n     *            month, 1-12 (not the zero based Java month\r\n     * @param day\r\n     *            day of month, 1-31\r\n     * @param longitude\r\n     *            in degrees, longitudes west of Meridian are negative\r\n     * @param latitude\r\n     *            in degrees, latitudes south of equator are negative\r\n     * @param zenith\r\n     *            Sun's zenith, in degrees\r\n     * @param type\r\n     *            type of calculation to carry out {@link #TYPE_SUNRISE} or {@link #TYPE_SUNRISE}.\r\n     *\r\n     * @return the time as a double. If an error was encountered in the calculation (expected behavior for some\r\n     *         locations such as near the poles, {@link Double.NaN} will be returned.\r\n     */\r\n    static getTimeUTC(date, longitude, latitude, zenith, isSunrise) {\r\n        const dayOfYear = date.ordinal;\r\n        const sunMeanAnomaly = SunTimesCalculator.getMeanAnomaly(dayOfYear, longitude, isSunrise);\r\n        const sunTrueLong = SunTimesCalculator.getSunTrueLongitude(sunMeanAnomaly);\r\n        const sunRightAscensionHours = SunTimesCalculator.getSunRightAscensionHours(sunTrueLong);\r\n        const cosLocalHourAngle = SunTimesCalculator.getCosLocalHourAngle(sunTrueLong, latitude, zenith);\r\n        let localHourAngle;\r\n        if (isSunrise) {\r\n            localHourAngle = 360 - SunTimesCalculator.acosDeg(cosLocalHourAngle);\r\n        }\r\n        else { // sunset\r\n            localHourAngle = SunTimesCalculator.acosDeg(cosLocalHourAngle);\r\n        }\r\n        const localHour = localHourAngle / SunTimesCalculator.DEG_PER_HOUR;\r\n        const localMeanTime = SunTimesCalculator.getLocalMeanTime(localHour, sunRightAscensionHours, SunTimesCalculator.getApproxTimeDays(dayOfYear, SunTimesCalculator.getHoursFromMeridian(longitude), isSunrise));\r\n        let processedTime = localMeanTime - SunTimesCalculator.getHoursFromMeridian(longitude);\r\n        while (processedTime < 0) {\r\n            processedTime += 24;\r\n        }\r\n        while (processedTime >= 24) {\r\n            processedTime -= 24;\r\n        }\r\n        return processedTime;\r\n    }\r\n}\r\n/**\r\n * The number of degrees of longitude that corresponds to one hour time difference.\r\n */\r\nSunTimesCalculator.DEG_PER_HOUR = 360 / 24;\r\n//# sourceMappingURL=SunTimesCalculator.js.map"]},"metadata":{},"sourceType":"module"}