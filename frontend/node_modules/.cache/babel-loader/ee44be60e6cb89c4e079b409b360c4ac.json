{"ast":null,"code":"import _classCallCheck from \"C:\\\\react\\\\my-app\\\\frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\react\\\\my-app\\\\frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { DateTime } from 'luxon';\nimport { Calendar, IntegerUtils } from '../polyfills/Utils';\nimport { IllegalArgumentException } from '../polyfills/errors';\n/**\r\n * The JewishDate is the base calendar class, that supports maintenance of a {@link java.util.GregorianCalendar}\r\n * instance along with the corresponding Jewish date. This class can use the standard Java Date and Calendar\r\n * classes for setting and maintaining the dates, but it does not subclass these classes or use them internally\r\n * in any calculations. This class also does not have a concept of a time (which the Date class does). Please\r\n * note that the calendar does not currently support dates prior to 1/1/1 Gregorian. Also keep in mind that the\r\n * Gregorian calendar started on October 15, 1582, so any calculations prior to that are suspect (at least from\r\n * a Gregorian perspective). While 1/1/1 Gregorian and forward are technically supported, any calculations prior to <a\r\n * href=\"http://en.wikipedia.org/wiki/Hillel_II\">Hillel II's (Hakatan's</a>) calendar (4119 in the Jewish Calendar / 359\r\n * CE Julian as recorded by <a href=\"http://en.wikipedia.org/wiki/Hai_Gaon\">Rav Hai Gaon</a>) would be just an\r\n * approximation.\r\n *\r\n * This open source Java code was written by <a href=\"http://www.facebook.com/avromf\">Avrom Finkelstien</a> from his C++\r\n * code. It was refactored to fit the KosherJava Zmanim API with simplification of the code, enhancements and some bug\r\n * fixing.\r\n *\r\n * Some of Avrom's original C++ code was translated from <a href=\"https://web.archive.org/web/20120124134148/http://emr.cs.uiuc.edu/~reingold/calendar.C\">C/C++\r\n * code</a> in <a href=\"http://www.calendarists.com\">Calendrical Calculations</a> by Nachum Dershowitz and Edward M.\r\n * Reingold, Software-- Practice &amp; Experience, vol. 20, no. 9 (September, 1990), pp. 899- 928. Any method with the mark\r\n * \"ND+ER\" indicates that the method was taken from this source with minor modifications.\r\n *\r\n * If you are looking for a class that implements a Jewish calendar version of the Calendar class, one is available from\r\n * the <a href=\"http://site.icu-project.org/\" >ICU (International Components for Unicode)</a> project, formerly part of\r\n * IBM's DeveloperWorks.\r\n *\r\n * @see net.sourceforge.zmanim.hebrewcalendar.JewishCalendar\r\n * @see net.sourceforge.zmanim.hebrewcalendar.HebrewDateFormatter\r\n * @see java.util.Date\r\n * @see java.util.Calendar\r\n * @author &copy; Avrom Finkelstien 2002\r\n * @author &copy; Eliyahu Hershfeld 2011 - 2015\r\n */\n\nexport var JewishDate = /*#__PURE__*/function () {\n  function JewishDate(jewishYearOrDateTimeOrDateOrMolad, jewishMonth, jewishDayOfMonth) {\n    _classCallCheck(this, JewishDate);\n\n    if (!jewishYearOrDateTimeOrDateOrMolad) {\n      this.resetDate();\n    } else if (jewishMonth) {\n      this.setJewishDate(jewishYearOrDateTimeOrDateOrMolad, jewishMonth, jewishDayOfMonth);\n    } else if (jewishYearOrDateTimeOrDateOrMolad instanceof Date) {\n      this.setDate(DateTime.fromJSDate(jewishYearOrDateTimeOrDateOrMolad));\n    } else if (DateTime.isDateTime(jewishYearOrDateTimeOrDateOrMolad)) {\n      this.setDate(jewishYearOrDateTimeOrDateOrMolad);\n    } else if (typeof jewishYearOrDateTimeOrDateOrMolad === 'number') {\n      var molad = jewishYearOrDateTimeOrDateOrMolad;\n      this.absDateToDate(JewishDate.moladToAbsDate(molad)); // long chalakimSince = getChalakimSinceMoladTohu(year, JewishDate.TISHREI);// tishrei\n\n      var conjunctionDay = Math.trunc(molad / JewishDate.CHALAKIM_PER_DAY);\n      var conjunctionParts = Math.trunc(molad - conjunctionDay * JewishDate.CHALAKIM_PER_DAY);\n      this.setMoladTime(conjunctionParts);\n    }\n  }\n  /**\r\n   * Returns the molad hours. Only a JewishDate object populated with {@link #getMolad()},\r\n   * {@link #setJewishDate(int, int, int, int, int, int)} or {@link #setMoladHours(int)} will have this field\r\n   * populated. A regular JewishDate object will have this field set to 0.\r\n   *\r\n   * @return the molad hours\r\n   * @see #setMoladHours(int)\r\n   * @see #getMolad()\r\n   * @see #setJewishDate(int, int, int, int, int, int)\r\n   */\n\n\n  _createClass(JewishDate, [{\n    key: \"getMoladHours\",\n    value: function getMoladHours() {\n      return this.moladHours;\n    }\n    /**\r\n     * Sets the molad hours.\r\n     *\r\n     * @param moladHours\r\n     *            the molad hours to set\r\n     * @see #getMoladHours()\r\n     * @see #getMolad()\r\n     * @see #setJewishDate(int, int, int, int, int, int)\r\n     *\r\n     */\n\n  }, {\n    key: \"setMoladHours\",\n    value: function setMoladHours(moladHours) {\n      this.moladHours = moladHours;\n    }\n    /**\r\n     * Returns the molad minutes. Only an object populated with {@link #getMolad()},\r\n     * {@link #setJewishDate(int, int, int, int, int, int)} or or {@link #setMoladMinutes(int)} will have these fields\r\n     * populated. A regular JewishDate object will have this field set to 0.\r\n     *\r\n     * @return the molad minutes\r\n     * @see #setMoladMinutes(int)\r\n     * @see #getMolad()\r\n     * @see #setJewishDate(int, int, int, int, int, int)\r\n     */\n\n  }, {\n    key: \"getMoladMinutes\",\n    value: function getMoladMinutes() {\n      return this.moladMinutes;\n    }\n    /**\r\n     * Sets the molad minutes. The expectation is that the traditional minute-less chalakim will be broken out to\r\n     * minutes and {@link #setMoladChalakim(int) chalakim/parts} , so 793 (TaShTZaG) parts would have the minutes set to\r\n     * 44 and chalakim to 1.\r\n     *\r\n     * @param moladMinutes\r\n     *            the molad minutes to set\r\n     * @see #getMoladMinutes()\r\n     * @see #setMoladChalakim(int)\r\n     * @see #getMolad()\r\n     * @see #setJewishDate(int, int, int, int, int, int)\r\n     *\r\n     */\n\n  }, {\n    key: \"setMoladMinutes\",\n    value: function setMoladMinutes(moladMinutes) {\n      this.moladMinutes = moladMinutes;\n    }\n    /**\r\n     * Sets the molad chalakim/parts. The expectation is that the traditional minute-less chalakim will be broken out to\r\n     * {@link #setMoladMinutes(int) minutes} and chalakim, so 793 (TaShTZaG) parts would have the minutes set to 44 and\r\n     * chalakim to 1.\r\n     *\r\n     * @param moladChalakim\r\n     *            the molad chalakim/parts to set\r\n     * @see #getMoladChalakim()\r\n     * @see #setMoladMinutes(int)\r\n     * @see #getMolad()\r\n     * @see #setJewishDate(int, int, int, int, int, int)\r\n     *\r\n     */\n\n  }, {\n    key: \"setMoladChalakim\",\n    value: function setMoladChalakim(moladChalakim) {\n      this.moladChalakim = moladChalakim;\n    }\n    /**\r\n     * Returns the molad chalakim/parts. Only an object populated with {@link #getMolad()},\r\n     * {@link #setJewishDate(int, int, int, int, int, int)} or or {@link #setMoladChalakim(int)} will have these fields\r\n     * populated. A regular JewishDate object will have this field set to 0.\r\n     *\r\n     * @return the molad chalakim/parts\r\n     * @see #setMoladChalakim(int)\r\n     * @see #getMolad()\r\n     * @see #setJewishDate(int, int, int, int, int, int)\r\n     */\n\n  }, {\n    key: \"getMoladChalakim\",\n    value: function getMoladChalakim() {\n      return this.moladChalakim;\n    }\n    /**\r\n     * Returns the last day in a gregorian month\r\n     *\r\n     * @param month\r\n     *            the Gregorian month\r\n     * @return the last day of the Gregorian month\r\n     */\n\n  }, {\n    key: \"getLastDayOfGregorianMonth\",\n    value: function getLastDayOfGregorianMonth(month) {\n      return JewishDate.getLastDayOfGregorianMonth(month, this.gregorianYear);\n    }\n    /**\r\n     * Returns the number of days in a given month in a given month and year.\r\n     *\r\n     * @param month\r\n     *            the month. As with other cases in this class, this is 1-based, not zero-based.\r\n     * @param year\r\n     *            the year (only impacts February)\r\n     * @return the number of days in the month in the given year\r\n     */\n\n  }, {\n    key: \"absDateToDate\",\n\n    /**\r\n     * Computes the Gregorian date from the absolute date. ND+ER\r\n     * @param absDate - the absolute date\r\n     */\n    value: function absDateToDate(absDate) {\n      var year = Math.trunc(absDate / 366); // Search forward year by year from approximate year\n\n      while (absDate >= JewishDate.gregorianDateToAbsDate(year + 1, 1, 1)) {\n        year++;\n      }\n\n      var month = 1; // Search forward month by month from January\n\n      while (absDate > JewishDate.gregorianDateToAbsDate(year, month, JewishDate.getLastDayOfGregorianMonth(month, year))) {\n        month++;\n      }\n\n      var dayOfMonth = absDate - JewishDate.gregorianDateToAbsDate(year, month, 1) + 1;\n      this.setInternalGregorianDate(year, month, dayOfMonth);\n    }\n    /**\r\n     * Returns the absolute date (days since January 1, 0001 on the Gregorian calendar).\r\n     *\r\n     * @return the number of days since January 1, 1\r\n     */\n\n  }, {\n    key: \"getAbsDate\",\n    value: function getAbsDate() {\n      return this.gregorianAbsDate;\n    }\n    /**\r\n     * Computes the absolute date from a Gregorian date. ND+ER\r\n     *\r\n     * @param year\r\n     *            the Gregorian year\r\n     * @param month\r\n     *            the Gregorian month. Unlike the Java Calendar where January has the value of 0,This expects a 1 for\r\n     *            January\r\n     * @param dayOfMonth\r\n     *            the day of the month (1st, 2nd, etc...)\r\n     * @return the absolute Gregorian day\r\n     */\n\n  }, {\n    key: \"isJewishLeapYear\",\n\n    /**\r\n     * Returns if the year the calendar is set to is a Jewish leap year. Years 3, 6, 8, 11, 14, 17 and 19 in the 19 year\r\n     * cycle are leap years.\r\n     *\r\n     * @return true if it is a leap year\r\n     * @see #isJewishLeapYear(int)\r\n     */\n    value: function isJewishLeapYear() {\n      return JewishDate.isJewishLeapYear(this.getJewishYear());\n    }\n    /**\r\n     * Returns the last month of a given Jewish year. This will be 12 on a non {@link #isJewishLeapYear(int) leap year}\r\n     * or 13 on a leap year.\r\n     *\r\n     * @param year\r\n     *            the Jewish year.\r\n     * @return 12 on a non leap year or 13 on a leap year\r\n     * @see #isJewishLeapYear(int)\r\n     */\n\n  }, {\n    key: \"getChalakimSinceMoladTohu\",\n\n    /**\r\n     * Returns the number of chalakim (parts - 1080 to the hour) from the original hypothetical Molad Tohu to the Jewish\r\n     * year and month that this Object is set to.\r\n     *\r\n     * @return the number of chalakim (parts - 1080 to the hour) from the original hypothetical Molad Tohu\r\n     */\n    value: function getChalakimSinceMoladTohu() {\n      return JewishDate.getChalakimSinceMoladTohu(this.jewishYear, this.jewishMonth);\n    }\n    /**\r\n     * Converts the {@link JewishDate#NISSAN} based constants used by this class to numeric month starting from\r\n     * {@link JewishDate#TISHREI}. This is required for Molad claculations.\r\n     *\r\n     * @param year\r\n     *            The Jewish year\r\n     * @param month\r\n     *            The Jewish Month\r\n     * @return the Jewish month of the year starting with Tishrei\r\n     */\n\n  }, {\n    key: \"getDaysInJewishYear\",\n\n    /**\r\n     * Returns the number of days for the current year that the calendar is set to.\r\n     *\r\n     * @return the number of days for the Object's current Jewish year.\r\n     * @see #isCheshvanLong()\r\n     * @see #isKislevShort()\r\n     * @see #isJewishLeapYear()\r\n     */\n    value: function getDaysInJewishYear() {\n      return JewishDate.getDaysInJewishYear(this.getJewishYear());\n    }\n    /**\r\n     * Returns if Cheshvan is long in a given Jewish year. The method name isLong is done since in a Kesidran (ordered)\r\n     * year Cheshvan is short. ND+ER\r\n     *\r\n     * @param year\r\n     *            the year\r\n     * @return true if Cheshvan is long in Jewish year.\r\n     * @see #isCheshvanLong()\r\n     * @see #getCheshvanKislevKviah()\r\n     */\n\n  }, {\n    key: \"isCheshvanLong\",\n\n    /**\r\n     * Returns if Cheshvan is long (30 days VS 29 days) for the current year that the calendar is set to. The method\r\n     * name isLong is done since in a Kesidran (ordered) year Cheshvan is short.\r\n     *\r\n     * @return true if Cheshvan is long for the current year that the calendar is set to\r\n     * @see #isCheshvanLong()\r\n     */\n    value: function isCheshvanLong() {\n      return JewishDate.isCheshvanLong(this.getJewishYear());\n    }\n    /**\r\n     * Returns if Kislev is short (29 days VS 30 days) in a given Jewish year. The method name isShort is done since in\r\n     * a Kesidran (ordered) year Kislev is long. ND+ER\r\n     *\r\n     * @param year\r\n     *            the Jewish year\r\n     * @return true if Kislev is short for the given Jewish year.\r\n     * @see #isKislevShort()\r\n     * @see #getCheshvanKislevKviah()\r\n     */\n\n  }, {\n    key: \"isKislevShort\",\n\n    /**\r\n     * Returns if the Kislev is short for the year that this class is set to. The method name isShort is done since in a\r\n     * Kesidran (ordered) year Kislev is long.\r\n     *\r\n     * @return true if Kislev is short for the year that this class is set to\r\n     */\n    value: function isKislevShort() {\n      return JewishDate.isKislevShort(this.getJewishYear());\n    }\n    /**\r\n     * Returns the Cheshvan and Kislev kviah (whether a Jewish year is short, regular or long). It will return\r\n     * {@link #SHELAIMIM} if both cheshvan and kislev are 30 days, {@link #KESIDRAN} if Cheshvan is 29 days and Kislev\r\n     * is 30 days and {@link #CHASERIM} if both are 29 days.\r\n     *\r\n     * @return {@link #SHELAIMIM} if both cheshvan and kislev are 30 days, {@link #KESIDRAN} if Cheshvan is 29 days and\r\n     *         Kislev is 30 days and {@link #CHASERIM} if both are 29 days.\r\n     * @see #isCheshvanLong()\r\n     * @see #isKislevShort()\r\n     */\n\n  }, {\n    key: \"getCheshvanKislevKviah\",\n    value: function getCheshvanKislevKviah() {\n      if (this.isCheshvanLong() && !this.isKislevShort()) {\n        return JewishDate.SHELAIMIM;\n      } else if (!this.isCheshvanLong() && this.isKislevShort()) {\n        return JewishDate.CHASERIM;\n      }\n\n      return JewishDate.KESIDRAN;\n    }\n    /**\r\n     * Returns the number of days of a Jewish month for a given month and year.\r\n     *\r\n     * @param month\r\n     *            the Jewish month\r\n     * @param year\r\n     *            the Jewish Year\r\n     * @return the number of days for a given Jewish month\r\n     */\n\n  }, {\n    key: \"getDaysInJewishMonth\",\n\n    /**\r\n     * Returns the number of days of the Jewish month that the calendar is currently set to.\r\n     *\r\n     * @return the number of days for the Jewish month that the calendar is currently set to.\r\n     */\n    value: function getDaysInJewishMonth() {\n      return JewishDate.getDaysInJewishMonth(this.getJewishMonth(), this.getJewishYear());\n    }\n    /**\r\n     * Computes the Jewish date from the absolute date. ND+ER\r\n     */\n\n  }, {\n    key: \"absDateToJewishDate\",\n    value: function absDateToJewishDate() {\n      // Approximation from below\n      this.jewishYear = Math.trunc((this.gregorianAbsDate - JewishDate.JEWISH_EPOCH) / 366); // Search forward for year from the approximation\n\n      while (this.gregorianAbsDate >= JewishDate.jewishDateToAbsDate(this.jewishYear + 1, JewishDate.TISHREI, 1)) {\n        this.jewishYear++;\n      } // Search forward for month from either Tishri or Nisan.\n\n\n      if (this.gregorianAbsDate < JewishDate.jewishDateToAbsDate(this.jewishYear, JewishDate.NISSAN, 1)) {\n        this.jewishMonth = JewishDate.TISHREI; // Start at Tishri\n      } else {\n        this.jewishMonth = JewishDate.NISSAN; // Start at Nisan\n      }\n\n      while (this.gregorianAbsDate > JewishDate.jewishDateToAbsDate(this.jewishYear, this.jewishMonth, this.getDaysInJewishMonth())) {\n        this.jewishMonth++;\n      } // Calculate the day by subtraction\n\n\n      this.jewishDay = this.gregorianAbsDate - JewishDate.jewishDateToAbsDate(this.jewishYear, this.jewishMonth, 1) + 1;\n    }\n    /**\r\n     * Returns the absolute date of Jewish date. ND+ER\r\n     *\r\n     * @param year\r\n     *            the Jewish year. The year can't be negative\r\n     * @param month\r\n     *            the Jewish month starting with Nisan. Nisan expects a value of 1 etc till Adar with a value of 12. For\r\n     *            a leap year, 13 will be the expected value for Adar II. Use the constants {@link JewishDate#NISSAN}\r\n     *            etc.\r\n     * @param dayOfMonth\r\n     *            the Jewish day of month. valid values are 1-30. If the day of month is set to 30 for a month that only\r\n     *            has 29 days, the day will be set as 29.\r\n     * @return the absolute date of the Jewish date.\r\n     */\n\n  }, {\n    key: \"getMolad\",\n\n    /**\r\n     * Returns the molad for a given year and month. Returns a JewishDate {@link Object} set to the date of the molad\r\n     * with the {@link #getMoladHours() hours}, {@link #getMoladMinutes() minutes} and {@link #getMoladChalakim()\r\n       * chalakim} set. In the current implementation, it sets the molad time based on a midnight date rollover. This\r\n     * means that Rosh Chodesh Adar II, 5771 with a molad of 7 chalakim past midnight on Shabbos 29 Adar I / March 5,\r\n     * 2011 12:00 AM and 7 chalakim, will have the following values: hours: 0, minutes: 0, Chalakim: 7.\r\n     *\r\n     * @return a JewishDate {@link Object} set to the date of the molad with the {@link #getMoladHours() hours},\r\n     *         {@link #getMoladMinutes() minutes} and {@link #getMoladChalakim() chalakim} set.\r\n     */\n    value: function getMolad() {\n      var moladDate = new JewishDate(this.getChalakimSinceMoladTohu());\n\n      if (moladDate.getMoladHours() >= 6) {\n        moladDate.forward(Calendar.DATE, 1);\n      }\n\n      moladDate.setMoladHours((moladDate.getMoladHours() + 18) % 24);\n      return moladDate;\n    }\n    /**\r\n     * Returns the number of days from the Jewish epoch from the number of chalakim from the epoch passed in.\r\n     *\r\n     * @param chalakim\r\n     *            the number of chalakim since the beginning of Sunday prior to BaHaRaD\r\n     * @return the number of days from the Jewish epoch\r\n     */\n\n  }, {\n    key: \"setMoladTime\",\n\n    /**\r\n     * Constructor that creates a JewishDate based on a molad passed in. The molad would be the number of chalakim/parts\r\n     * starting at the beginning of Sunday prior to the molad Tohu BeHaRaD (Be = Monday, Ha= 5 hours and Rad =204\r\n     * chalakim/parts) - prior to the start of the Jewish calendar. BeHaRaD is 23:11:20 on Sunday night(5 hours 204/1080\r\n     * chalakim after sunset on Sunday evening).\r\n     *\r\n     * @param molad the number of chalakim since the beginning of Sunday prior to BaHaRaD\r\n     */\n\n    /*\r\n        public JewishDate(molad: number) {\r\n            this.absDateToDate(JewishDate.moladToAbsDate(molad));\r\n            // long chalakimSince = getChalakimSinceMoladTohu(year, JewishDate.TISHREI);// tishrei\r\n            const conjunctionDay: number = Math.trunc(molad / JewishDate.CHALAKIM_PER_DAY);\r\n            const conjunctionParts: number = Math.trunc(molad - conjunctionDay * JewishDate.CHALAKIM_PER_DAY);\r\n            this.setMoladTime(conjunctionParts);\r\n        }\r\n    */\n\n    /**\r\n     * Sets the molad time (hours minutes and chalakim) based on the number of chalakim since the start of the day.\r\n     *\r\n     * @param chalakim\r\n     *            the number of chalakim since the start of the day.\r\n     */\n    value: function setMoladTime(chalakim) {\n      var adjustedChalakim = chalakim;\n      this.setMoladHours(Math.trunc(adjustedChalakim / JewishDate.CHALAKIM_PER_HOUR));\n      adjustedChalakim = adjustedChalakim - this.getMoladHours() * JewishDate.CHALAKIM_PER_HOUR;\n      this.setMoladMinutes(Math.trunc(adjustedChalakim / JewishDate.CHALAKIM_PER_MINUTE));\n      this.setMoladChalakim(adjustedChalakim - this.moladMinutes * JewishDate.CHALAKIM_PER_MINUTE);\n    }\n    /**\r\n     * returns the number of days from Rosh Hashana of the date passed in, to the full date passed in.\r\n     *\r\n     * @return the number of days\r\n     */\n\n  }, {\n    key: \"getDaysSinceStartOfJewishYear\",\n    value: function getDaysSinceStartOfJewishYear() {\n      return JewishDate.getDaysSinceStartOfJewishYear(this.getJewishYear(), this.getJewishMonth(), this.getJewishDayOfMonth());\n    }\n    /**\r\n     * returns the number of days from Rosh Hashana of the date passed in, to the full date passed in.\r\n     *\r\n     * @param year\r\n     *            the Jewish year\r\n     * @param month\r\n     *            the Jewish month\r\n     * @param dayOfMonth\r\n     *            the day in the Jewish month\r\n     * @return the number of days\r\n     */\n\n  }, {\n    key: \"setDate\",\n\n    /**\r\n     * Creates a Jewish date based on a Jewish year, month and day of month.\r\n     *\r\n     * @param jewishYear\r\n     *            the Jewish year\r\n     * @param jewishMonth\r\n     *            the Jewish month. The method expects a 1 for Nissan ... 12 for Adar and 13 for Adar II. Use the\r\n     *            constants {@link #NISSAN} ... {@link #ADAR} (or {@link #ADAR_II} for a leap year Adar II) to avoid any\r\n     *            confusion.\r\n     * @param jewishDayOfMonth\r\n     *            the Jewish day of month. If 30 is passed in for a month with only 29 days (for example {@link #IYAR},\r\n     *            or {@link #KISLEV} in a year that {@link #isKislevShort()}), the 29th (last valid date of the month)\r\n     *            will be set\r\n     * @throws IllegalArgumentException\r\n     *             if the day of month is &lt; 1 or &gt; 30, or a year of &lt; 0 is passed in.\r\n     */\n\n    /*\r\n        public JewishDate(jewishYear: number, jewishMonth: number, jewishDayOfMonth: number) {\r\n            this.setJewishDate(jewishYear, jewishMonth, jewishDayOfMonth);\r\n        }\r\n    */\n\n    /**\r\n     * Default constructor will set a default date to the current system date.\r\n     */\n\n    /*\r\n        public JewishDate() {\r\n            this.resetDate();\r\n        }\r\n    */\n\n    /**\r\n     * A constructor that initializes the date to the {@link java.util.Date Date} paremeter.\r\n     *\r\n     * @param date\r\n     *            the <code>Date</code> to set the calendar to\r\n     * @throws IllegalArgumentException\r\n     *             if the date would fall prior to the January 1, 1 AD\r\n     */\n\n    /*\r\n        public JewishDate(date: Date) {\r\n            this.setDate(date);\r\n        }\r\n    */\n\n    /**\r\n     * A constructor that initializes the date to the {@link java.util.Calendar Calendar} paremeter.\r\n     *\r\n     * @param calendar\r\n     *            the <code>Calendar</code> to set the calendar to\r\n     * @throws IllegalArgumentException\r\n     *             if the {@link Calendar#ERA} is {@link GregorianCalendar#BC}\r\n     */\n\n    /*\r\n        public JewishDate(calendar: GregorianCalendar) {\r\n            this.setDate(calendar);\r\n        }\r\n    */\n\n    /**\r\n     * Sets the date based on a {@link java.util.Calendar Calendar} object. Modifies the Jewish date as well.\r\n     *\r\n     * @param date\r\n     *            the <code>Calendar</code> to set the calendar to\r\n     * @throws IllegalArgumentException\r\n     *             if the {@link Calendar#ERA} is {@link GregorianCalendar#BC}\r\n     */\n    value: function setDate(date) {\n      if (date.year < 1) {\n        throw new IllegalArgumentException(\"Dates with a BC era are not supported. The year \".concat(date.year, \" is invalid.\"));\n      }\n\n      this.gregorianMonth = date.month;\n      this.gregorianDayOfMonth = date.day;\n      this.gregorianYear = date.year;\n      this.gregorianAbsDate = JewishDate.gregorianDateToAbsDate(this.gregorianYear, this.gregorianMonth, this.gregorianDayOfMonth); // init the date\n\n      this.absDateToJewishDate();\n      this.dayOfWeek = Math.abs(this.gregorianAbsDate % 7) + 1; // set day of week\n    }\n    /**\r\n     * Sets the date based on a {@link java.util.Date Date} object. Modifies the Jewish date as well.\r\n     *\r\n     * @param date\r\n     *            the <code>Date</code> to set the calendar to\r\n     * @throws IllegalArgumentException\r\n     *             if the date would fall prior to the year 1 AD\r\n     */\n\n    /*\r\n        public setDate(date: Date): void {\r\n            const cal: GregorianCalendar = new GregorianCalendar();\r\n            cal.setTime(date);\r\n            this.setDate(cal);\r\n        }\r\n    */\n\n    /**\r\n     * Sets the Gregorian Date, and updates the Jewish date accordingly. Like the Java Calendar A value of 0 is expected\r\n     * for January.\r\n     *\r\n     * @param year\r\n     *            the Gregorian year\r\n     * @param month\r\n     *            the Gregorian month. Like the Java Calendar, this class expects 0 for January\r\n     * @param dayOfMonth\r\n     *            the Gregorian day of month. If this is &gt; the number of days in the month/year, the last valid date of\r\n     *            the month will be set\r\n     * @throws IllegalArgumentException\r\n     *             if a year of &lt; 1, a month &lt; 0 or &gt; 11 or a day of month &lt; 1 is passed in\r\n     */\n\n  }, {\n    key: \"setGregorianDate\",\n    value: function setGregorianDate(year, month, dayOfMonth) {\n      JewishDate.validateGregorianDate(year, month, dayOfMonth);\n      this.setInternalGregorianDate(year, month + 1, dayOfMonth);\n    }\n    /**\r\n     * Sets the hidden internal representation of the Gregorian date , and updates the Jewish date accordingly. While\r\n     * public getters and setters have 0 based months matching the Java Calendar classes, This class internally\r\n     * represents the Gregorian month starting at 1. When this is called it will not adjust the month to match the Java\r\n     * Calendar classes.\r\n     *\r\n     * @param year - the year\r\n     * @param month - the month\r\n     * @param dayOfMonth - the day of month\r\n     */\n\n  }, {\n    key: \"setInternalGregorianDate\",\n    value: function setInternalGregorianDate(year, month, dayOfMonth) {\n      // make sure date is a valid date for the given month, if not, set to last day of month\n      if (dayOfMonth > JewishDate.getLastDayOfGregorianMonth(month, year)) {\n        dayOfMonth = JewishDate.getLastDayOfGregorianMonth(month, year);\n      } // init month, date, year\n\n\n      this.gregorianMonth = month;\n      this.gregorianDayOfMonth = dayOfMonth;\n      this.gregorianYear = year;\n      this.gregorianAbsDate = JewishDate.gregorianDateToAbsDate(this.gregorianYear, this.gregorianMonth, this.gregorianDayOfMonth); // init date\n\n      this.absDateToJewishDate();\n      this.dayOfWeek = Math.abs(this.gregorianAbsDate % 7) + 1; // set day of week\n    }\n  }, {\n    key: \"setJewishDate\",\n    value: function setJewishDate(year, month, dayOfMonth) {\n      var hours = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var minutes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var chalakim = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n      JewishDate.validateJewishDate(year, month, dayOfMonth, hours, minutes, chalakim); // if 30 is passed for a month that only has 29 days (for example by rolling the month from a month that had 30\n      // days to a month that only has 29) set the date to 29th\n\n      if (dayOfMonth > JewishDate.getDaysInJewishMonth(month, year)) {\n        dayOfMonth = JewishDate.getDaysInJewishMonth(month, year);\n      }\n\n      this.jewishMonth = month;\n      this.jewishDay = dayOfMonth;\n      this.jewishYear = year;\n      this.moladHours = hours;\n      this.moladMinutes = minutes;\n      this.moladChalakim = chalakim;\n      this.gregorianAbsDate = JewishDate.jewishDateToAbsDate(this.jewishYear, this.jewishMonth, this.jewishDay); // reset Gregorian date\n\n      this.absDateToDate(this.gregorianAbsDate);\n      this.dayOfWeek = Math.abs(this.gregorianAbsDate % 7) + 1; // reset day of week\n    }\n    /**\r\n     * Returns this object's date as a {@link java.util.Calendar} object.\r\n     *\r\n     * @return The {@link java.util.Calendar}\r\n     */\n\n  }, {\n    key: \"getDate\",\n    value: function getDate() {\n      return DateTime.fromObject({\n        year: this.gregorianYear,\n        month: this.gregorianMonth,\n        day: this.gregorianDayOfMonth\n      });\n    }\n    /**\r\n     * Resets this date to the current system date.\r\n     */\n\n  }, {\n    key: \"resetDate\",\n    value: function resetDate() {\n      this.setDate(DateTime.local());\n    }\n    /**\r\n     * Returns a string containing the Jewish date in the form, \"day Month, year\" e.g. \"21 Shevat, 5729\". For more\r\n     * complex formatting, use the formatter classes.\r\n     *\r\n     * This functionality is duplicated from {@link HebrewDateFormatter} to avoid circular dependencies.\r\n     *\r\n     * @return the Jewish date in the form \"day Month, year\" e.g. \"21 Shevat, 5729\"\r\n     * @see HebrewDateFormatter#format(JewishDate)\r\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var transliteratedMonths = ['Nissan', 'Iyar', 'Sivan', 'Tammuz', 'Av', 'Elul', 'Tishrei', 'Cheshvan', 'Kislev', 'Teves', 'Shevat', 'Adar', 'Adar II', 'Adar I'];\n      var formattedMonth;\n\n      if (this.isJewishLeapYear() && this.jewishMonth === JewishDate.ADAR) {\n        formattedMonth = transliteratedMonths[13]; // return Adar I, not Adar in a leap year\n      } else {\n        formattedMonth = transliteratedMonths[this.jewishMonth - 1];\n      }\n\n      return \"\".concat(this.getJewishDayOfMonth(), \" \").concat(formattedMonth, \", \").concat(this.getJewishYear());\n    }\n    /**\r\n     * Rolls the date, month or year forward by the amount passed in. It modifies both the Gregorian and Jewish dates\r\n     * accordingly. If manipulation beyond the fields supported here is required, use the {@link Calendar} class\r\n     * {@link Calendar#add(int, int)} or {@link Calendar#roll(int, int)} methods in the following manner.\r\n     *\r\n     * <pre>\r\n     * <code>\r\n     *     Calendar cal = jewishDate.getTime(); // get a java.util.Calendar representation of the JewishDate\r\n     *     cal.add(Calendar.MONTH, 3); // add 3 Gregorian months\r\n     *     jewishDate.setDate(cal); // set the updated calendar back to this class\r\n     * </code>\r\n     * </pre>\r\n     *\r\n     * @param field the calendar field to be forwarded. The must be {@link Calendar#DATE}, {@link Calendar#MONTH} or {@link Calendar#YEAR}\r\n     * @param amount the positive amount to move forward\r\n     * @throws IllegalArgumentException if the field is anything besides {@link Calendar#DATE}, {@link Calendar#MONTH}\r\n     * or {@link Calendar#YEAR} or if the amount is less than 1\r\n     *\r\n     * @see #back()\r\n     * @see Calendar#add(int, int)\r\n     * @see Calendar#roll(int, int)\r\n     */\n\n  }, {\n    key: \"forward\",\n    value: function forward(field, amount) {\n      if (field !== Calendar.DATE && field !== Calendar.MONTH && field !== Calendar.YEAR) {\n        throw new IllegalArgumentException('Unsupported field was passed to Forward. Only Calendar.DATE, Calendar.MONTH or Calendar.YEAR are supported.');\n      }\n\n      if (amount < 1) {\n        throw new IllegalArgumentException('JewishDate.forward() does not support amounts less than 1. See JewishDate.back()');\n      }\n\n      if (field === Calendar.DATE) {\n        // Change Gregorian date\n        for (var i = 0; i < amount; i++) {\n          if (this.gregorianDayOfMonth === JewishDate.getLastDayOfGregorianMonth(this.gregorianMonth, this.gregorianYear)) {\n            this.gregorianDayOfMonth = 1; // if last day of year\n\n            if (this.gregorianMonth === 12) {\n              this.gregorianYear++;\n            } else {\n              this.gregorianMonth++;\n            }\n          } else {\n            // if not last day of month\n            this.gregorianDayOfMonth++;\n          } // Change the Jewish Date\n\n\n          if (this.jewishDay === this.getDaysInJewishMonth()) {\n            // if it last day of elul (i.e. last day of Jewish year)\n            if (this.jewishMonth === JewishDate.ELUL) {\n              this.jewishYear++;\n              this.jewishMonth++;\n              this.jewishDay = 1;\n            } else if (this.jewishMonth === JewishDate.getLastMonthOfJewishYear(this.jewishYear)) {\n              // if it is the last day of Adar, or Adar II as case may be\n              this.jewishMonth = JewishDate.NISSAN;\n              this.jewishDay = 1;\n            } else {\n              this.jewishMonth++;\n              this.jewishDay = 1;\n            }\n          } else {\n            // if not last date of month\n            this.jewishDay++;\n          }\n\n          if (this.dayOfWeek === 7) {\n            // if last day of week, loop back to Sunday\n            this.dayOfWeek = 1;\n          } else {\n            this.dayOfWeek++;\n          } // increment the absolute date\n\n\n          this.gregorianAbsDate++;\n        }\n      } else if (field === Calendar.MONTH) {\n        this.forwardJewishMonth(amount);\n      } else if (field === Calendar.YEAR) {\n        this.setJewishYear(this.getJewishYear() + amount);\n      }\n    }\n    /**\r\n     * Forward the Jewish date by the number of months passed in.\r\n     * FIXME: Deal with forwarding a date such as 30 Nisan by a month. 30 Iyar does not exist. This should be dealt with similar to\r\n     * the way that the Java Calendar behaves (not that simple since there is a difference between add() or roll().\r\n     *\r\n     * @throws IllegalArgumentException if the amount is less than 1\r\n     * @param amount the number of months to roll the month forward\r\n     */\n\n  }, {\n    key: \"forwardJewishMonth\",\n    value: function forwardJewishMonth(amount) {\n      if (amount < 1) {\n        throw new IllegalArgumentException('the amount of months to forward has to be greater than zero.');\n      }\n\n      for (var i = 0; i < amount; i++) {\n        if (this.getJewishMonth() === JewishDate.ELUL) {\n          this.setJewishMonth(JewishDate.TISHREI);\n          this.setJewishYear(this.getJewishYear() + 1);\n        } else if (!this.isJewishLeapYear() && this.getJewishMonth() === JewishDate.ADAR || this.isJewishLeapYear() && this.getJewishMonth() === JewishDate.ADAR_II) {\n          this.setJewishMonth(JewishDate.NISSAN);\n        } else {\n          this.setJewishMonth(this.getJewishMonth() + 1);\n        }\n      }\n    }\n    /**\r\n     * Rolls the date back by 1 day. It modifies both the Gregorian and Jewish dates accordingly. The API does not\r\n     * currently offer the ability to forward more than one day t a time, or to forward by month or year. If such\r\n     * manipulation is required use the {@link Calendar} class {@link Calendar#add(int, int)} or\r\n     * {@link Calendar#roll(int, int)} methods in the following manner.\r\n     *\r\n     * <pre>\r\n     * <code>\r\n     *     Calendar cal = jewishDate.getTime(); // get a java.util.Calendar representation of the JewishDate\r\n     *     cal.add(Calendar.MONTH, -3); // subtract 3 Gregorian months\r\n     *     jewishDate.setDate(cal); // set the updated calendar back to this class\r\n     * </code>\r\n     * </pre>\r\n     *\r\n     * @see #back()\r\n     * @see Calendar#add(int, int)\r\n     * @see Calendar#roll(int, int)\r\n     */\n\n  }, {\n    key: \"back\",\n    value: function back() {\n      // Change Gregorian date\n      if (this.gregorianDayOfMonth === 1) {\n        // if first day of month\n        if (this.gregorianMonth === 1) {\n          // if first day of year\n          this.gregorianMonth = 12;\n          this.gregorianYear--;\n        } else {\n          this.gregorianMonth--;\n        } // change to last day of previous month\n\n\n        this.gregorianDayOfMonth = JewishDate.getLastDayOfGregorianMonth(this.gregorianMonth, this.gregorianYear);\n      } else {\n        this.gregorianDayOfMonth--;\n      } // change Jewish date\n\n\n      if (this.jewishDay === 1) {\n        // if first day of the Jewish month\n        if (this.jewishMonth === JewishDate.NISSAN) {\n          this.jewishMonth = JewishDate.getLastMonthOfJewishYear(this.jewishYear);\n        } else if (this.jewishMonth === JewishDate.TISHREI) {\n          // if Rosh Hashana\n          this.jewishYear--;\n          this.jewishMonth--;\n        } else {\n          this.jewishMonth--;\n        }\n\n        this.jewishDay = this.getDaysInJewishMonth();\n      } else {\n        this.jewishDay--;\n      }\n\n      if (this.dayOfWeek === 1) {\n        // if first day of week, loop back to Saturday\n        this.dayOfWeek = 7;\n      } else {\n        this.dayOfWeek--;\n      }\n\n      this.gregorianAbsDate--; // change the absolute date\n    }\n    /**\r\n     * @see Object#equals(Object)\r\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(object) {\n      if (this === object) {\n        return true;\n      }\n\n      if (!(object instanceof JewishDate)) {\n        return false;\n      }\n\n      var jewishDate = object;\n      return this.gregorianAbsDate === jewishDate.getAbsDate();\n    }\n    /**\r\n     * Compares two dates as per the compareTo() method in the Comparable interface. Returns a value less than 0 if this\r\n     * date is \"less than\" (before) the date, greater than 0 if this date is \"greater than\" (after) the date, or 0 if\r\n     * they are equal.\r\n     */\n\n  }, {\n    key: \"compareTo\",\n    value: function compareTo(jewishDate) {\n      return IntegerUtils.compare(this.gregorianAbsDate, jewishDate.getAbsDate());\n    }\n    /**\r\n     * Returns the Gregorian month (between 0-11).\r\n     *\r\n     * @return the Gregorian month (between 0-11). Like the java.util.Calendar, months are 0 based.\r\n     */\n\n  }, {\n    key: \"getGregorianMonth\",\n    value: function getGregorianMonth() {\n      return this.gregorianMonth - 1;\n    }\n    /**\r\n     * Returns the Gregorian day of the month.\r\n     *\r\n     * @return the Gregorian day of the mont\r\n     */\n\n  }, {\n    key: \"getGregorianDayOfMonth\",\n    value: function getGregorianDayOfMonth() {\n      return this.gregorianDayOfMonth;\n    }\n    /**\r\n     * Returns the Gregotian year.\r\n     *\r\n     * @return the Gregorian year\r\n     */\n\n  }, {\n    key: \"getGregorianYear\",\n    value: function getGregorianYear() {\n      return this.gregorianYear;\n    }\n    /**\r\n     * Returns the Jewish month 1-12 (or 13 years in a leap year). The month count starts with 1 for Nisan and goes to\r\n     * 13 for Adar II\r\n     *\r\n     * @return the Jewish month from 1 to 12 (or 13 years in a leap year). The month count starts with 1 for Nisan and\r\n     *         goes to 13 for Adar II\r\n     */\n\n  }, {\n    key: \"getJewishMonth\",\n    value: function getJewishMonth() {\n      return this.jewishMonth;\n    }\n    /**\r\n     * Returns the Jewish day of month.\r\n     *\r\n     * @return the Jewish day of the month\r\n     */\n\n  }, {\n    key: \"getJewishDayOfMonth\",\n    value: function getJewishDayOfMonth() {\n      return this.jewishDay;\n    }\n    /**\r\n     * Returns the Jewish year.\r\n     *\r\n     * @return the Jewish year\r\n     */\n\n  }, {\n    key: \"getJewishYear\",\n    value: function getJewishYear() {\n      return this.jewishYear;\n    }\n    /**\r\n     * Returns the day of the week as a number between 1-7.\r\n     *\r\n     * @return the day of the week as a number between 1-7.\r\n     */\n\n  }, {\n    key: \"getDayOfWeek\",\n    value: function getDayOfWeek() {\n      return this.dayOfWeek;\n    }\n    /**\r\n     * Sets the Gregorian month.\r\n     *\r\n     * @param month\r\n     *            the Gregorian month\r\n     *\r\n     * @throws IllegalArgumentException\r\n     *             if a month &lt; 0 or &gt; 11 is passed in\r\n     */\n\n  }, {\n    key: \"setGregorianMonth\",\n    value: function setGregorianMonth(month) {\n      JewishDate.validateGregorianMonth(month);\n      this.setInternalGregorianDate(this.gregorianYear, month + 1, this.gregorianDayOfMonth);\n    }\n    /**\r\n     * sets the Gregorian year.\r\n     *\r\n     * @param year\r\n     *            the Gregorian year.\r\n     * @throws IllegalArgumentException\r\n     *             if a year of &lt; 1 is passed in\r\n     */\n\n  }, {\n    key: \"setGregorianYear\",\n    value: function setGregorianYear(year) {\n      JewishDate.validateGregorianYear(year);\n      this.setInternalGregorianDate(year, this.gregorianMonth, this.gregorianDayOfMonth);\n    }\n    /**\r\n     * sets the Gregorian Day of month.\r\n     *\r\n     * @param dayOfMonth\r\n     *            the Gregorian Day of month.\r\n     * @throws IllegalArgumentException\r\n     *             if the day of month of &lt; 1 is passed in\r\n     */\n\n  }, {\n    key: \"setGregorianDayOfMonth\",\n    value: function setGregorianDayOfMonth(dayOfMonth) {\n      JewishDate.validateGregorianDayOfMonth(dayOfMonth);\n      this.setInternalGregorianDate(this.gregorianYear, this.gregorianMonth, dayOfMonth);\n    }\n    /**\r\n     * sets the Jewish month.\r\n     *\r\n     * @param month\r\n     *            the Jewish month from 1 to 12 (or 13 years in a leap year). The month count starts with 1 for Nisan\r\n     *            and goes to 13 for Adar II\r\n     * @throws IllegalArgumentException\r\n     *             if a month &lt; 1 or &gt; 12 (or 13 on a leap year) is passed in\r\n     */\n\n  }, {\n    key: \"setJewishMonth\",\n    value: function setJewishMonth(month) {\n      this.setJewishDate(this.jewishYear, month, this.jewishDay);\n    }\n    /**\r\n     * sets the Jewish year.\r\n     *\r\n     * @param year\r\n     *            the Jewish year\r\n     * @throws IllegalArgumentException\r\n     *             if a year of &lt; 3761 is passed in. The same will happen if the year is 3761 and the month and day\r\n     *             previously set are &lt; 18 Teves (preior to Jan 1, 1 AD)\r\n     */\n\n  }, {\n    key: \"setJewishYear\",\n    value: function setJewishYear(year) {\n      this.setJewishDate(year, this.jewishMonth, this.jewishDay);\n    }\n    /**\r\n     * sets the Jewish day of month.\r\n     *\r\n     * @param dayOfMonth\r\n     *            the Jewish day of month\r\n     * @throws IllegalArgumentException\r\n     *             if the day of month is &lt; 1 or &gt; 30 is passed in\r\n     */\n\n  }, {\n    key: \"setJewishDayOfMonth\",\n    value: function setJewishDayOfMonth(dayOfMonth) {\n      this.setJewishDate(this.jewishYear, this.jewishMonth, dayOfMonth);\n    }\n    /**\r\n     * A method that creates a <a href=\"http://en.wikipedia.org/wiki/Object_copy#Deep_copy\">deep copy</a> of the object.\r\n     *\r\n     * @see Object#clone()\r\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var clone = new JewishDate(this.jewishYear, this.jewishMonth, this.jewishDay);\n      clone.setMoladHours(this.moladHours);\n      clone.setMoladMinutes(this.moladMinutes);\n      clone.setMoladChalakim(this.moladChalakim);\n      return clone;\n    }\n  }], [{\n    key: \"getLastDayOfGregorianMonth\",\n    value: function getLastDayOfGregorianMonth(month, year) {\n      switch (month) {\n        case 2:\n          if (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) {\n            return 29;\n          }\n\n          return 28;\n\n        case 4:\n        case 6:\n        case 9:\n        case 11:\n          return 30;\n\n        default:\n          return 31;\n      }\n    }\n  }, {\n    key: \"gregorianDateToAbsDate\",\n    value: function gregorianDateToAbsDate(year, month, dayOfMonth) {\n      var absDate = dayOfMonth;\n\n      for (var m = month - 1; m > 0; m--) {\n        absDate += JewishDate.getLastDayOfGregorianMonth(m, year); // days in prior months of the year\n      }\n\n      return absDate // days this year\n      + 365 * (year - 1) // days in previous years ignoring leap days\n      + Math.trunc((year - 1) / 4) // Julian leap days before this year\n      - Math.trunc((year - 1) / 100) // minus prior century years\n      + Math.trunc((year - 1) / 400); // plus prior years divisible by 400\n    }\n    /**\r\n     * Returns if the year is a Jewish leap year. Years 3, 6, 8, 11, 14, 17 and 19 in the 19 year cycle are leap years.\r\n     *\r\n     * @param year\r\n     *            the Jewish year.\r\n     * @return true if it is a leap year\r\n     * @see #isJewishLeapYear()\r\n     */\n\n  }, {\n    key: \"isJewishLeapYear\",\n    value: function isJewishLeapYear(year) {\n      return (7 * year + 1) % 19 < 7;\n    }\n  }, {\n    key: \"getLastMonthOfJewishYear\",\n    value: function getLastMonthOfJewishYear(year) {\n      return JewishDate.isJewishLeapYear(year) ? JewishDate.ADAR_II : JewishDate.ADAR;\n    }\n    /**\r\n     * Returns the number of days elapsed from the Sunday prior to the start of the Jewish calendar to the mean\r\n     * conjunction of Tishri of the Jewish year.\r\n     *\r\n     * @param year\r\n     *            the Jewish year\r\n     * @return the number of days elapsed from prior to the molad Tohu BaHaRaD (Be = Monday, Ha= 5 hours and Rad =204\r\n     *         chalakim/parts) prior to the start of the Jewish calendar, to the mean conjunction of Tishri of the\r\n     *         Jewish year. BeHaRaD is 23:11:20 on Sunday night(5 hours 204/1080 chalakim after sunset on Sunday\r\n     *         evening).\r\n     */\n\n  }, {\n    key: \"getJewishCalendarElapsedDays\",\n    value: function getJewishCalendarElapsedDays(year) {\n      var chalakimSince = JewishDate.getChalakimSinceMoladTohu(year, JewishDate.TISHREI);\n      var moladDay = Math.trunc(chalakimSince / JewishDate.CHALAKIM_PER_DAY);\n      var moladParts = Math.trunc(chalakimSince - moladDay * JewishDate.CHALAKIM_PER_DAY); // delay Rosh Hashana for the 4 dechiyos\n\n      return JewishDate.addDechiyos(year, moladDay, moladParts);\n    } // private static int getJewishCalendarElapsedDaysOLD(int year) {\n    // // Jewish lunar month = 29 days, 12 hours and 793 chalakim\n    // // Molad Tohu = BeHaRaD - Monday, 5 hours (11 PM) and 204 chalakim\n    // final int chalakimTashTZag = 793; // chalakim in a lunar month\n    // final int chalakimTohuRaD = 204; // chalakim from original molad Tohu BeHaRaD\n    // final int hoursTohuHa = 5; // hours from original molad Tohu BeHaRaD\n    // final int dayTohu = 1; // Monday (0 based)\n    //\n    // int monthsElapsed = (235 * ((year - 1) / 19)) // Months in complete 19 year lunar (Metonic) cycles so far\n    // + (12 * ((year - 1) % 19)) // Regular months in this cycle\n    // + ((7 * ((year - 1) % 19) + 1) / 19); // Leap months this cycle\n    // // start with Molad Tohu BeHaRaD\n    // // start with RaD of BeHaRaD and add TaShTzaG (793) chalakim plus elapsed chalakim\n    // int partsElapsed = chalakimTohuRaD + chalakimTashTZag * (monthsElapsed % 1080);\n    // // start with Ha hours of BeHaRaD, add 12 hour remainder of lunar month add hours elapsed\n    // int hoursElapsed = hoursTohuHa + 12 * monthsElapsed + 793 * (monthsElapsed / 1080) + partsElapsed / 1080;\n    // // start with Monday of BeHaRaD = 1 (0 based), add 29 days of the lunar months elapsed\n    // int conjunctionDay = dayTohu + 29 * monthsElapsed + hoursElapsed / 24;\n    // int conjunctionParts = 1080 * (hoursElapsed % 24) + partsElapsed % 1080;\n    // return addDechiyos(year, conjunctionDay, conjunctionParts);\n    // }\n\n    /**\r\n     * Adds the 4 dechiyos for molad Tishrei. These are:\r\n     * <ol>\r\n     * <li>Lo ADU Rosh - Rosh Hashana can't fall on a Sunday, Wednesday or Friday. If the molad fell on one of these\r\n     * days, Rosh Hashana is delayed to the following day.</li>\r\n     * <li>Molad Zaken - If the molad of Tishrei falls after 12 noon, Rosh Hashana is delayed to the following day. If\r\n     * the following day is ADU, it will be delayed an additional day.</li>\r\n     * <li>GaTRaD - If on a non leap year the molad of Tishrei falls on a Tuesday (Ga) on or after 9 hours (T) and 204\r\n     * chalakim (TRaD) it is delayed till Thursday (one day delay, plus one day for Lo ADU Rosh)</li>\r\n     * <li>BeTuTaKFoT - if the year following a leap year falls on a Monday (Be) on or after 15 hours (Tu) and 589\r\n     * chalakim (TaKFoT) it is delayed till Tuesday</li>\r\n     * </ol>\r\n     *\r\n     * @param year - the year\r\n     * @param moladDay - the molad day\r\n     * @param moladParts - the molad parts\r\n     * @return the number of elapsed days in the JewishCalendar adjusted for the 4 dechiyos.\r\n     */\n\n  }, {\n    key: \"addDechiyos\",\n    value: function addDechiyos(year, moladDay, moladParts) {\n      var roshHashanaDay = moladDay; // if no dechiyos\n      // delay Rosh Hashana for the dechiyos of the Molad - new moon 1 - Molad Zaken, 2- GaTRaD 3- BeTuTaKFoT\n\n      if (moladParts >= 19440 || // Dechiya of Molad Zaken - molad is >= midday (18 hours * 1080 chalakim)\n      moladDay % 7 === 2 && // start Dechiya of GaTRaD - Ga = is a Tuesday\n      moladParts >= 9924 // TRaD = 9 hours, 204 parts or later (9 * 1080 + 204)\n      && !JewishDate.isJewishLeapYear(year) // of a non-leap year - end Dechiya of GaTRaD\n      || moladDay % 7 === 1 && // start Dechiya of BeTuTaKFoT - Be = is on a Monday\n      moladParts >= 16789 // TRaD = 15 hours, 589 parts or later (15 * 1080 + 589)\n      && JewishDate.isJewishLeapYear(year - 1)) {\n        // in a year following a leap year - end Dechiya of BeTuTaKFoT\n        roshHashanaDay += 1; // Then postpone Rosh HaShanah one day\n      } // start 4th Dechiya - Lo ADU Rosh - Rosh Hashana can't occur on A- sunday, D- Wednesday, U - Friday\n\n\n      if (roshHashanaDay % 7 === 0 || // If Rosh HaShanah would occur on Sunday,\n      roshHashanaDay % 7 === 3 // or Wednesday,\n      || roshHashanaDay % 7 === 5) {\n        // or Friday - end 4th Dechiya - Lo ADU Rosh\n        roshHashanaDay++; // Then postpone it one (more) day\n      }\n\n      return roshHashanaDay;\n    }\n    /**\r\n     * Returns the number of chalakim (parts - 1080 to the hour) from the original hypothetical Molad Tohu to the year\r\n     * and month passed in.\r\n     *\r\n     * @param year\r\n     *            the Jewish year\r\n     * @param month\r\n     *            the Jewish month the Jewish month, with the month numbers starting from Nisan. Use the JewishDate\r\n     *            constants such as {@link JewishDate#TISHREI}.\r\n     * @return the number of chalakim (parts - 1080 to the hour) from the original hypothetical Molad Tohu\r\n     */\n\n  }, {\n    key: \"getChalakimSinceMoladTohu\",\n    value: function getChalakimSinceMoladTohu(year, month) {\n      // Jewish lunar month = 29 days, 12 hours and 793 chalakim\n      // chalakim since Molad Tohu BeHaRaD - 1 day, 5 hours and 204 chalakim\n      var monthOfYear = JewishDate.getJewishMonthOfYear(year, month);\n      var monthsElapsed = 235 * Math.trunc((year - 1) / 19) + // Months in complete 19 year lunar (Metonic) cycles so far\n      12 * ((year - 1) % 19) // Regular months in this cycle\n      + Math.trunc((7 * ((year - 1) % 19) + 1) / 19) // Leap months this cycle\n      + (monthOfYear - 1); // add elapsed months till the start of the molad of the month\n      // return chalakim prior to BeHaRaD + number of chalakim since\n\n      return JewishDate.CHALAKIM_MOLAD_TOHU + JewishDate.CHALAKIM_PER_MONTH * monthsElapsed;\n    }\n  }, {\n    key: \"getJewishMonthOfYear\",\n    value: function getJewishMonthOfYear(year, month) {\n      var isLeapYear = JewishDate.isJewishLeapYear(year);\n      return (month + (isLeapYear ? 6 : 5)) % (isLeapYear ? 13 : 12) + 1;\n    }\n    /**\r\n     * Validates the components of a Jewish date for validity. It will throw an {@link IllegalArgumentException} if the\r\n     * Jewish date is earlier than 18 Teves, 3761 (1/1/1 Gregorian), a month < 1 or > 12 (or 13 on a\r\n     * {@link #isJewishLeapYear(int) leap year}), the day of month is < 1 or > 30, an hour < 0 or > 23, a minute < 0 >\r\n     * 59 or chalakim < 0 > 17. For larger a larger number of chalakim such as 793 (TaShTzaG) break the chalakim into\r\n     * minutes (18 chalakim per minutes, so it would be 44 minutes and 1 chelek in the case of 793/TaShTzaG).\r\n     *\r\n     * @param year\r\n     *            the Jewish year to validate. It will reject any year <= 3761 (lower than the year 1 Gregorian).\r\n     * @param month\r\n     *            the Jewish month to validate. It will reject a month < 1 or > 12 (or 13 on a leap year) .\r\n     * @param dayOfMonth\r\n     *            the day of the Jewish month to validate. It will reject any value < 1 or > 30 TODO: check calling\r\n     *            methods to see if there is any reason that the class can validate that 30 is invalid for some months.\r\n     * @param hours\r\n     *            the hours (for molad calculations). It will reject an hour < 0 or > 23\r\n     * @param minutes\r\n     *            the minutes (for molad calculations). It will reject a minute < 0 or > 59\r\n     * @param chalakim\r\n     *            the chalakim/parts (for molad calculations). It will reject a chalakim < 0 or > 17. For larger numbers\r\n     *            such as 793 (TaShTzaG) break the chalakim into minutes (18 chalakim per minutes, so it would be 44\r\n     *            minutes and 1 chelek in the case of 793/TaShTzaG)\r\n     *\r\n     * @throws IllegalArgumentException\r\n     *             if a A Jewish date earlier than 18 Teves, 3761 (1/1/1 Gregorian), a month < 1 or > 12 (or 13 on a\r\n     *             leap year), the day of month is < 1 or > 30, an hour < 0 or > 23, a minute < 0 > 59 or chalakim < 0 >\r\n     *             17. For larger a larger number of chalakim such as 793 (TaShTzaG) break the chalakim into minutes (18\r\n     *             chalakim per minutes, so it would be 44 minutes and 1 chelek in the case of 793 (TaShTzaG).\r\n     */\n\n  }, {\n    key: \"validateJewishDate\",\n    value: function validateJewishDate(year, month, dayOfMonth, hours, minutes, chalakim) {\n      if (month < JewishDate.NISSAN || month > JewishDate.getLastMonthOfJewishYear(year)) {\n        throw new IllegalArgumentException(\"The Jewish month has to be between 1 and 12 (or 13 on a leap year). \".concat(month, \" is invalid for the year \").concat(year, \".\"));\n      }\n\n      if (dayOfMonth < 1 || dayOfMonth > 30) {\n        throw new IllegalArgumentException(\"The Jewish day of month can't be < 1 or > 30. \".concat(dayOfMonth, \" is invalid.\"));\n      } // reject dates prior to 18 Teves, 3761 (1/1/1 AD). This restriction can be relaxed if the date coding is\n      // changed/corrected\n\n\n      if (year < 3761 || year === 3761 && month >= JewishDate.TISHREI && month < JewishDate.TEVES || year === 3761 && month === JewishDate.TEVES && dayOfMonth < 18) {\n        throw new IllegalArgumentException(\"A Jewish date earlier than 18 Teves, 3761 (1/1/1 Gregorian) can't be set. \".concat(year, \", \").concat(month, \", \").concat(dayOfMonth, \" is invalid.\"));\n      }\n\n      if (hours < 0 || hours > 23) {\n        throw new IllegalArgumentException(\"Hours < 0 or > 23 can't be set. \".concat(hours, \" is invalid.\"));\n      }\n\n      if (minutes < 0 || minutes > 59) {\n        throw new IllegalArgumentException(\"Minutes < 0 or > 59 can't be set. \".concat(minutes, \" is invalid.\"));\n      }\n\n      if (chalakim < 0 || chalakim > 17) {\n        throw new IllegalArgumentException(\"Chalakim/parts < 0 or > 17 can't be set. \".concat(chalakim, \" is invalid. For larger numbers such as 793 (TaShTzaG) break the chalakim into minutes (18 chalakim per minutes, so it would be 44 minutes and 1 chelek in the case of 793 (TaShTzaG)\"));\n      }\n    }\n    /**\r\n     * Validates the components of a Gregorian date for validity. It will throw an {@link IllegalArgumentException} if a\r\n     * year of < 1, a month < 0 or > 11 or a day of month < 1 is passed in.\r\n     *\r\n     * @param year\r\n     *            the Gregorian year to validate. It will reject any year < 1.\r\n     * @param month\r\n     *            the Gregorian month number to validate. It will enforce that the month is between 0 - 11 like a\r\n     *            {@link GregorianCalendar}, where {@link Calendar#JANUARY} has a value of 0.\r\n     * @param dayOfMonth\r\n     *            the day of the Gregorian month to validate. It will reject any value < 1, but will allow values > 31\r\n     *            since calling methods will simply set it to the maximum for that month. TODO: check calling methods to\r\n     *            see if there is any reason that the class needs days > the maximum.\r\n     * @throws IllegalArgumentException\r\n     *             if a year of < 1, a month < 0 or > 11 or a day of month < 1 is passed in\r\n     * @see #validateGregorianYear(int)\r\n     * @see #validateGregorianMonth(int)\r\n     * @see #validateGregorianDayOfMonth(int)\r\n     */\n\n  }, {\n    key: \"validateGregorianDate\",\n    value: function validateGregorianDate(year, month, dayOfMonth) {\n      JewishDate.validateGregorianMonth(month);\n      JewishDate.validateGregorianDayOfMonth(dayOfMonth);\n      JewishDate.validateGregorianYear(year);\n    }\n    /**\r\n     * Validates a Gregorian month for validity.\r\n     *\r\n     * @param month\r\n     *            the Gregorian month number to validate. It will enforce that the month is between 0 - 11 like a\r\n     *            {@link GregorianCalendar}, where {@link Calendar#JANUARY} has a value of 0.\r\n     */\n\n  }, {\n    key: \"validateGregorianMonth\",\n    value: function validateGregorianMonth(month) {\n      if (month > 11 || month < 0) {\n        throw new IllegalArgumentException(\"The Gregorian month has to be between 0 - 11. \".concat(month, \" is invalid.\"));\n      }\n    }\n    /**\r\n     * Validates a Gregorian day of month for validity.\r\n     *\r\n     * @param dayOfMonth\r\n     *            the day of the Gregorian month to validate. It will reject any value < 1, but will allow values > 31\r\n     *            since calling methods will simply set it to the maximum for that month. TODO: check calling methods to\r\n     *            see if there is any reason that the class needs days > the maximum.\r\n     */\n\n  }, {\n    key: \"validateGregorianDayOfMonth\",\n    value: function validateGregorianDayOfMonth(dayOfMonth) {\n      if (dayOfMonth <= 0) {\n        throw new IllegalArgumentException(\"The day of month can't be less than 1. \".concat(dayOfMonth, \" is invalid.\"));\n      }\n    }\n    /**\r\n     * Validates a Gregorian year for validity.\r\n     *\r\n     * @param year\r\n     *            the Gregorian year to validate. It will reject any year < 1.\r\n     */\n\n  }, {\n    key: \"validateGregorianYear\",\n    value: function validateGregorianYear(year) {\n      if (year < 1) {\n        throw new IllegalArgumentException(\"Years < 1 can't be calculated. \".concat(year, \" is invalid.\"));\n      }\n    }\n    /**\r\n     * Returns the number of days for a given Jewish year. ND+ER\r\n     *\r\n     * @param year\r\n     *            the Jewish year\r\n     * @return the number of days for a given Jewish year.\r\n     * @see #isCheshvanLong()\r\n     * @see #isKislevShort()\r\n     */\n\n  }, {\n    key: \"getDaysInJewishYear\",\n    value: function getDaysInJewishYear(year) {\n      return JewishDate.getJewishCalendarElapsedDays(year + 1) - JewishDate.getJewishCalendarElapsedDays(year);\n    }\n  }, {\n    key: \"isCheshvanLong\",\n    value: function isCheshvanLong(year) {\n      return JewishDate.getDaysInJewishYear(year) % 10 === 5;\n    }\n  }, {\n    key: \"isKislevShort\",\n    value: function isKislevShort(year) {\n      return JewishDate.getDaysInJewishYear(year) % 10 === 3;\n    }\n  }, {\n    key: \"getDaysInJewishMonth\",\n    value: function getDaysInJewishMonth(month, year) {\n      var shortMonths = [JewishDate.IYAR, JewishDate.TAMMUZ, JewishDate.ELUL, JewishDate.ADAR_II];\n\n      if (shortMonths.includes(month) || month === JewishDate.CHESHVAN && !JewishDate.isCheshvanLong(year) || month === JewishDate.KISLEV && JewishDate.isKislevShort(year) || month === JewishDate.TEVES || month === JewishDate.ADAR && !JewishDate.isJewishLeapYear(year)) {\n        return 29;\n      }\n\n      return 30;\n    }\n  }, {\n    key: \"jewishDateToAbsDate\",\n    value: function jewishDateToAbsDate(year, month, dayOfMonth) {\n      var elapsed = JewishDate.getDaysSinceStartOfJewishYear(year, month, dayOfMonth); // add elapsed days this year + Days in prior years + Days elapsed before absolute year 1\n\n      return elapsed + JewishDate.getJewishCalendarElapsedDays(year) + JewishDate.JEWISH_EPOCH;\n    }\n  }, {\n    key: \"moladToAbsDate\",\n    value: function moladToAbsDate(chalakim) {\n      return Math.trunc(chalakim / JewishDate.CHALAKIM_PER_DAY) + JewishDate.JEWISH_EPOCH;\n    }\n  }, {\n    key: \"getDaysSinceStartOfJewishYear\",\n    value: function getDaysSinceStartOfJewishYear(year, month, dayOfMonth) {\n      var elapsedDays = dayOfMonth; // Before Tishrei (from Nissan to Tishrei), add days in prior months\n\n      if (month < JewishDate.TISHREI) {\n        // this year before and after Nisan.\n        for (var m = JewishDate.TISHREI; m <= JewishDate.getLastMonthOfJewishYear(year); m++) {\n          elapsedDays += JewishDate.getDaysInJewishMonth(m, year);\n        }\n\n        for (var _m = JewishDate.NISSAN; _m < month; _m++) {\n          elapsedDays += JewishDate.getDaysInJewishMonth(_m, year);\n        }\n      } else {\n        // Add days in prior months this year\n        for (var _m2 = JewishDate.TISHREI; _m2 < month; _m2++) {\n          elapsedDays += JewishDate.getDaysInJewishMonth(_m2, year);\n        }\n      }\n\n      return elapsedDays;\n    }\n  }]);\n\n  return JewishDate;\n}();\n/**\r\n * Value of the month field indicating Nissan, the first numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 7th (or 8th in a {@link #isJewishLeapYear() leap\r\n   * year}) month of the year.\r\n */\n\nJewishDate.NISSAN = 1;\n/**\r\n * Value of the month field indicating Iyar, the second numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 8th (or 9th in a {@link #isJewishLeapYear() leap\r\n   * year}) month of the year.\r\n */\n\nJewishDate.IYAR = 2;\n/**\r\n * Value of the month field indicating Sivan, the third numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 9th (or 10th in a {@link #isJewishLeapYear() leap\r\n   * year}) month of the year.\r\n */\n\nJewishDate.SIVAN = 3;\n/**\r\n * Value of the month field indicating Tammuz, the fourth numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 10th (or 11th in a {@link #isJewishLeapYear() leap\r\n   * year}) month of the year.\r\n */\n\nJewishDate.TAMMUZ = 4;\n/**\r\n * Value of the month field indicating Av, the fifth numeric month of the year in the Jewish calendar. With the year\r\n * starting at {@link #TISHREI}, it would actually be the 11th (or 12th in a {@link #isJewishLeapYear() leap year})\r\n * month of the year.\r\n */\n\nJewishDate.AV = 5;\n/**\r\n * Value of the month field indicating Elul, the sixth numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 12th (or 13th in a {@link #isJewishLeapYear() leap\r\n   * year}) month of the year.\r\n */\n\nJewishDate.ELUL = 6;\n/**\r\n * Value of the month field indicating Tishrei, the seventh numeric month of the year in the Jewish calendar. With\r\n * the year starting at this month, it would actually be the 1st month of the year.\r\n */\n\nJewishDate.TISHREI = 7;\n/**\r\n * Value of the month field indicating Cheshvan/marcheshvan, the eighth numeric month of the year in the Jewish\r\n * calendar. With the year starting at {@link #TISHREI}, it would actually be the 2nd month of the year.\r\n */\n\nJewishDate.CHESHVAN = 8;\n/**\r\n * Value of the month field indicating Kislev, the ninth numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 3rd month of the year.\r\n */\n\nJewishDate.KISLEV = 9;\n/**\r\n * Value of the month field indicating Teves, the tenth numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 4th month of the year.\r\n */\n\nJewishDate.TEVES = 10;\n/**\r\n * Value of the month field indicating Shevat, the eleventh numeric month of the year in the Jewish calendar. With\r\n * the year starting at {@link #TISHREI}, it would actually be the 5th month of the year.\r\n */\n\nJewishDate.SHEVAT = 11;\n/**\r\n * Value of the month field indicating Adar (or Adar I in a {@link #isJewishLeapYear() leap year}), the twelfth\r\n * numeric month of the year in the Jewish calendar. With the year starting at {@link #TISHREI}, it would actually\r\n * be the 6th month of the year.\r\n */\n\nJewishDate.ADAR = 12;\n/**\r\n * Value of the month field indicating Adar II, the leap (intercalary or embolismic) thirteenth (Undecimber) numeric\r\n * month of the year added in Jewish {@link #isJewishLeapYear() leap year}). The leap years are years 3, 6, 8, 11,\r\n * 14, 17 and 19 of a 19 year cycle. With the year starting at {@link #TISHREI}, it would actually be the 7th month\r\n * of the year.\r\n */\n\nJewishDate.ADAR_II = 13;\n/**\r\n * the Jewish epoch using the RD (Rata Die/Fixed Date or Reingold Dershowitz) day used in Calendrical Calculations.\r\n * Day 1 is January 1, 0001 Gregorian\r\n */\n\nJewishDate.JEWISH_EPOCH = -1373429;\nJewishDate.CHALAKIM_PER_MINUTE = 18;\nJewishDate.CHALAKIM_PER_HOUR = 1080;\nJewishDate.CHALAKIM_PER_DAY = 25920; // 24 * 1080\n\nJewishDate.CHALAKIM_PER_MONTH = 765433; // (29 * 24 + 12) * 1080 + 793\n\n/**\r\n * Days from the beginning of Sunday till molad BaHaRaD. Calculated as 1 day, 5 hours and 204 chalakim = (24 + 5) *\r\n * 1080 + 204 = 31524\r\n */\n\nJewishDate.CHALAKIM_MOLAD_TOHU = 31524;\n/**\r\n * A short year where both {@link #CHESHVAN} and {@link #KISLEV} are 29 days.\r\n *\r\n * @see #getCheshvanKislevKviah()\r\n * @see HebrewDateFormatter#getFormattedKviah(int)\r\n */\n\nJewishDate.CHASERIM = 0;\n/**\r\n * An ordered year where {@link #CHESHVAN} is 29 days and {@link #KISLEV} is 30 days.\r\n *\r\n * @see #getCheshvanKislevKviah()\r\n * @see HebrewDateFormatter#getFormattedKviah(int)\r\n */\n\nJewishDate.KESIDRAN = 1;\n/**\r\n * A long year where both {@link #CHESHVAN} and {@link #KISLEV} are 30 days.\r\n *\r\n * @see #getCheshvanKislevKviah()\r\n * @see HebrewDateFormatter#getFormattedKviah(int)\r\n */\n\nJewishDate.SHELAIMIM = 2;","map":{"version":3,"sources":["../../../src/hebrewcalendar/JewishDate.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { DateTime } from 'luxon';\r\nimport { Calendar, IntegerUtils } from '../polyfills/Utils';\r\nimport { IllegalArgumentException } from '../polyfills/errors';\r\n/**\r\n * The JewishDate is the base calendar class, that supports maintenance of a {@link java.util.GregorianCalendar}\r\n * instance along with the corresponding Jewish date. This class can use the standard Java Date and Calendar\r\n * classes for setting and maintaining the dates, but it does not subclass these classes or use them internally\r\n * in any calculations. This class also does not have a concept of a time (which the Date class does). Please\r\n * note that the calendar does not currently support dates prior to 1/1/1 Gregorian. Also keep in mind that the\r\n * Gregorian calendar started on October 15, 1582, so any calculations prior to that are suspect (at least from\r\n * a Gregorian perspective). While 1/1/1 Gregorian and forward are technically supported, any calculations prior to <a\r\n * href=\"http://en.wikipedia.org/wiki/Hillel_II\">Hillel II's (Hakatan's</a>) calendar (4119 in the Jewish Calendar / 359\r\n * CE Julian as recorded by <a href=\"http://en.wikipedia.org/wiki/Hai_Gaon\">Rav Hai Gaon</a>) would be just an\r\n * approximation.\r\n *\r\n * This open source Java code was written by <a href=\"http://www.facebook.com/avromf\">Avrom Finkelstien</a> from his C++\r\n * code. It was refactored to fit the KosherJava Zmanim API with simplification of the code, enhancements and some bug\r\n * fixing.\r\n *\r\n * Some of Avrom's original C++ code was translated from <a href=\"https://web.archive.org/web/20120124134148/http://emr.cs.uiuc.edu/~reingold/calendar.C\">C/C++\r\n * code</a> in <a href=\"http://www.calendarists.com\">Calendrical Calculations</a> by Nachum Dershowitz and Edward M.\r\n * Reingold, Software-- Practice &amp; Experience, vol. 20, no. 9 (September, 1990), pp. 899- 928. Any method with the mark\r\n * \"ND+ER\" indicates that the method was taken from this source with minor modifications.\r\n *\r\n * If you are looking for a class that implements a Jewish calendar version of the Calendar class, one is available from\r\n * the <a href=\"http://site.icu-project.org/\" >ICU (International Components for Unicode)</a> project, formerly part of\r\n * IBM's DeveloperWorks.\r\n *\r\n * @see net.sourceforge.zmanim.hebrewcalendar.JewishCalendar\r\n * @see net.sourceforge.zmanim.hebrewcalendar.HebrewDateFormatter\r\n * @see java.util.Date\r\n * @see java.util.Calendar\r\n * @author &copy; Avrom Finkelstien 2002\r\n * @author &copy; Eliyahu Hershfeld 2011 - 2015\r\n */\r\nexport class JewishDate {\r\n    constructor(jewishYearOrDateTimeOrDateOrMolad, jewishMonth, jewishDayOfMonth) {\r\n        if (!jewishYearOrDateTimeOrDateOrMolad) {\r\n            this.resetDate();\r\n        }\r\n        else if (jewishMonth) {\r\n            this.setJewishDate(jewishYearOrDateTimeOrDateOrMolad, jewishMonth, jewishDayOfMonth);\r\n        }\r\n        else if (jewishYearOrDateTimeOrDateOrMolad instanceof Date) {\r\n            this.setDate(DateTime.fromJSDate(jewishYearOrDateTimeOrDateOrMolad));\r\n        }\r\n        else if (DateTime.isDateTime(jewishYearOrDateTimeOrDateOrMolad)) {\r\n            this.setDate(jewishYearOrDateTimeOrDateOrMolad);\r\n        }\r\n        else if (typeof jewishYearOrDateTimeOrDateOrMolad === 'number') {\r\n            const molad = jewishYearOrDateTimeOrDateOrMolad;\r\n            this.absDateToDate(JewishDate.moladToAbsDate(molad));\r\n            // long chalakimSince = getChalakimSinceMoladTohu(year, JewishDate.TISHREI);// tishrei\r\n            const conjunctionDay = Math.trunc(molad / JewishDate.CHALAKIM_PER_DAY);\r\n            const conjunctionParts = Math.trunc(molad - conjunctionDay * JewishDate.CHALAKIM_PER_DAY);\r\n            this.setMoladTime(conjunctionParts);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the molad hours. Only a JewishDate object populated with {@link #getMolad()},\r\n     * {@link #setJewishDate(int, int, int, int, int, int)} or {@link #setMoladHours(int)} will have this field\r\n     * populated. A regular JewishDate object will have this field set to 0.\r\n     *\r\n     * @return the molad hours\r\n     * @see #setMoladHours(int)\r\n     * @see #getMolad()\r\n     * @see #setJewishDate(int, int, int, int, int, int)\r\n     */\r\n    getMoladHours() {\r\n        return this.moladHours;\r\n    }\r\n    /**\r\n     * Sets the molad hours.\r\n     *\r\n     * @param moladHours\r\n     *            the molad hours to set\r\n     * @see #getMoladHours()\r\n     * @see #getMolad()\r\n     * @see #setJewishDate(int, int, int, int, int, int)\r\n     *\r\n     */\r\n    setMoladHours(moladHours) {\r\n        this.moladHours = moladHours;\r\n    }\r\n    /**\r\n     * Returns the molad minutes. Only an object populated with {@link #getMolad()},\r\n     * {@link #setJewishDate(int, int, int, int, int, int)} or or {@link #setMoladMinutes(int)} will have these fields\r\n     * populated. A regular JewishDate object will have this field set to 0.\r\n     *\r\n     * @return the molad minutes\r\n     * @see #setMoladMinutes(int)\r\n     * @see #getMolad()\r\n     * @see #setJewishDate(int, int, int, int, int, int)\r\n     */\r\n    getMoladMinutes() {\r\n        return this.moladMinutes;\r\n    }\r\n    /**\r\n     * Sets the molad minutes. The expectation is that the traditional minute-less chalakim will be broken out to\r\n     * minutes and {@link #setMoladChalakim(int) chalakim/parts} , so 793 (TaShTZaG) parts would have the minutes set to\r\n     * 44 and chalakim to 1.\r\n     *\r\n     * @param moladMinutes\r\n     *            the molad minutes to set\r\n     * @see #getMoladMinutes()\r\n     * @see #setMoladChalakim(int)\r\n     * @see #getMolad()\r\n     * @see #setJewishDate(int, int, int, int, int, int)\r\n     *\r\n     */\r\n    setMoladMinutes(moladMinutes) {\r\n        this.moladMinutes = moladMinutes;\r\n    }\r\n    /**\r\n     * Sets the molad chalakim/parts. The expectation is that the traditional minute-less chalakim will be broken out to\r\n     * {@link #setMoladMinutes(int) minutes} and chalakim, so 793 (TaShTZaG) parts would have the minutes set to 44 and\r\n     * chalakim to 1.\r\n     *\r\n     * @param moladChalakim\r\n     *            the molad chalakim/parts to set\r\n     * @see #getMoladChalakim()\r\n     * @see #setMoladMinutes(int)\r\n     * @see #getMolad()\r\n     * @see #setJewishDate(int, int, int, int, int, int)\r\n     *\r\n     */\r\n    setMoladChalakim(moladChalakim) {\r\n        this.moladChalakim = moladChalakim;\r\n    }\r\n    /**\r\n     * Returns the molad chalakim/parts. Only an object populated with {@link #getMolad()},\r\n     * {@link #setJewishDate(int, int, int, int, int, int)} or or {@link #setMoladChalakim(int)} will have these fields\r\n     * populated. A regular JewishDate object will have this field set to 0.\r\n     *\r\n     * @return the molad chalakim/parts\r\n     * @see #setMoladChalakim(int)\r\n     * @see #getMolad()\r\n     * @see #setJewishDate(int, int, int, int, int, int)\r\n     */\r\n    getMoladChalakim() {\r\n        return this.moladChalakim;\r\n    }\r\n    /**\r\n     * Returns the last day in a gregorian month\r\n     *\r\n     * @param month\r\n     *            the Gregorian month\r\n     * @return the last day of the Gregorian month\r\n     */\r\n    getLastDayOfGregorianMonth(month) {\r\n        return JewishDate.getLastDayOfGregorianMonth(month, this.gregorianYear);\r\n    }\r\n    /**\r\n     * Returns the number of days in a given month in a given month and year.\r\n     *\r\n     * @param month\r\n     *            the month. As with other cases in this class, this is 1-based, not zero-based.\r\n     * @param year\r\n     *            the year (only impacts February)\r\n     * @return the number of days in the month in the given year\r\n     */\r\n    static getLastDayOfGregorianMonth(month, year) {\r\n        switch (month) {\r\n            case 2:\r\n                if ((year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0)) {\r\n                    return 29;\r\n                }\r\n                return 28;\r\n            case 4:\r\n            case 6:\r\n            case 9:\r\n            case 11:\r\n                return 30;\r\n            default:\r\n                return 31;\r\n        }\r\n    }\r\n    /**\r\n     * Computes the Gregorian date from the absolute date. ND+ER\r\n     * @param absDate - the absolute date\r\n     */\r\n    absDateToDate(absDate) {\r\n        let year = Math.trunc(absDate / 366); // Search forward year by year from approximate year\r\n        while (absDate >= JewishDate.gregorianDateToAbsDate(year + 1, 1, 1)) {\r\n            year++;\r\n        }\r\n        let month = 1; // Search forward month by month from January\r\n        while (absDate > JewishDate.gregorianDateToAbsDate(year, month, JewishDate.getLastDayOfGregorianMonth(month, year))) {\r\n            month++;\r\n        }\r\n        const dayOfMonth = absDate - JewishDate.gregorianDateToAbsDate(year, month, 1) + 1;\r\n        this.setInternalGregorianDate(year, month, dayOfMonth);\r\n    }\r\n    /**\r\n     * Returns the absolute date (days since January 1, 0001 on the Gregorian calendar).\r\n     *\r\n     * @return the number of days since January 1, 1\r\n     */\r\n    getAbsDate() {\r\n        return this.gregorianAbsDate;\r\n    }\r\n    /**\r\n     * Computes the absolute date from a Gregorian date. ND+ER\r\n     *\r\n     * @param year\r\n     *            the Gregorian year\r\n     * @param month\r\n     *            the Gregorian month. Unlike the Java Calendar where January has the value of 0,This expects a 1 for\r\n     *            January\r\n     * @param dayOfMonth\r\n     *            the day of the month (1st, 2nd, etc...)\r\n     * @return the absolute Gregorian day\r\n     */\r\n    static gregorianDateToAbsDate(year, month, dayOfMonth) {\r\n        let absDate = dayOfMonth;\r\n        for (let m = month - 1; m > 0; m--) {\r\n            absDate += JewishDate.getLastDayOfGregorianMonth(m, year); // days in prior months of the year\r\n        }\r\n        return (absDate // days this year\r\n            + 365 * (year - 1) // days in previous years ignoring leap days\r\n            + Math.trunc((year - 1) / 4) // Julian leap days before this year\r\n            - Math.trunc((year - 1) / 100) // minus prior century years\r\n            + Math.trunc((year - 1) / 400)); // plus prior years divisible by 400\r\n    }\r\n    /**\r\n     * Returns if the year is a Jewish leap year. Years 3, 6, 8, 11, 14, 17 and 19 in the 19 year cycle are leap years.\r\n     *\r\n     * @param year\r\n     *            the Jewish year.\r\n     * @return true if it is a leap year\r\n     * @see #isJewishLeapYear()\r\n     */\r\n    static isJewishLeapYear(year) {\r\n        return ((7 * year) + 1) % 19 < 7;\r\n    }\r\n    /**\r\n     * Returns if the year the calendar is set to is a Jewish leap year. Years 3, 6, 8, 11, 14, 17 and 19 in the 19 year\r\n     * cycle are leap years.\r\n     *\r\n     * @return true if it is a leap year\r\n     * @see #isJewishLeapYear(int)\r\n     */\r\n    isJewishLeapYear() {\r\n        return JewishDate.isJewishLeapYear(this.getJewishYear());\r\n    }\r\n    /**\r\n     * Returns the last month of a given Jewish year. This will be 12 on a non {@link #isJewishLeapYear(int) leap year}\r\n     * or 13 on a leap year.\r\n     *\r\n     * @param year\r\n     *            the Jewish year.\r\n     * @return 12 on a non leap year or 13 on a leap year\r\n     * @see #isJewishLeapYear(int)\r\n     */\r\n    static getLastMonthOfJewishYear(year) {\r\n        return JewishDate.isJewishLeapYear(year) ? JewishDate.ADAR_II : JewishDate.ADAR;\r\n    }\r\n    /**\r\n     * Returns the number of days elapsed from the Sunday prior to the start of the Jewish calendar to the mean\r\n     * conjunction of Tishri of the Jewish year.\r\n     *\r\n     * @param year\r\n     *            the Jewish year\r\n     * @return the number of days elapsed from prior to the molad Tohu BaHaRaD (Be = Monday, Ha= 5 hours and Rad =204\r\n     *         chalakim/parts) prior to the start of the Jewish calendar, to the mean conjunction of Tishri of the\r\n     *         Jewish year. BeHaRaD is 23:11:20 on Sunday night(5 hours 204/1080 chalakim after sunset on Sunday\r\n     *         evening).\r\n     */\r\n    static getJewishCalendarElapsedDays(year) {\r\n        const chalakimSince = JewishDate.getChalakimSinceMoladTohu(year, JewishDate.TISHREI);\r\n        const moladDay = Math.trunc(chalakimSince / JewishDate.CHALAKIM_PER_DAY);\r\n        const moladParts = Math.trunc(chalakimSince - moladDay * JewishDate.CHALAKIM_PER_DAY);\r\n        // delay Rosh Hashana for the 4 dechiyos\r\n        return JewishDate.addDechiyos(year, moladDay, moladParts);\r\n    }\r\n    // private static int getJewishCalendarElapsedDaysOLD(int year) {\r\n    // // Jewish lunar month = 29 days, 12 hours and 793 chalakim\r\n    // // Molad Tohu = BeHaRaD - Monday, 5 hours (11 PM) and 204 chalakim\r\n    // final int chalakimTashTZag = 793; // chalakim in a lunar month\r\n    // final int chalakimTohuRaD = 204; // chalakim from original molad Tohu BeHaRaD\r\n    // final int hoursTohuHa = 5; // hours from original molad Tohu BeHaRaD\r\n    // final int dayTohu = 1; // Monday (0 based)\r\n    //\r\n    // int monthsElapsed = (235 * ((year - 1) / 19)) // Months in complete 19 year lunar (Metonic) cycles so far\r\n    // + (12 * ((year - 1) % 19)) // Regular months in this cycle\r\n    // + ((7 * ((year - 1) % 19) + 1) / 19); // Leap months this cycle\r\n    // // start with Molad Tohu BeHaRaD\r\n    // // start with RaD of BeHaRaD and add TaShTzaG (793) chalakim plus elapsed chalakim\r\n    // int partsElapsed = chalakimTohuRaD + chalakimTashTZag * (monthsElapsed % 1080);\r\n    // // start with Ha hours of BeHaRaD, add 12 hour remainder of lunar month add hours elapsed\r\n    // int hoursElapsed = hoursTohuHa + 12 * monthsElapsed + 793 * (monthsElapsed / 1080) + partsElapsed / 1080;\r\n    // // start with Monday of BeHaRaD = 1 (0 based), add 29 days of the lunar months elapsed\r\n    // int conjunctionDay = dayTohu + 29 * monthsElapsed + hoursElapsed / 24;\r\n    // int conjunctionParts = 1080 * (hoursElapsed % 24) + partsElapsed % 1080;\r\n    // return addDechiyos(year, conjunctionDay, conjunctionParts);\r\n    // }\r\n    /**\r\n     * Adds the 4 dechiyos for molad Tishrei. These are:\r\n     * <ol>\r\n     * <li>Lo ADU Rosh - Rosh Hashana can't fall on a Sunday, Wednesday or Friday. If the molad fell on one of these\r\n     * days, Rosh Hashana is delayed to the following day.</li>\r\n     * <li>Molad Zaken - If the molad of Tishrei falls after 12 noon, Rosh Hashana is delayed to the following day. If\r\n     * the following day is ADU, it will be delayed an additional day.</li>\r\n     * <li>GaTRaD - If on a non leap year the molad of Tishrei falls on a Tuesday (Ga) on or after 9 hours (T) and 204\r\n     * chalakim (TRaD) it is delayed till Thursday (one day delay, plus one day for Lo ADU Rosh)</li>\r\n     * <li>BeTuTaKFoT - if the year following a leap year falls on a Monday (Be) on or after 15 hours (Tu) and 589\r\n     * chalakim (TaKFoT) it is delayed till Tuesday</li>\r\n     * </ol>\r\n     *\r\n     * @param year - the year\r\n     * @param moladDay - the molad day\r\n     * @param moladParts - the molad parts\r\n     * @return the number of elapsed days in the JewishCalendar adjusted for the 4 dechiyos.\r\n     */\r\n    static addDechiyos(year, moladDay, moladParts) {\r\n        let roshHashanaDay = moladDay; // if no dechiyos\r\n        // delay Rosh Hashana for the dechiyos of the Molad - new moon 1 - Molad Zaken, 2- GaTRaD 3- BeTuTaKFoT\r\n        if ((moladParts >= 19440) // Dechiya of Molad Zaken - molad is >= midday (18 hours * 1080 chalakim)\r\n            || (((moladDay % 7) === 2) // start Dechiya of GaTRaD - Ga = is a Tuesday\r\n                && (moladParts >= 9924) // TRaD = 9 hours, 204 parts or later (9 * 1080 + 204)\r\n                && !JewishDate.isJewishLeapYear(year)) // of a non-leap year - end Dechiya of GaTRaD\r\n            || (((moladDay % 7) === 1) // start Dechiya of BeTuTaKFoT - Be = is on a Monday\r\n                && (moladParts >= 16789) // TRaD = 15 hours, 589 parts or later (15 * 1080 + 589)\r\n                && (JewishDate.isJewishLeapYear(year - 1)))) { // in a year following a leap year - end Dechiya of BeTuTaKFoT\r\n            roshHashanaDay += 1; // Then postpone Rosh HaShanah one day\r\n        }\r\n        // start 4th Dechiya - Lo ADU Rosh - Rosh Hashana can't occur on A- sunday, D- Wednesday, U - Friday\r\n        if (((roshHashanaDay % 7) === 0) // If Rosh HaShanah would occur on Sunday,\r\n            || ((roshHashanaDay % 7) === 3) // or Wednesday,\r\n            || ((roshHashanaDay % 7) === 5)) { // or Friday - end 4th Dechiya - Lo ADU Rosh\r\n            roshHashanaDay++; // Then postpone it one (more) day\r\n        }\r\n        return roshHashanaDay;\r\n    }\r\n    /**\r\n     * Returns the number of chalakim (parts - 1080 to the hour) from the original hypothetical Molad Tohu to the year\r\n     * and month passed in.\r\n     *\r\n     * @param year\r\n     *            the Jewish year\r\n     * @param month\r\n     *            the Jewish month the Jewish month, with the month numbers starting from Nisan. Use the JewishDate\r\n     *            constants such as {@link JewishDate#TISHREI}.\r\n     * @return the number of chalakim (parts - 1080 to the hour) from the original hypothetical Molad Tohu\r\n     */\r\n    static getChalakimSinceMoladTohu(year, month) {\r\n        // Jewish lunar month = 29 days, 12 hours and 793 chalakim\r\n        // chalakim since Molad Tohu BeHaRaD - 1 day, 5 hours and 204 chalakim\r\n        const monthOfYear = JewishDate.getJewishMonthOfYear(year, month);\r\n        const monthsElapsed = (235 * Math.trunc((year - 1) / 19)) // Months in complete 19 year lunar (Metonic) cycles so far\r\n            + (12 * ((year - 1) % 19)) // Regular months in this cycle\r\n            + Math.trunc((7 * ((year - 1) % 19) + 1) / 19) // Leap months this cycle\r\n            + (monthOfYear - 1); // add elapsed months till the start of the molad of the month\r\n        // return chalakim prior to BeHaRaD + number of chalakim since\r\n        return JewishDate.CHALAKIM_MOLAD_TOHU + (JewishDate.CHALAKIM_PER_MONTH * monthsElapsed);\r\n    }\r\n    /**\r\n     * Returns the number of chalakim (parts - 1080 to the hour) from the original hypothetical Molad Tohu to the Jewish\r\n     * year and month that this Object is set to.\r\n     *\r\n     * @return the number of chalakim (parts - 1080 to the hour) from the original hypothetical Molad Tohu\r\n     */\r\n    getChalakimSinceMoladTohu() {\r\n        return JewishDate.getChalakimSinceMoladTohu(this.jewishYear, this.jewishMonth);\r\n    }\r\n    /**\r\n     * Converts the {@link JewishDate#NISSAN} based constants used by this class to numeric month starting from\r\n     * {@link JewishDate#TISHREI}. This is required for Molad claculations.\r\n     *\r\n     * @param year\r\n     *            The Jewish year\r\n     * @param month\r\n     *            The Jewish Month\r\n     * @return the Jewish month of the year starting with Tishrei\r\n     */\r\n    static getJewishMonthOfYear(year, month) {\r\n        const isLeapYear = JewishDate.isJewishLeapYear(year);\r\n        return ((month + (isLeapYear ? 6 : 5)) % (isLeapYear ? 13 : 12)) + 1;\r\n    }\r\n    /**\r\n     * Validates the components of a Jewish date for validity. It will throw an {@link IllegalArgumentException} if the\r\n     * Jewish date is earlier than 18 Teves, 3761 (1/1/1 Gregorian), a month < 1 or > 12 (or 13 on a\r\n     * {@link #isJewishLeapYear(int) leap year}), the day of month is < 1 or > 30, an hour < 0 or > 23, a minute < 0 >\r\n     * 59 or chalakim < 0 > 17. For larger a larger number of chalakim such as 793 (TaShTzaG) break the chalakim into\r\n     * minutes (18 chalakim per minutes, so it would be 44 minutes and 1 chelek in the case of 793/TaShTzaG).\r\n     *\r\n     * @param year\r\n     *            the Jewish year to validate. It will reject any year <= 3761 (lower than the year 1 Gregorian).\r\n     * @param month\r\n     *            the Jewish month to validate. It will reject a month < 1 or > 12 (or 13 on a leap year) .\r\n     * @param dayOfMonth\r\n     *            the day of the Jewish month to validate. It will reject any value < 1 or > 30 TODO: check calling\r\n     *            methods to see if there is any reason that the class can validate that 30 is invalid for some months.\r\n     * @param hours\r\n     *            the hours (for molad calculations). It will reject an hour < 0 or > 23\r\n     * @param minutes\r\n     *            the minutes (for molad calculations). It will reject a minute < 0 or > 59\r\n     * @param chalakim\r\n     *            the chalakim/parts (for molad calculations). It will reject a chalakim < 0 or > 17. For larger numbers\r\n     *            such as 793 (TaShTzaG) break the chalakim into minutes (18 chalakim per minutes, so it would be 44\r\n     *            minutes and 1 chelek in the case of 793/TaShTzaG)\r\n     *\r\n     * @throws IllegalArgumentException\r\n     *             if a A Jewish date earlier than 18 Teves, 3761 (1/1/1 Gregorian), a month < 1 or > 12 (or 13 on a\r\n     *             leap year), the day of month is < 1 or > 30, an hour < 0 or > 23, a minute < 0 > 59 or chalakim < 0 >\r\n     *             17. For larger a larger number of chalakim such as 793 (TaShTzaG) break the chalakim into minutes (18\r\n     *             chalakim per minutes, so it would be 44 minutes and 1 chelek in the case of 793 (TaShTzaG).\r\n     */\r\n    static validateJewishDate(year, month, dayOfMonth, hours, minutes, chalakim) {\r\n        if (month < JewishDate.NISSAN || month > JewishDate.getLastMonthOfJewishYear(year)) {\r\n            throw new IllegalArgumentException(`The Jewish month has to be between 1 and 12 (or 13 on a leap year). ${month} is invalid for the year ${year}.`);\r\n        }\r\n        if (dayOfMonth < 1 || dayOfMonth > 30) {\r\n            throw new IllegalArgumentException(`The Jewish day of month can't be < 1 or > 30. ${dayOfMonth} is invalid.`);\r\n        }\r\n        // reject dates prior to 18 Teves, 3761 (1/1/1 AD). This restriction can be relaxed if the date coding is\r\n        // changed/corrected\r\n        if ((year < 3761) || (year === 3761 && (month >= JewishDate.TISHREI && month < JewishDate.TEVES))\r\n            || (year === 3761 && month === JewishDate.TEVES && dayOfMonth < 18)) {\r\n            throw new IllegalArgumentException(`A Jewish date earlier than 18 Teves, 3761 (1/1/1 Gregorian) can't be set. ${year}, ${month}, ${dayOfMonth} is invalid.`);\r\n        }\r\n        if (hours < 0 || hours > 23) {\r\n            throw new IllegalArgumentException(`Hours < 0 or > 23 can't be set. ${hours} is invalid.`);\r\n        }\r\n        if (minutes < 0 || minutes > 59) {\r\n            throw new IllegalArgumentException(`Minutes < 0 or > 59 can't be set. ${minutes} is invalid.`);\r\n        }\r\n        if (chalakim < 0 || chalakim > 17) {\r\n            throw new IllegalArgumentException(`Chalakim/parts < 0 or > 17 can't be set. ${chalakim} is invalid. For larger numbers such as 793 (TaShTzaG) break the chalakim into minutes (18 chalakim per minutes, so it would be 44 minutes and 1 chelek in the case of 793 (TaShTzaG)`);\r\n        }\r\n    }\r\n    /**\r\n     * Validates the components of a Gregorian date for validity. It will throw an {@link IllegalArgumentException} if a\r\n     * year of < 1, a month < 0 or > 11 or a day of month < 1 is passed in.\r\n     *\r\n     * @param year\r\n     *            the Gregorian year to validate. It will reject any year < 1.\r\n     * @param month\r\n     *            the Gregorian month number to validate. It will enforce that the month is between 0 - 11 like a\r\n     *            {@link GregorianCalendar}, where {@link Calendar#JANUARY} has a value of 0.\r\n     * @param dayOfMonth\r\n     *            the day of the Gregorian month to validate. It will reject any value < 1, but will allow values > 31\r\n     *            since calling methods will simply set it to the maximum for that month. TODO: check calling methods to\r\n     *            see if there is any reason that the class needs days > the maximum.\r\n     * @throws IllegalArgumentException\r\n     *             if a year of < 1, a month < 0 or > 11 or a day of month < 1 is passed in\r\n     * @see #validateGregorianYear(int)\r\n     * @see #validateGregorianMonth(int)\r\n     * @see #validateGregorianDayOfMonth(int)\r\n     */\r\n    static validateGregorianDate(year, month, dayOfMonth) {\r\n        JewishDate.validateGregorianMonth(month);\r\n        JewishDate.validateGregorianDayOfMonth(dayOfMonth);\r\n        JewishDate.validateGregorianYear(year);\r\n    }\r\n    /**\r\n     * Validates a Gregorian month for validity.\r\n     *\r\n     * @param month\r\n     *            the Gregorian month number to validate. It will enforce that the month is between 0 - 11 like a\r\n     *            {@link GregorianCalendar}, where {@link Calendar#JANUARY} has a value of 0.\r\n     */\r\n    static validateGregorianMonth(month) {\r\n        if (month > 11 || month < 0) {\r\n            throw new IllegalArgumentException(`The Gregorian month has to be between 0 - 11. ${month} is invalid.`);\r\n        }\r\n    }\r\n    /**\r\n     * Validates a Gregorian day of month for validity.\r\n     *\r\n     * @param dayOfMonth\r\n     *            the day of the Gregorian month to validate. It will reject any value < 1, but will allow values > 31\r\n     *            since calling methods will simply set it to the maximum for that month. TODO: check calling methods to\r\n     *            see if there is any reason that the class needs days > the maximum.\r\n     */\r\n    static validateGregorianDayOfMonth(dayOfMonth) {\r\n        if (dayOfMonth <= 0) {\r\n            throw new IllegalArgumentException(`The day of month can't be less than 1. ${dayOfMonth} is invalid.`);\r\n        }\r\n    }\r\n    /**\r\n     * Validates a Gregorian year for validity.\r\n     *\r\n     * @param year\r\n     *            the Gregorian year to validate. It will reject any year < 1.\r\n     */\r\n    static validateGregorianYear(year) {\r\n        if (year < 1) {\r\n            throw new IllegalArgumentException(`Years < 1 can't be calculated. ${year} is invalid.`);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the number of days for a given Jewish year. ND+ER\r\n     *\r\n     * @param year\r\n     *            the Jewish year\r\n     * @return the number of days for a given Jewish year.\r\n     * @see #isCheshvanLong()\r\n     * @see #isKislevShort()\r\n     */\r\n    static getDaysInJewishYear(year) {\r\n        return JewishDate.getJewishCalendarElapsedDays(year + 1) - JewishDate.getJewishCalendarElapsedDays(year);\r\n    }\r\n    /**\r\n     * Returns the number of days for the current year that the calendar is set to.\r\n     *\r\n     * @return the number of days for the Object's current Jewish year.\r\n     * @see #isCheshvanLong()\r\n     * @see #isKislevShort()\r\n     * @see #isJewishLeapYear()\r\n     */\r\n    getDaysInJewishYear() {\r\n        return JewishDate.getDaysInJewishYear(this.getJewishYear());\r\n    }\r\n    /**\r\n     * Returns if Cheshvan is long in a given Jewish year. The method name isLong is done since in a Kesidran (ordered)\r\n     * year Cheshvan is short. ND+ER\r\n     *\r\n     * @param year\r\n     *            the year\r\n     * @return true if Cheshvan is long in Jewish year.\r\n     * @see #isCheshvanLong()\r\n     * @see #getCheshvanKislevKviah()\r\n     */\r\n    static isCheshvanLong(year) {\r\n        return JewishDate.getDaysInJewishYear(year) % 10 === 5;\r\n    }\r\n    /**\r\n     * Returns if Cheshvan is long (30 days VS 29 days) for the current year that the calendar is set to. The method\r\n     * name isLong is done since in a Kesidran (ordered) year Cheshvan is short.\r\n     *\r\n     * @return true if Cheshvan is long for the current year that the calendar is set to\r\n     * @see #isCheshvanLong()\r\n     */\r\n    isCheshvanLong() {\r\n        return JewishDate.isCheshvanLong(this.getJewishYear());\r\n    }\r\n    /**\r\n     * Returns if Kislev is short (29 days VS 30 days) in a given Jewish year. The method name isShort is done since in\r\n     * a Kesidran (ordered) year Kislev is long. ND+ER\r\n     *\r\n     * @param year\r\n     *            the Jewish year\r\n     * @return true if Kislev is short for the given Jewish year.\r\n     * @see #isKislevShort()\r\n     * @see #getCheshvanKislevKviah()\r\n     */\r\n    static isKislevShort(year) {\r\n        return JewishDate.getDaysInJewishYear(year) % 10 === 3;\r\n    }\r\n    /**\r\n     * Returns if the Kislev is short for the year that this class is set to. The method name isShort is done since in a\r\n     * Kesidran (ordered) year Kislev is long.\r\n     *\r\n     * @return true if Kislev is short for the year that this class is set to\r\n     */\r\n    isKislevShort() {\r\n        return JewishDate.isKislevShort(this.getJewishYear());\r\n    }\r\n    /**\r\n     * Returns the Cheshvan and Kislev kviah (whether a Jewish year is short, regular or long). It will return\r\n     * {@link #SHELAIMIM} if both cheshvan and kislev are 30 days, {@link #KESIDRAN} if Cheshvan is 29 days and Kislev\r\n     * is 30 days and {@link #CHASERIM} if both are 29 days.\r\n     *\r\n     * @return {@link #SHELAIMIM} if both cheshvan and kislev are 30 days, {@link #KESIDRAN} if Cheshvan is 29 days and\r\n     *         Kislev is 30 days and {@link #CHASERIM} if both are 29 days.\r\n     * @see #isCheshvanLong()\r\n     * @see #isKislevShort()\r\n     */\r\n    getCheshvanKislevKviah() {\r\n        if (this.isCheshvanLong() && !this.isKislevShort()) {\r\n            return JewishDate.SHELAIMIM;\r\n        }\r\n        else if (!this.isCheshvanLong() && this.isKislevShort()) {\r\n            return JewishDate.CHASERIM;\r\n        }\r\n        return JewishDate.KESIDRAN;\r\n    }\r\n    /**\r\n     * Returns the number of days of a Jewish month for a given month and year.\r\n     *\r\n     * @param month\r\n     *            the Jewish month\r\n     * @param year\r\n     *            the Jewish Year\r\n     * @return the number of days for a given Jewish month\r\n     */\r\n    static getDaysInJewishMonth(month, year) {\r\n        const shortMonths = [\r\n            JewishDate.IYAR,\r\n            JewishDate.TAMMUZ,\r\n            JewishDate.ELUL,\r\n            JewishDate.ADAR_II,\r\n        ];\r\n        if (shortMonths.includes(month)\r\n            || ((month === JewishDate.CHESHVAN) && !(JewishDate.isCheshvanLong(year)))\r\n            || ((month === JewishDate.KISLEV) && JewishDate.isKislevShort(year)) || (month === JewishDate.TEVES)\r\n            || ((month === JewishDate.ADAR) && !(JewishDate.isJewishLeapYear(year)))) {\r\n            return 29;\r\n        }\r\n        return 30;\r\n    }\r\n    /**\r\n     * Returns the number of days of the Jewish month that the calendar is currently set to.\r\n     *\r\n     * @return the number of days for the Jewish month that the calendar is currently set to.\r\n     */\r\n    getDaysInJewishMonth() {\r\n        return JewishDate.getDaysInJewishMonth(this.getJewishMonth(), this.getJewishYear());\r\n    }\r\n    /**\r\n     * Computes the Jewish date from the absolute date. ND+ER\r\n     */\r\n    absDateToJewishDate() {\r\n        // Approximation from below\r\n        this.jewishYear = Math.trunc((this.gregorianAbsDate - JewishDate.JEWISH_EPOCH) / 366);\r\n        // Search forward for year from the approximation\r\n        while (this.gregorianAbsDate >= JewishDate.jewishDateToAbsDate(this.jewishYear + 1, JewishDate.TISHREI, 1)) {\r\n            this.jewishYear++;\r\n        }\r\n        // Search forward for month from either Tishri or Nisan.\r\n        if (this.gregorianAbsDate < JewishDate.jewishDateToAbsDate(this.jewishYear, JewishDate.NISSAN, 1)) {\r\n            this.jewishMonth = JewishDate.TISHREI; // Start at Tishri\r\n        }\r\n        else {\r\n            this.jewishMonth = JewishDate.NISSAN; // Start at Nisan\r\n        }\r\n        while (this.gregorianAbsDate > JewishDate.jewishDateToAbsDate(this.jewishYear, this.jewishMonth, this.getDaysInJewishMonth())) {\r\n            this.jewishMonth++;\r\n        }\r\n        // Calculate the day by subtraction\r\n        this.jewishDay = this.gregorianAbsDate - JewishDate.jewishDateToAbsDate(this.jewishYear, this.jewishMonth, 1) + 1;\r\n    }\r\n    /**\r\n     * Returns the absolute date of Jewish date. ND+ER\r\n     *\r\n     * @param year\r\n     *            the Jewish year. The year can't be negative\r\n     * @param month\r\n     *            the Jewish month starting with Nisan. Nisan expects a value of 1 etc till Adar with a value of 12. For\r\n     *            a leap year, 13 will be the expected value for Adar II. Use the constants {@link JewishDate#NISSAN}\r\n     *            etc.\r\n     * @param dayOfMonth\r\n     *            the Jewish day of month. valid values are 1-30. If the day of month is set to 30 for a month that only\r\n     *            has 29 days, the day will be set as 29.\r\n     * @return the absolute date of the Jewish date.\r\n     */\r\n    static jewishDateToAbsDate(year, month, dayOfMonth) {\r\n        const elapsed = JewishDate.getDaysSinceStartOfJewishYear(year, month, dayOfMonth);\r\n        // add elapsed days this year + Days in prior years + Days elapsed before absolute year 1\r\n        return elapsed + JewishDate.getJewishCalendarElapsedDays(year) + JewishDate.JEWISH_EPOCH;\r\n    }\r\n    /**\r\n     * Returns the molad for a given year and month. Returns a JewishDate {@link Object} set to the date of the molad\r\n     * with the {@link #getMoladHours() hours}, {@link #getMoladMinutes() minutes} and {@link #getMoladChalakim()\r\n       * chalakim} set. In the current implementation, it sets the molad time based on a midnight date rollover. This\r\n     * means that Rosh Chodesh Adar II, 5771 with a molad of 7 chalakim past midnight on Shabbos 29 Adar I / March 5,\r\n     * 2011 12:00 AM and 7 chalakim, will have the following values: hours: 0, minutes: 0, Chalakim: 7.\r\n     *\r\n     * @return a JewishDate {@link Object} set to the date of the molad with the {@link #getMoladHours() hours},\r\n     *         {@link #getMoladMinutes() minutes} and {@link #getMoladChalakim() chalakim} set.\r\n     */\r\n    getMolad() {\r\n        const moladDate = new JewishDate(this.getChalakimSinceMoladTohu());\r\n        if (moladDate.getMoladHours() >= 6) {\r\n            moladDate.forward(Calendar.DATE, 1);\r\n        }\r\n        moladDate.setMoladHours((moladDate.getMoladHours() + 18) % 24);\r\n        return moladDate;\r\n    }\r\n    /**\r\n     * Returns the number of days from the Jewish epoch from the number of chalakim from the epoch passed in.\r\n     *\r\n     * @param chalakim\r\n     *            the number of chalakim since the beginning of Sunday prior to BaHaRaD\r\n     * @return the number of days from the Jewish epoch\r\n     */\r\n    static moladToAbsDate(chalakim) {\r\n        return Math.trunc(chalakim / JewishDate.CHALAKIM_PER_DAY) + JewishDate.JEWISH_EPOCH;\r\n    }\r\n    /**\r\n     * Constructor that creates a JewishDate based on a molad passed in. The molad would be the number of chalakim/parts\r\n     * starting at the beginning of Sunday prior to the molad Tohu BeHaRaD (Be = Monday, Ha= 5 hours and Rad =204\r\n     * chalakim/parts) - prior to the start of the Jewish calendar. BeHaRaD is 23:11:20 on Sunday night(5 hours 204/1080\r\n     * chalakim after sunset on Sunday evening).\r\n     *\r\n     * @param molad the number of chalakim since the beginning of Sunday prior to BaHaRaD\r\n     */\r\n    /*\r\n        public JewishDate(molad: number) {\r\n            this.absDateToDate(JewishDate.moladToAbsDate(molad));\r\n            // long chalakimSince = getChalakimSinceMoladTohu(year, JewishDate.TISHREI);// tishrei\r\n            const conjunctionDay: number = Math.trunc(molad / JewishDate.CHALAKIM_PER_DAY);\r\n            const conjunctionParts: number = Math.trunc(molad - conjunctionDay * JewishDate.CHALAKIM_PER_DAY);\r\n            this.setMoladTime(conjunctionParts);\r\n        }\r\n    */\r\n    /**\r\n     * Sets the molad time (hours minutes and chalakim) based on the number of chalakim since the start of the day.\r\n     *\r\n     * @param chalakim\r\n     *            the number of chalakim since the start of the day.\r\n     */\r\n    setMoladTime(chalakim) {\r\n        let adjustedChalakim = chalakim;\r\n        this.setMoladHours(Math.trunc(adjustedChalakim / JewishDate.CHALAKIM_PER_HOUR));\r\n        adjustedChalakim = adjustedChalakim - (this.getMoladHours() * JewishDate.CHALAKIM_PER_HOUR);\r\n        this.setMoladMinutes(Math.trunc(adjustedChalakim / JewishDate.CHALAKIM_PER_MINUTE));\r\n        this.setMoladChalakim(adjustedChalakim - this.moladMinutes * JewishDate.CHALAKIM_PER_MINUTE);\r\n    }\r\n    /**\r\n     * returns the number of days from Rosh Hashana of the date passed in, to the full date passed in.\r\n     *\r\n     * @return the number of days\r\n     */\r\n    getDaysSinceStartOfJewishYear() {\r\n        return JewishDate.getDaysSinceStartOfJewishYear(this.getJewishYear(), this.getJewishMonth(), this.getJewishDayOfMonth());\r\n    }\r\n    /**\r\n     * returns the number of days from Rosh Hashana of the date passed in, to the full date passed in.\r\n     *\r\n     * @param year\r\n     *            the Jewish year\r\n     * @param month\r\n     *            the Jewish month\r\n     * @param dayOfMonth\r\n     *            the day in the Jewish month\r\n     * @return the number of days\r\n     */\r\n    static getDaysSinceStartOfJewishYear(year, month, dayOfMonth) {\r\n        let elapsedDays = dayOfMonth;\r\n        // Before Tishrei (from Nissan to Tishrei), add days in prior months\r\n        if (month < JewishDate.TISHREI) {\r\n            // this year before and after Nisan.\r\n            for (let m = JewishDate.TISHREI; m <= JewishDate.getLastMonthOfJewishYear(year); m++) {\r\n                elapsedDays += JewishDate.getDaysInJewishMonth(m, year);\r\n            }\r\n            for (let m = JewishDate.NISSAN; m < month; m++) {\r\n                elapsedDays += JewishDate.getDaysInJewishMonth(m, year);\r\n            }\r\n        }\r\n        else { // Add days in prior months this year\r\n            for (let m = JewishDate.TISHREI; m < month; m++) {\r\n                elapsedDays += JewishDate.getDaysInJewishMonth(m, year);\r\n            }\r\n        }\r\n        return elapsedDays;\r\n    }\r\n    /**\r\n     * Creates a Jewish date based on a Jewish year, month and day of month.\r\n     *\r\n     * @param jewishYear\r\n     *            the Jewish year\r\n     * @param jewishMonth\r\n     *            the Jewish month. The method expects a 1 for Nissan ... 12 for Adar and 13 for Adar II. Use the\r\n     *            constants {@link #NISSAN} ... {@link #ADAR} (or {@link #ADAR_II} for a leap year Adar II) to avoid any\r\n     *            confusion.\r\n     * @param jewishDayOfMonth\r\n     *            the Jewish day of month. If 30 is passed in for a month with only 29 days (for example {@link #IYAR},\r\n     *            or {@link #KISLEV} in a year that {@link #isKislevShort()}), the 29th (last valid date of the month)\r\n     *            will be set\r\n     * @throws IllegalArgumentException\r\n     *             if the day of month is &lt; 1 or &gt; 30, or a year of &lt; 0 is passed in.\r\n     */\r\n    /*\r\n        public JewishDate(jewishYear: number, jewishMonth: number, jewishDayOfMonth: number) {\r\n            this.setJewishDate(jewishYear, jewishMonth, jewishDayOfMonth);\r\n        }\r\n    */\r\n    /**\r\n     * Default constructor will set a default date to the current system date.\r\n     */\r\n    /*\r\n        public JewishDate() {\r\n            this.resetDate();\r\n        }\r\n    */\r\n    /**\r\n     * A constructor that initializes the date to the {@link java.util.Date Date} paremeter.\r\n     *\r\n     * @param date\r\n     *            the <code>Date</code> to set the calendar to\r\n     * @throws IllegalArgumentException\r\n     *             if the date would fall prior to the January 1, 1 AD\r\n     */\r\n    /*\r\n        public JewishDate(date: Date) {\r\n            this.setDate(date);\r\n        }\r\n    */\r\n    /**\r\n     * A constructor that initializes the date to the {@link java.util.Calendar Calendar} paremeter.\r\n     *\r\n     * @param calendar\r\n     *            the <code>Calendar</code> to set the calendar to\r\n     * @throws IllegalArgumentException\r\n     *             if the {@link Calendar#ERA} is {@link GregorianCalendar#BC}\r\n     */\r\n    /*\r\n        public JewishDate(calendar: GregorianCalendar) {\r\n            this.setDate(calendar);\r\n        }\r\n    */\r\n    /**\r\n     * Sets the date based on a {@link java.util.Calendar Calendar} object. Modifies the Jewish date as well.\r\n     *\r\n     * @param date\r\n     *            the <code>Calendar</code> to set the calendar to\r\n     * @throws IllegalArgumentException\r\n     *             if the {@link Calendar#ERA} is {@link GregorianCalendar#BC}\r\n     */\r\n    setDate(date) {\r\n        if (date.year < 1) {\r\n            throw new IllegalArgumentException(`Dates with a BC era are not supported. The year ${date.year} is invalid.`);\r\n        }\r\n        this.gregorianMonth = date.month;\r\n        this.gregorianDayOfMonth = date.day;\r\n        this.gregorianYear = date.year;\r\n        this.gregorianAbsDate = JewishDate.gregorianDateToAbsDate(this.gregorianYear, this.gregorianMonth, this.gregorianDayOfMonth); // init the date\r\n        this.absDateToJewishDate();\r\n        this.dayOfWeek = Math.abs(this.gregorianAbsDate % 7) + 1; // set day of week\r\n    }\r\n    /**\r\n     * Sets the date based on a {@link java.util.Date Date} object. Modifies the Jewish date as well.\r\n     *\r\n     * @param date\r\n     *            the <code>Date</code> to set the calendar to\r\n     * @throws IllegalArgumentException\r\n     *             if the date would fall prior to the year 1 AD\r\n     */\r\n    /*\r\n        public setDate(date: Date): void {\r\n            const cal: GregorianCalendar = new GregorianCalendar();\r\n            cal.setTime(date);\r\n            this.setDate(cal);\r\n        }\r\n    */\r\n    /**\r\n     * Sets the Gregorian Date, and updates the Jewish date accordingly. Like the Java Calendar A value of 0 is expected\r\n     * for January.\r\n     *\r\n     * @param year\r\n     *            the Gregorian year\r\n     * @param month\r\n     *            the Gregorian month. Like the Java Calendar, this class expects 0 for January\r\n     * @param dayOfMonth\r\n     *            the Gregorian day of month. If this is &gt; the number of days in the month/year, the last valid date of\r\n     *            the month will be set\r\n     * @throws IllegalArgumentException\r\n     *             if a year of &lt; 1, a month &lt; 0 or &gt; 11 or a day of month &lt; 1 is passed in\r\n     */\r\n    setGregorianDate(year, month, dayOfMonth) {\r\n        JewishDate.validateGregorianDate(year, month, dayOfMonth);\r\n        this.setInternalGregorianDate(year, month + 1, dayOfMonth);\r\n    }\r\n    /**\r\n     * Sets the hidden internal representation of the Gregorian date , and updates the Jewish date accordingly. While\r\n     * public getters and setters have 0 based months matching the Java Calendar classes, This class internally\r\n     * represents the Gregorian month starting at 1. When this is called it will not adjust the month to match the Java\r\n     * Calendar classes.\r\n     *\r\n     * @param year - the year\r\n     * @param month - the month\r\n     * @param dayOfMonth - the day of month\r\n     */\r\n    setInternalGregorianDate(year, month, dayOfMonth) {\r\n        // make sure date is a valid date for the given month, if not, set to last day of month\r\n        if (dayOfMonth > JewishDate.getLastDayOfGregorianMonth(month, year)) {\r\n            dayOfMonth = JewishDate.getLastDayOfGregorianMonth(month, year);\r\n        }\r\n        // init month, date, year\r\n        this.gregorianMonth = month;\r\n        this.gregorianDayOfMonth = dayOfMonth;\r\n        this.gregorianYear = year;\r\n        this.gregorianAbsDate = JewishDate.gregorianDateToAbsDate(this.gregorianYear, this.gregorianMonth, this.gregorianDayOfMonth); // init date\r\n        this.absDateToJewishDate();\r\n        this.dayOfWeek = Math.abs(this.gregorianAbsDate % 7) + 1; // set day of week\r\n    }\r\n    setJewishDate(year, month, dayOfMonth, hours = 0, minutes = 0, chalakim = 0) {\r\n        JewishDate.validateJewishDate(year, month, dayOfMonth, hours, minutes, chalakim);\r\n        // if 30 is passed for a month that only has 29 days (for example by rolling the month from a month that had 30\r\n        // days to a month that only has 29) set the date to 29th\r\n        if (dayOfMonth > JewishDate.getDaysInJewishMonth(month, year)) {\r\n            dayOfMonth = JewishDate.getDaysInJewishMonth(month, year);\r\n        }\r\n        this.jewishMonth = month;\r\n        this.jewishDay = dayOfMonth;\r\n        this.jewishYear = year;\r\n        this.moladHours = hours;\r\n        this.moladMinutes = minutes;\r\n        this.moladChalakim = chalakim;\r\n        this.gregorianAbsDate = JewishDate.jewishDateToAbsDate(this.jewishYear, this.jewishMonth, this.jewishDay); // reset Gregorian date\r\n        this.absDateToDate(this.gregorianAbsDate);\r\n        this.dayOfWeek = Math.abs(this.gregorianAbsDate % 7) + 1; // reset day of week\r\n    }\r\n    /**\r\n     * Returns this object's date as a {@link java.util.Calendar} object.\r\n     *\r\n     * @return The {@link java.util.Calendar}\r\n     */\r\n    getDate() {\r\n        return DateTime.fromObject({\r\n            year: this.gregorianYear,\r\n            month: this.gregorianMonth,\r\n            day: this.gregorianDayOfMonth,\r\n        });\r\n    }\r\n    /**\r\n     * Resets this date to the current system date.\r\n     */\r\n    resetDate() {\r\n        this.setDate(DateTime.local());\r\n    }\r\n    /**\r\n     * Returns a string containing the Jewish date in the form, \"day Month, year\" e.g. \"21 Shevat, 5729\". For more\r\n     * complex formatting, use the formatter classes.\r\n     *\r\n     * This functionality is duplicated from {@link HebrewDateFormatter} to avoid circular dependencies.\r\n     *\r\n     * @return the Jewish date in the form \"day Month, year\" e.g. \"21 Shevat, 5729\"\r\n     * @see HebrewDateFormatter#format(JewishDate)\r\n     */\r\n    toString() {\r\n        const transliteratedMonths = ['Nissan', 'Iyar', 'Sivan', 'Tammuz', 'Av', 'Elul', 'Tishrei', 'Cheshvan',\r\n            'Kislev', 'Teves', 'Shevat', 'Adar', 'Adar II', 'Adar I'];\r\n        let formattedMonth;\r\n        if (this.isJewishLeapYear() && this.jewishMonth === JewishDate.ADAR) {\r\n            formattedMonth = transliteratedMonths[13]; // return Adar I, not Adar in a leap year\r\n        }\r\n        else {\r\n            formattedMonth = transliteratedMonths[this.jewishMonth - 1];\r\n        }\r\n        return `${this.getJewishDayOfMonth()} ${formattedMonth}, ${this.getJewishYear()}`;\r\n    }\r\n    /**\r\n     * Rolls the date, month or year forward by the amount passed in. It modifies both the Gregorian and Jewish dates\r\n     * accordingly. If manipulation beyond the fields supported here is required, use the {@link Calendar} class\r\n     * {@link Calendar#add(int, int)} or {@link Calendar#roll(int, int)} methods in the following manner.\r\n     *\r\n     * <pre>\r\n     * <code>\r\n     *     Calendar cal = jewishDate.getTime(); // get a java.util.Calendar representation of the JewishDate\r\n     *     cal.add(Calendar.MONTH, 3); // add 3 Gregorian months\r\n     *     jewishDate.setDate(cal); // set the updated calendar back to this class\r\n     * </code>\r\n     * </pre>\r\n     *\r\n     * @param field the calendar field to be forwarded. The must be {@link Calendar#DATE}, {@link Calendar#MONTH} or {@link Calendar#YEAR}\r\n     * @param amount the positive amount to move forward\r\n     * @throws IllegalArgumentException if the field is anything besides {@link Calendar#DATE}, {@link Calendar#MONTH}\r\n     * or {@link Calendar#YEAR} or if the amount is less than 1\r\n     *\r\n     * @see #back()\r\n     * @see Calendar#add(int, int)\r\n     * @see Calendar#roll(int, int)\r\n     */\r\n    forward(field, amount) {\r\n        if (field !== Calendar.DATE && field !== Calendar.MONTH && field !== Calendar.YEAR) {\r\n            throw new IllegalArgumentException('Unsupported field was passed to Forward. Only Calendar.DATE, Calendar.MONTH or Calendar.YEAR are supported.');\r\n        }\r\n        if (amount < 1) {\r\n            throw new IllegalArgumentException('JewishDate.forward() does not support amounts less than 1. See JewishDate.back()');\r\n        }\r\n        if (field === Calendar.DATE) {\r\n            // Change Gregorian date\r\n            for (let i = 0; i < amount; i++) {\r\n                if (this.gregorianDayOfMonth === JewishDate.getLastDayOfGregorianMonth(this.gregorianMonth, this.gregorianYear)) {\r\n                    this.gregorianDayOfMonth = 1;\r\n                    // if last day of year\r\n                    if (this.gregorianMonth === 12) {\r\n                        this.gregorianYear++;\r\n                    }\r\n                    else {\r\n                        this.gregorianMonth++;\r\n                    }\r\n                }\r\n                else {\r\n                    // if not last day of month\r\n                    this.gregorianDayOfMonth++;\r\n                }\r\n                // Change the Jewish Date\r\n                if (this.jewishDay === this.getDaysInJewishMonth()) {\r\n                    // if it last day of elul (i.e. last day of Jewish year)\r\n                    if (this.jewishMonth === JewishDate.ELUL) {\r\n                        this.jewishYear++;\r\n                        this.jewishMonth++;\r\n                        this.jewishDay = 1;\r\n                    }\r\n                    else if (this.jewishMonth === JewishDate.getLastMonthOfJewishYear(this.jewishYear)) {\r\n                        // if it is the last day of Adar, or Adar II as case may be\r\n                        this.jewishMonth = JewishDate.NISSAN;\r\n                        this.jewishDay = 1;\r\n                    }\r\n                    else {\r\n                        this.jewishMonth++;\r\n                        this.jewishDay = 1;\r\n                    }\r\n                }\r\n                else {\r\n                    // if not last date of month\r\n                    this.jewishDay++;\r\n                }\r\n                if (this.dayOfWeek === 7) {\r\n                    // if last day of week, loop back to Sunday\r\n                    this.dayOfWeek = 1;\r\n                }\r\n                else {\r\n                    this.dayOfWeek++;\r\n                }\r\n                // increment the absolute date\r\n                this.gregorianAbsDate++;\r\n            }\r\n        }\r\n        else if (field === Calendar.MONTH) {\r\n            this.forwardJewishMonth(amount);\r\n        }\r\n        else if (field === Calendar.YEAR) {\r\n            this.setJewishYear(this.getJewishYear() + amount);\r\n        }\r\n    }\r\n    /**\r\n     * Forward the Jewish date by the number of months passed in.\r\n     * FIXME: Deal with forwarding a date such as 30 Nisan by a month. 30 Iyar does not exist. This should be dealt with similar to\r\n     * the way that the Java Calendar behaves (not that simple since there is a difference between add() or roll().\r\n     *\r\n     * @throws IllegalArgumentException if the amount is less than 1\r\n     * @param amount the number of months to roll the month forward\r\n     */\r\n    forwardJewishMonth(amount) {\r\n        if (amount < 1) {\r\n            throw new IllegalArgumentException('the amount of months to forward has to be greater than zero.');\r\n        }\r\n        for (let i = 0; i < amount; i++) {\r\n            if (this.getJewishMonth() === JewishDate.ELUL) {\r\n                this.setJewishMonth(JewishDate.TISHREI);\r\n                this.setJewishYear(this.getJewishYear() + 1);\r\n            }\r\n            else if ((!this.isJewishLeapYear() && this.getJewishMonth() === JewishDate.ADAR)\r\n                || (this.isJewishLeapYear() && this.getJewishMonth() === JewishDate.ADAR_II)) {\r\n                this.setJewishMonth(JewishDate.NISSAN);\r\n            }\r\n            else {\r\n                this.setJewishMonth(this.getJewishMonth() + 1);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Rolls the date back by 1 day. It modifies both the Gregorian and Jewish dates accordingly. The API does not\r\n     * currently offer the ability to forward more than one day t a time, or to forward by month or year. If such\r\n     * manipulation is required use the {@link Calendar} class {@link Calendar#add(int, int)} or\r\n     * {@link Calendar#roll(int, int)} methods in the following manner.\r\n     *\r\n     * <pre>\r\n     * <code>\r\n     *     Calendar cal = jewishDate.getTime(); // get a java.util.Calendar representation of the JewishDate\r\n     *     cal.add(Calendar.MONTH, -3); // subtract 3 Gregorian months\r\n     *     jewishDate.setDate(cal); // set the updated calendar back to this class\r\n     * </code>\r\n     * </pre>\r\n     *\r\n     * @see #back()\r\n     * @see Calendar#add(int, int)\r\n     * @see Calendar#roll(int, int)\r\n     */\r\n    back() {\r\n        // Change Gregorian date\r\n        if (this.gregorianDayOfMonth === 1) { // if first day of month\r\n            if (this.gregorianMonth === 1) { // if first day of year\r\n                this.gregorianMonth = 12;\r\n                this.gregorianYear--;\r\n            }\r\n            else {\r\n                this.gregorianMonth--;\r\n            }\r\n            // change to last day of previous month\r\n            this.gregorianDayOfMonth = JewishDate.getLastDayOfGregorianMonth(this.gregorianMonth, this.gregorianYear);\r\n        }\r\n        else {\r\n            this.gregorianDayOfMonth--;\r\n        }\r\n        // change Jewish date\r\n        if (this.jewishDay === 1) { // if first day of the Jewish month\r\n            if (this.jewishMonth === JewishDate.NISSAN) {\r\n                this.jewishMonth = JewishDate.getLastMonthOfJewishYear(this.jewishYear);\r\n            }\r\n            else if (this.jewishMonth === JewishDate.TISHREI) { // if Rosh Hashana\r\n                this.jewishYear--;\r\n                this.jewishMonth--;\r\n            }\r\n            else {\r\n                this.jewishMonth--;\r\n            }\r\n            this.jewishDay = this.getDaysInJewishMonth();\r\n        }\r\n        else {\r\n            this.jewishDay--;\r\n        }\r\n        if (this.dayOfWeek === 1) { // if first day of week, loop back to Saturday\r\n            this.dayOfWeek = 7;\r\n        }\r\n        else {\r\n            this.dayOfWeek--;\r\n        }\r\n        this.gregorianAbsDate--; // change the absolute date\r\n    }\r\n    /**\r\n     * @see Object#equals(Object)\r\n     */\r\n    equals(object) {\r\n        if (this === object) {\r\n            return true;\r\n        }\r\n        if (!(object instanceof JewishDate)) {\r\n            return false;\r\n        }\r\n        const jewishDate = object;\r\n        return this.gregorianAbsDate === jewishDate.getAbsDate();\r\n    }\r\n    /**\r\n     * Compares two dates as per the compareTo() method in the Comparable interface. Returns a value less than 0 if this\r\n     * date is \"less than\" (before) the date, greater than 0 if this date is \"greater than\" (after) the date, or 0 if\r\n     * they are equal.\r\n     */\r\n    compareTo(jewishDate) {\r\n        return IntegerUtils.compare(this.gregorianAbsDate, jewishDate.getAbsDate());\r\n    }\r\n    /**\r\n     * Returns the Gregorian month (between 0-11).\r\n     *\r\n     * @return the Gregorian month (between 0-11). Like the java.util.Calendar, months are 0 based.\r\n     */\r\n    getGregorianMonth() {\r\n        return this.gregorianMonth - 1;\r\n    }\r\n    /**\r\n     * Returns the Gregorian day of the month.\r\n     *\r\n     * @return the Gregorian day of the mont\r\n     */\r\n    getGregorianDayOfMonth() {\r\n        return this.gregorianDayOfMonth;\r\n    }\r\n    /**\r\n     * Returns the Gregotian year.\r\n     *\r\n     * @return the Gregorian year\r\n     */\r\n    getGregorianYear() {\r\n        return this.gregorianYear;\r\n    }\r\n    /**\r\n     * Returns the Jewish month 1-12 (or 13 years in a leap year). The month count starts with 1 for Nisan and goes to\r\n     * 13 for Adar II\r\n     *\r\n     * @return the Jewish month from 1 to 12 (or 13 years in a leap year). The month count starts with 1 for Nisan and\r\n     *         goes to 13 for Adar II\r\n     */\r\n    getJewishMonth() {\r\n        return this.jewishMonth;\r\n    }\r\n    /**\r\n     * Returns the Jewish day of month.\r\n     *\r\n     * @return the Jewish day of the month\r\n     */\r\n    getJewishDayOfMonth() {\r\n        return this.jewishDay;\r\n    }\r\n    /**\r\n     * Returns the Jewish year.\r\n     *\r\n     * @return the Jewish year\r\n     */\r\n    getJewishYear() {\r\n        return this.jewishYear;\r\n    }\r\n    /**\r\n     * Returns the day of the week as a number between 1-7.\r\n     *\r\n     * @return the day of the week as a number between 1-7.\r\n     */\r\n    getDayOfWeek() {\r\n        return this.dayOfWeek;\r\n    }\r\n    /**\r\n     * Sets the Gregorian month.\r\n     *\r\n     * @param month\r\n     *            the Gregorian month\r\n     *\r\n     * @throws IllegalArgumentException\r\n     *             if a month &lt; 0 or &gt; 11 is passed in\r\n     */\r\n    setGregorianMonth(month) {\r\n        JewishDate.validateGregorianMonth(month);\r\n        this.setInternalGregorianDate(this.gregorianYear, month + 1, this.gregorianDayOfMonth);\r\n    }\r\n    /**\r\n     * sets the Gregorian year.\r\n     *\r\n     * @param year\r\n     *            the Gregorian year.\r\n     * @throws IllegalArgumentException\r\n     *             if a year of &lt; 1 is passed in\r\n     */\r\n    setGregorianYear(year) {\r\n        JewishDate.validateGregorianYear(year);\r\n        this.setInternalGregorianDate(year, this.gregorianMonth, this.gregorianDayOfMonth);\r\n    }\r\n    /**\r\n     * sets the Gregorian Day of month.\r\n     *\r\n     * @param dayOfMonth\r\n     *            the Gregorian Day of month.\r\n     * @throws IllegalArgumentException\r\n     *             if the day of month of &lt; 1 is passed in\r\n     */\r\n    setGregorianDayOfMonth(dayOfMonth) {\r\n        JewishDate.validateGregorianDayOfMonth(dayOfMonth);\r\n        this.setInternalGregorianDate(this.gregorianYear, this.gregorianMonth, dayOfMonth);\r\n    }\r\n    /**\r\n     * sets the Jewish month.\r\n     *\r\n     * @param month\r\n     *            the Jewish month from 1 to 12 (or 13 years in a leap year). The month count starts with 1 for Nisan\r\n     *            and goes to 13 for Adar II\r\n     * @throws IllegalArgumentException\r\n     *             if a month &lt; 1 or &gt; 12 (or 13 on a leap year) is passed in\r\n     */\r\n    setJewishMonth(month) {\r\n        this.setJewishDate(this.jewishYear, month, this.jewishDay);\r\n    }\r\n    /**\r\n     * sets the Jewish year.\r\n     *\r\n     * @param year\r\n     *            the Jewish year\r\n     * @throws IllegalArgumentException\r\n     *             if a year of &lt; 3761 is passed in. The same will happen if the year is 3761 and the month and day\r\n     *             previously set are &lt; 18 Teves (preior to Jan 1, 1 AD)\r\n     */\r\n    setJewishYear(year) {\r\n        this.setJewishDate(year, this.jewishMonth, this.jewishDay);\r\n    }\r\n    /**\r\n     * sets the Jewish day of month.\r\n     *\r\n     * @param dayOfMonth\r\n     *            the Jewish day of month\r\n     * @throws IllegalArgumentException\r\n     *             if the day of month is &lt; 1 or &gt; 30 is passed in\r\n     */\r\n    setJewishDayOfMonth(dayOfMonth) {\r\n        this.setJewishDate(this.jewishYear, this.jewishMonth, dayOfMonth);\r\n    }\r\n    /**\r\n     * A method that creates a <a href=\"http://en.wikipedia.org/wiki/Object_copy#Deep_copy\">deep copy</a> of the object.\r\n     *\r\n     * @see Object#clone()\r\n     */\r\n    clone() {\r\n        const clone = new JewishDate(this.jewishYear, this.jewishMonth, this.jewishDay);\r\n        clone.setMoladHours(this.moladHours);\r\n        clone.setMoladMinutes(this.moladMinutes);\r\n        clone.setMoladChalakim(this.moladChalakim);\r\n        return clone;\r\n    }\r\n}\r\n/**\r\n * Value of the month field indicating Nissan, the first numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 7th (or 8th in a {@link #isJewishLeapYear() leap\r\n   * year}) month of the year.\r\n */\r\nJewishDate.NISSAN = 1;\r\n/**\r\n * Value of the month field indicating Iyar, the second numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 8th (or 9th in a {@link #isJewishLeapYear() leap\r\n   * year}) month of the year.\r\n */\r\nJewishDate.IYAR = 2;\r\n/**\r\n * Value of the month field indicating Sivan, the third numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 9th (or 10th in a {@link #isJewishLeapYear() leap\r\n   * year}) month of the year.\r\n */\r\nJewishDate.SIVAN = 3;\r\n/**\r\n * Value of the month field indicating Tammuz, the fourth numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 10th (or 11th in a {@link #isJewishLeapYear() leap\r\n   * year}) month of the year.\r\n */\r\nJewishDate.TAMMUZ = 4;\r\n/**\r\n * Value of the month field indicating Av, the fifth numeric month of the year in the Jewish calendar. With the year\r\n * starting at {@link #TISHREI}, it would actually be the 11th (or 12th in a {@link #isJewishLeapYear() leap year})\r\n * month of the year.\r\n */\r\nJewishDate.AV = 5;\r\n/**\r\n * Value of the month field indicating Elul, the sixth numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 12th (or 13th in a {@link #isJewishLeapYear() leap\r\n   * year}) month of the year.\r\n */\r\nJewishDate.ELUL = 6;\r\n/**\r\n * Value of the month field indicating Tishrei, the seventh numeric month of the year in the Jewish calendar. With\r\n * the year starting at this month, it would actually be the 1st month of the year.\r\n */\r\nJewishDate.TISHREI = 7;\r\n/**\r\n * Value of the month field indicating Cheshvan/marcheshvan, the eighth numeric month of the year in the Jewish\r\n * calendar. With the year starting at {@link #TISHREI}, it would actually be the 2nd month of the year.\r\n */\r\nJewishDate.CHESHVAN = 8;\r\n/**\r\n * Value of the month field indicating Kislev, the ninth numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 3rd month of the year.\r\n */\r\nJewishDate.KISLEV = 9;\r\n/**\r\n * Value of the month field indicating Teves, the tenth numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 4th month of the year.\r\n */\r\nJewishDate.TEVES = 10;\r\n/**\r\n * Value of the month field indicating Shevat, the eleventh numeric month of the year in the Jewish calendar. With\r\n * the year starting at {@link #TISHREI}, it would actually be the 5th month of the year.\r\n */\r\nJewishDate.SHEVAT = 11;\r\n/**\r\n * Value of the month field indicating Adar (or Adar I in a {@link #isJewishLeapYear() leap year}), the twelfth\r\n * numeric month of the year in the Jewish calendar. With the year starting at {@link #TISHREI}, it would actually\r\n * be the 6th month of the year.\r\n */\r\nJewishDate.ADAR = 12;\r\n/**\r\n * Value of the month field indicating Adar II, the leap (intercalary or embolismic) thirteenth (Undecimber) numeric\r\n * month of the year added in Jewish {@link #isJewishLeapYear() leap year}). The leap years are years 3, 6, 8, 11,\r\n * 14, 17 and 19 of a 19 year cycle. With the year starting at {@link #TISHREI}, it would actually be the 7th month\r\n * of the year.\r\n */\r\nJewishDate.ADAR_II = 13;\r\n/**\r\n * the Jewish epoch using the RD (Rata Die/Fixed Date or Reingold Dershowitz) day used in Calendrical Calculations.\r\n * Day 1 is January 1, 0001 Gregorian\r\n */\r\nJewishDate.JEWISH_EPOCH = -1373429;\r\nJewishDate.CHALAKIM_PER_MINUTE = 18;\r\nJewishDate.CHALAKIM_PER_HOUR = 1080;\r\nJewishDate.CHALAKIM_PER_DAY = 25920; // 24 * 1080\r\nJewishDate.CHALAKIM_PER_MONTH = 765433; // (29 * 24 + 12) * 1080 + 793\r\n/**\r\n * Days from the beginning of Sunday till molad BaHaRaD. Calculated as 1 day, 5 hours and 204 chalakim = (24 + 5) *\r\n * 1080 + 204 = 31524\r\n */\r\nJewishDate.CHALAKIM_MOLAD_TOHU = 31524;\r\n/**\r\n * A short year where both {@link #CHESHVAN} and {@link #KISLEV} are 29 days.\r\n *\r\n * @see #getCheshvanKislevKviah()\r\n * @see HebrewDateFormatter#getFormattedKviah(int)\r\n */\r\nJewishDate.CHASERIM = 0;\r\n/**\r\n * An ordered year where {@link #CHESHVAN} is 29 days and {@link #KISLEV} is 30 days.\r\n *\r\n * @see #getCheshvanKislevKviah()\r\n * @see HebrewDateFormatter#getFormattedKviah(int)\r\n */\r\nJewishDate.KESIDRAN = 1;\r\n/**\r\n * A long year where both {@link #CHESHVAN} and {@link #KISLEV} are 30 days.\r\n *\r\n * @see #getCheshvanKislevKviah()\r\n * @see HebrewDateFormatter#getFormattedKviah(int)\r\n */\r\nJewishDate.SHELAIMIM = 2;\r\n//# sourceMappingURL=JewishDate.js.map"]},"metadata":{},"sourceType":"module"}