{"ast":null,"code":"import _classCallCheck from \"C:\\\\react\\\\my-app\\\\frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\react\\\\my-app\\\\frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { DateTime } from 'luxon';\nimport * as numeral from 'numeral';\nimport { TimeZone, Utils } from '../polyfills/Utils';\nimport { Time } from './Time';\nimport { AstronomicalCalendar } from '../AstronomicalCalendar';\nimport { ZmanimCalendar } from '../ZmanimCalendar';\nimport { ComplexZmanimCalendar } from '../ComplexZmanimCalendar';\nimport { Zman } from './Zman';\nimport { UnsupportedError } from '../polyfills/errors';\nvar methodNamesToExclude = ['getAdjustedDate', 'getDate', 'getElevationAdjustedSunrise', 'getElevationAdjustedSunset', 'getMidnightLastNight', 'getMidnightTonight', 'getSunriseBaalHatanya', 'getSunsetBaalHatanya'];\n/**\r\n * A class used to format both non {@link java.util.Date} times generated by the Zmanim package as well as Dates. For\r\n * example the {@link net.sourceforge.zmanim.AstronomicalCalendar#getTemporalHour()} returns the length of the hour in\r\n * milliseconds. This class can format this time.\r\n *\r\n * @author &copy; Eliyahu Hershfeld 2004 - 2019\r\n * @version 1.2\r\n */\n\nexport var ZmanimFormatter = /*#__PURE__*/function () {\n  function ZmanimFormatter(formatOrTimeZone, dateFormat, timeZoneId) {\n    _classCallCheck(this, ZmanimFormatter);\n\n    this.prependZeroHours = false;\n    this.useSeconds = false;\n    this.useMillis = false;\n    this.timeFormat = ZmanimFormatter.SEXAGESIMAL_XSD_FORMAT;\n    var format;\n\n    if (dateFormat) {\n      format = formatOrTimeZone;\n    } else {\n      format = 0;\n      dateFormat = 'h:mm:ss';\n      timeZoneId = formatOrTimeZone;\n    }\n\n    this.setTimeZone(timeZoneId);\n\n    if (this.prependZeroHours) {\n      this.hourNF = '00';\n    }\n\n    this.setTimeFormat(format);\n    this.setDateFormat(dateFormat);\n  }\n  /**\r\n   * @return the timeZone\r\n   */\n\n\n  _createClass(ZmanimFormatter, [{\n    key: \"getTimeZone\",\n    value: function getTimeZone() {\n      return this.timeZoneId;\n    }\n    /**\r\n     * @param timeZoneId\r\n     *            the timeZone to set\r\n     */\n\n  }, {\n    key: \"setTimeZone\",\n    value: function setTimeZone(timeZoneId) {\n      this.timeZoneId = timeZoneId;\n    }\n    /**\r\n     * Sets the format to use for formatting.\r\n     *\r\n     * @param format\r\n     *            int the format constant to use.\r\n     */\n\n  }, {\n    key: \"setTimeFormat\",\n    value: function setTimeFormat(format) {\n      this.timeFormat = format;\n\n      switch (format) {\n        case ZmanimFormatter.SEXAGESIMAL_XSD_FORMAT:\n          this.setSettings(true, true, true);\n          break;\n\n        case ZmanimFormatter.SEXAGESIMAL_FORMAT:\n          this.setSettings(false, false, false);\n          break;\n\n        case ZmanimFormatter.SEXAGESIMAL_SECONDS_FORMAT:\n          this.setSettings(false, true, false);\n          break;\n\n        case ZmanimFormatter.SEXAGESIMAL_MILLIS_FORMAT:\n          this.setSettings(false, true, true);\n          break;\n        // case DECIMAL_FORMAT:\n        // default:\n      }\n    }\n    /**\r\n     * Sets the SimpleDateFormat Object\r\n     * @param dateFormat the SimpleDateFormat Object to set\r\n     */\n\n  }, {\n    key: \"setDateFormat\",\n    value: function setDateFormat(dateFormat) {\n      this.dateFormat = dateFormat;\n    }\n    /**\r\n     * returns the SimpleDateFormat Object\r\n     * @return the SimpleDateFormat Object\r\n     */\n\n  }, {\n    key: \"getDateFormat\",\n    value: function getDateFormat() {\n      return this.dateFormat;\n    }\n  }, {\n    key: \"setSettings\",\n    value: function setSettings(prependZeroHours, useSeconds, useMillis) {\n      this.prependZeroHours = prependZeroHours;\n      this.useSeconds = useSeconds;\n      this.useMillis = useMillis;\n    }\n    /**\r\n     * A method that formats milliseconds into a time format.\r\n     *\r\n     * @param milliseconds\r\n     *            The time in milliseconds.\r\n     * @return String The formatted <code>String</code>\r\n     */\n\n    /*\r\n        public format(milliseconds: number): string {\r\n            return this.format(milliseconds);\r\n        }\r\n    */\n\n    /**\r\n     * A method that formats milliseconds into a time format.\r\n     *\r\n     * @param millis\r\n     *            The time in milliseconds.\r\n     * @return String The formatted <code>String</code>\r\n     */\n\n    /*\r\n        public format(millis: number): string {\r\n            return format(new Time(millis));\r\n        }\r\n    */\n\n    /**\r\n     * A method that formats {@link Time}objects.\r\n     *\r\n     * @param time\r\n     *            The time <code>Object</code> to be formatted.\r\n     * @return String The formatted <code>String</code>\r\n     */\n\n  }, {\n    key: \"format\",\n    value: function format(timeOrMillis) {\n      var time;\n\n      if (timeOrMillis instanceof Time) {\n        time = timeOrMillis;\n      } else {\n        time = new Time(timeOrMillis);\n      }\n\n      if (this.timeFormat === ZmanimFormatter.XSD_DURATION_FORMAT) {\n        return ZmanimFormatter.formatXSDDurationTime(time);\n      }\n\n      var sb = numeral(time.getHours()).format(this.hourNF).concat(':').concat(numeral(time.getMinutes()).format(ZmanimFormatter.minuteSecondNF).toString());\n\n      if (this.useSeconds) {\n        sb = sb.concat(':').concat(numeral(time.getSeconds()).format(ZmanimFormatter.minuteSecondNF).toString());\n      }\n\n      if (this.useMillis) {\n        sb = sb.concat('.').concat(numeral(time.getMilliseconds()).format(ZmanimFormatter.milliNF).toString());\n      }\n\n      return sb;\n    }\n    /**\r\n     * Formats a date using this class's {@link #getDateFormat() date format}.\r\n     *\r\n     * @param dateTime - the date to format\r\n     * @return the formatted String\r\n     */\n\n  }, {\n    key: \"formatDateTime\",\n    value: function formatDateTime(dateTime) {\n      var _dateTime = dateTime.setZone(this.getTimeZone());\n\n      if (this.dateFormat === ZmanimFormatter.XSD_DATE_FORMAT) {\n        return this.getXSDateTime(_dateTime);\n      }\n\n      return _dateTime.toFormat(this.dateFormat);\n    }\n    /**\r\n     * The date:date-time function returns the current date and time as a date/time string. The date/time string that's\r\n     * returned must be a string in the format defined as the lexical representation of xs:dateTime in <a\r\n     * href=\"http://www.w3.org/TR/xmlschema11-2/#dateTime\">[3.3.8 dateTime]</a> of <a\r\n     * href=\"http://www.w3.org/TR/xmlschema11-2/\">[XML Schema 1.1 Part 2: Datatypes]</a>. The date/time format is\r\n     * basically CCYY-MM-DDThh:mm:ss, although implementers should consult <a\r\n     * href=\"http://www.w3.org/TR/xmlschema11-2/\">[XML Schema 1.1 Part 2: Datatypes]</a> and <a\r\n     * href=\"http://www.iso.ch/markete/8601.pdf\">[ISO 8601]</a> for details. The date/time string format must include a\r\n     * time zone, either a Z to indicate Coordinated Universal Time or a + or - followed by the difference between the\r\n     * difference from UTC represented as hh:mm.\r\n     * @param dateTime - the UTC Date Object\r\n     * @return the XSD dateTime\r\n     */\n\n  }, {\n    key: \"getXSDateTime\",\n    value: function getXSDateTime(dateTime) {\n      return dateTime.setZone(this.getTimeZone()).toFormat(ZmanimFormatter.XSD_DATE_FORMAT.concat('ZZ'));\n    }\n    /**\r\n     * Represent the hours and minutes with two-digit strings.\r\n     *\r\n     * @param digits\r\n     *            hours or minutes.\r\n     * @return two-digit String representation of hrs or minutes.\r\n     */\n\n  }], [{\n    key: \"formatDigits\",\n    value: function formatDigits(digits) {\n      var dd = Math.abs(digits).toString();\n      return dd.length === 1 ? \"0\".concat(dd) : dd;\n    }\n    /**\r\n     * This returns the xml representation of an xsd:duration object.\r\n     *\r\n     * @param millis\r\n     *            the duration in milliseconds\r\n     * @return the xsd:duration formatted String\r\n     */\n\n    /*\r\n        public formatXSDDurationTime(millis: number): string {\r\n            return formatXSDDurationTime(new Time(millis));\r\n        }\r\n    */\n\n    /**\r\n     * This returns the xml representation of an xsd:duration object.\r\n     *\r\n     * @param time\r\n     *            the duration as a Time object\r\n     * @return the xsd:duration formatted String\r\n     */\n\n  }, {\n    key: \"formatXSDDurationTime\",\n    value: function formatXSDDurationTime(timeOrMillis) {\n      var time;\n\n      if (timeOrMillis instanceof Time) {\n        time = timeOrMillis;\n      } else {\n        time = new Time(timeOrMillis);\n      }\n\n      var duration;\n\n      if (time.getHours() !== 0 || time.getMinutes() !== 0 || time.getSeconds() !== 0 || time.getMilliseconds() !== 0) {\n        duration = 'P'.concat('T');\n        if (time.getHours() !== 0) duration = duration.concat(\"\".concat(time.getHours(), \"H\"));\n        if (time.getMinutes() !== 0) duration = duration.concat(\"\".concat(time.getMinutes(), \"M\"));\n\n        if (time.getSeconds() !== 0 || time.getMilliseconds() !== 0) {\n          duration = duration.concat(\"\".concat(time.getSeconds(), \".\").concat(numeral(time.getMilliseconds()).format(ZmanimFormatter.milliNF)));\n          duration = duration.concat('S');\n        }\n\n        if (duration.length === 1) duration.concat('T0S'); // zero seconds\n\n        if (time.isNegative()) {\n          duration = duration.substr(0, 0).concat('-').concat(duration.substr(0, duration.length));\n        }\n      }\n\n      return duration.toString();\n    }\n  }, {\n    key: \"formatDecimal\",\n    value: function formatDecimal(num) {\n      return num - Math.trunc(num) > 0 ? num.toString() : numeral(num).format('0.0');\n    }\n    /**\r\n     * A method that returns an XML formatted <code>String</code> representing the serialized <code>Object</code>. The\r\n     * format used is:\r\n     *\r\n     * <pre>\r\n     *  &lt;AstronomicalTimes date=&quot;1969-02-08&quot; type=&quot;net.sourceforge.zmanim.AstronomicalCalendar algorithm=&quot;US Naval Almanac Algorithm&quot; location=&quot;Lakewood, NJ&quot; latitude=&quot;40.095965&quot; longitude=&quot;-74.22213&quot; elevation=&quot;31.0&quot; timeZoneName=&quot;Eastern Standard Time&quot; timeZoneID=&quot;America/New_York&quot; timeZoneOffset=&quot;-5&quot;&gt;\r\n     *     &lt;Sunrise&gt;2007-02-18T06:45:27-05:00&lt;/Sunrise&gt;\r\n     *     &lt;TemporalHour&gt;PT54M17.529S&lt;/TemporalHour&gt;\r\n     *     ...\r\n     *   &lt;/AstronomicalTimes&gt;\r\n     * </pre>\r\n     *\r\n     * Note that the output uses the <a href=\"http://www.w3.org/TR/xmlschema11-2/#dateTime\">xsd:dateTime</a> format for\r\n     * times such as sunrise, and <a href=\"http://www.w3.org/TR/xmlschema11-2/#duration\">xsd:duration</a> format for\r\n     * times that are a duration such as the length of a\r\n     * {@link net.sourceforge.zmanim.AstronomicalCalendar#getTemporalHour() temporal hour}. The output of this method is\r\n     * returned by the {@link #toString() toString}.\r\n     *\r\n     * @param astronomicalCalendar the AstronomicalCalendar Object\r\n     *\r\n     * @return The XML formatted <code>String</code>. The format will be:\r\n     *\r\n     *         <pre>\r\n     *  &lt;AstronomicalTimes date=&quot;1969-02-08&quot; type=&quot;net.sourceforge.zmanim.AstronomicalCalendar algorithm=&quot;US Naval Almanac Algorithm&quot; location=&quot;Lakewood, NJ&quot; latitude=&quot;40.095965&quot; longitude=&quot;-74.22213&quot; elevation=&quot;31.0&quot; timeZoneName=&quot;Eastern Standard Time&quot; timeZoneID=&quot;America/New_York&quot; timeZoneOffset=&quot;-5&quot;&gt;\r\n     *     &lt;Sunrise&gt;2007-02-18T06:45:27-05:00&lt;/Sunrise&gt;\r\n     *     &lt;TemporalHour&gt;PT54M17.529S&lt;/TemporalHour&gt;\r\n     *     ...\r\n     *  &lt;/AstronomicalTimes&gt;\r\n     * </pre>\r\n     *\r\n     *         TODO: add proper schema, and support for nulls. XSD duration (for solar hours), should probably return\r\n     *         nil and not P\r\n     * @deprecated\r\n     */\n\n  }, {\n    key: \"toXML\",\n    value: function toXML() {\n      throw new UnsupportedError('This method is not supported.');\n    }\n    /**\r\n     * A method that returns a JSON formatted <code>String</code> representing the serialized <code>Object</code>. The\r\n     * format used is:\r\n     * <pre>\r\n     * {\r\n     *    &quot;metadata&quot;:{\r\n     *      &quot;date&quot;:&quot;1969-02-08&quot;,\r\n     *      &quot;type&quot;:&quot;net.sourceforge.zmanim.AstronomicalCalendar&quot;,\r\n     *      &quot;algorithm&quot;:&quot;US Naval Almanac Algorithm&quot;,\r\n     *      &quot;location&quot;:&quot;Lakewood, NJ&quot;,\r\n     *      &quot;latitude&quot;:&quot;40.095965&quot;,\r\n     *      &quot;longitude&quot;:&quot;-74.22213&quot;,\r\n     *      &quot;elevation:&quot;31.0&quot;,\r\n     *      &quot;timeZoneName&quot;:&quot;Eastern Standard Time&quot;,\r\n     *      &quot;timeZoneID&quot;:&quot;America/New_York&quot;,\r\n     *      &quot;timeZoneOffset&quot;:&quot;-5&quot;},\r\n     *    &quot;AstronomicalTimes&quot;:{\r\n     *     &quot;Sunrise&quot;:&quot;2007-02-18T06:45:27-05:00&quot;,\r\n     *     &quot;TemporalHour&quot;:&quot;PT54M17.529S&quot;\r\n     *     ...\r\n     *     }\r\n     * }\r\n     * </pre>\r\n     *\r\n     * Note that the output uses the <a href=\"http://www.w3.org/TR/xmlschema11-2/#dateTime\">xsd:dateTime</a> format for\r\n     * times such as sunrise, and <a href=\"http://www.w3.org/TR/xmlschema11-2/#duration\">xsd:duration</a> format for\r\n     * times that are a duration such as the length of a\r\n     * {@link net.sourceforge.zmanim.AstronomicalCalendar#getTemporalHour() temporal hour}.\r\n     *\r\n     * @param astronomicalCalendar the AstronomicalCalendar Object\r\n     *\r\n     * @return The JSON formatted <code>String</code>. The format will be:\r\n     * <pre>\r\n     * {\r\n     *    &quot;metadata&quot;:{\r\n     *      &quot;date&quot;:&quot;1969-02-08&quot;,\r\n     *      &quot;type&quot;:&quot;net.sourceforge.zmanim.AstronomicalCalendar&quot;,\r\n     *      &quot;algorithm&quot;:&quot;US Naval Almanac Algorithm&quot;,\r\n     *      &quot;location&quot;:&quot;Lakewood, NJ&quot;,\r\n     *      &quot;latitude&quot;:&quot;40.095965&quot;,\r\n     *      &quot;longitude&quot;:&quot;-74.22213&quot;,\r\n     *      &quot;elevation:&quot;31.0&quot;,\r\n     *      &quot;timeZoneName&quot;:&quot;Eastern Standard Time&quot;,\r\n     *      &quot;timeZoneID&quot;:&quot;America/New_York&quot;,\r\n     *      &quot;timeZoneOffset&quot;:&quot;-5&quot;},\r\n     *    &quot;AstronomicalTimes&quot;:{\r\n     *     &quot;Sunrise&quot;:&quot;2007-02-18T06:45:27-05:00&quot;,\r\n     *     &quot;TemporalHour&quot;:&quot;PT54M17.529S&quot;\r\n     *     ...\r\n     *     }\r\n     * }\r\n     * </pre>\r\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(astronomicalCalendar) {\n      var json = {\n        metadata: ZmanimFormatter.getOutputMetadata(astronomicalCalendar)\n      };\n      var key = ZmanimFormatter.getOutputKey(astronomicalCalendar);\n      json[key] = ZmanimFormatter.getZmanimOutput(astronomicalCalendar);\n      return json;\n    } // @ts-ignore\n\n  }, {\n    key: \"getOutputKey\",\n    value: function getOutputKey(astronomicalCalendar) {\n      switch (true) {\n        case astronomicalCalendar instanceof ComplexZmanimCalendar:\n          return 'Zmanim';\n\n        case astronomicalCalendar instanceof ZmanimCalendar:\n          return 'BasicZmanim';\n\n        case astronomicalCalendar instanceof AstronomicalCalendar:\n          return 'AstronomicalTimes';\n      }\n    }\n  }, {\n    key: \"getOutputMetadata\",\n    value: function getOutputMetadata(astronomicalCalendar) {\n      var df = 'yyyy-MM-dd';\n      return {\n        date: astronomicalCalendar.getDate().toFormat(df),\n        type: astronomicalCalendar.getClassName(),\n        algorithm: astronomicalCalendar.getAstronomicalCalculator().getCalculatorName(),\n        location: astronomicalCalendar.getGeoLocation().getLocationName(),\n        latitude: astronomicalCalendar.getGeoLocation().getLatitude().toString(),\n        longitude: astronomicalCalendar.getGeoLocation().getLongitude().toString(),\n        elevation: ZmanimFormatter.formatDecimal(astronomicalCalendar.getGeoLocation().getElevation()),\n        timeZoneName: TimeZone.getDisplayName(astronomicalCalendar.getGeoLocation().getTimeZone(), astronomicalCalendar.getDate()),\n        timeZoneID: astronomicalCalendar.getGeoLocation().getTimeZone(),\n        timeZoneOffset: ZmanimFormatter.formatDecimal(TimeZone.getOffset(astronomicalCalendar.getGeoLocation().getTimeZone(), astronomicalCalendar.getDate().valueOf()) / ZmanimFormatter.HOUR_MILLIS)\n      };\n    }\n  }, {\n    key: \"getZmanimOutput\",\n    value: function getZmanimOutput(astronomicalCalendar) {\n      var formatter = new ZmanimFormatter(ZmanimFormatter.XSD_DURATION_FORMAT, ZmanimFormatter.XSD_DATE_FORMAT, astronomicalCalendar.getGeoLocation().getTimeZone());\n      /*\r\n          let dateList: Set<Date> = new Set();\r\n          let durationList: Set<number> = new Set();\r\n      */\n\n      var dateList = [];\n      var durationList = [];\n      var otherList = []; // Get al the methods in the calendar\n\n      Utils.getAllMethodNames(astronomicalCalendar, true) // Filter out methods that we don't want\n      .filter(function (method) {\n        return includeMethod(method, astronomicalCalendar);\n      }) // Call each method and get the return values\n      .map(function (method) {\n        return {\n          methodName: method,\n          value: astronomicalCalendar[method].call(astronomicalCalendar)\n        };\n      }) // Filter for return values of type Date or number\n      .filter(function (methodObj) {\n        return DateTime.isDateTime(methodObj.value) || typeof methodObj.value === 'number' || methodObj.value === null;\n      }) // Separate the Dates and numbers\n      .forEach(function (methodObj) {\n        var tagName = methodObj.methodName.substring(3);\n\n        if (DateTime.isDateTime(methodObj.value)) {\n          // dateList.add(new KosherZmanim.Zman(methodObj.value, tagName));\n          var zman = {\n            zman: methodObj.value,\n            label: tagName\n          };\n          dateList.push(zman);\n        } else if (typeof methodObj.value === 'number') {\n          // durationList.add(new KosherZmanim.Zman(methodObj.value, tagName));\n          var _zman = {\n            duration: methodObj.value,\n            label: tagName\n          };\n          durationList.push(_zman);\n        } else {\n          otherList.push(tagName);\n        }\n      });\n      dateList.sort(Zman.compareDateOrder); // Filter for values in milliseconds, and not values in minutes\n\n      durationList = durationList.filter(function (zman) {\n        return zman.duration > 1000;\n      }).sort(Zman.compareDurationOrder);\n      var timesData = {};\n      dateList.forEach(function (zman) {\n        timesData[zman.label] = formatter.formatDateTime(zman.zman);\n      });\n      durationList.forEach(function (zman) {\n        timesData[zman.label] = formatter.format(Math.trunc(zman.duration));\n      });\n      otherList.forEach(function (tagName) {\n        timesData[tagName] = 'N/A';\n      });\n      return timesData;\n    }\n  }]);\n\n  return ZmanimFormatter;\n}();\nZmanimFormatter.minuteSecondNF = '00';\nZmanimFormatter.milliNF = '000';\n/**\r\n * Format using hours, minutes, seconds and milliseconds using the xsd:time format. This format will return\r\n * 00.00.00.0 when formatting 0.\r\n */\n\nZmanimFormatter.SEXAGESIMAL_XSD_FORMAT = 0;\n/**\r\n * Format using standard decimal format with 5 positions after the decimal.\r\n */\n\nZmanimFormatter.DECIMAL_FORMAT = 1;\n/** Format using hours and minutes. */\n\nZmanimFormatter.SEXAGESIMAL_FORMAT = 2;\n/** Format using hours, minutes and seconds. */\n\nZmanimFormatter.SEXAGESIMAL_SECONDS_FORMAT = 3;\n/** Format using hours, minutes, seconds and milliseconds. */\n\nZmanimFormatter.SEXAGESIMAL_MILLIS_FORMAT = 4;\n/** constant for milliseconds in a minute (60,000) */\n\nZmanimFormatter.MINUTE_MILLIS = 60 * 1000;\n/** constant for milliseconds in an hour (3,600,000) */\n\nZmanimFormatter.HOUR_MILLIS = ZmanimFormatter.MINUTE_MILLIS * 60;\n/**\r\n * Format using the XSD Duration format. This is in the format of PT1H6M7.869S (P for period (duration), T for time,\r\n * H, M and S indicate hours, minutes and seconds.\r\n */\n\nZmanimFormatter.XSD_DURATION_FORMAT = 5;\nZmanimFormatter.XSD_DATE_FORMAT = 'yyyy-LL-dd\\'T\\'HH:mm:ss';\n/**\r\n * Determines if a method should be output by the {@link #toJSON(AstronomicalCalendar)}\r\n *\r\n * @param {string} method - the method in question\r\n * @param {AstronomicalCalendar} astronomicalCalendar - The astronomical calendar, to be able to\r\n * check the parameterlist\r\n * @return if the method should be included in serialization\r\n */\n\nfunction includeMethod(method, astronomicalCalendar) {\n  // Filter out methods with parameters\n  return astronomicalCalendar[method].length === 0 // Filter out methods that don't start with \"get\"\n  && method.startsWith('get') // Filter out excluded methods\n  && !methodNamesToExclude.includes(method);\n}","map":{"version":3,"sources":["../../../src/util/ZmanimFormatter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { DateTime } from 'luxon';\r\nimport * as numeral from 'numeral';\r\nimport { TimeZone, Utils } from '../polyfills/Utils';\r\nimport { Time } from './Time';\r\nimport { AstronomicalCalendar } from '../AstronomicalCalendar';\r\nimport { ZmanimCalendar } from '../ZmanimCalendar';\r\nimport { ComplexZmanimCalendar } from '../ComplexZmanimCalendar';\r\nimport { Zman } from './Zman';\r\nimport { UnsupportedError } from '../polyfills/errors';\r\nconst methodNamesToExclude = [\r\n    'getAdjustedDate',\r\n    'getDate',\r\n    'getElevationAdjustedSunrise',\r\n    'getElevationAdjustedSunset',\r\n    'getMidnightLastNight',\r\n    'getMidnightTonight',\r\n    'getSunriseBaalHatanya',\r\n    'getSunsetBaalHatanya',\r\n];\r\n/**\r\n * A class used to format both non {@link java.util.Date} times generated by the Zmanim package as well as Dates. For\r\n * example the {@link net.sourceforge.zmanim.AstronomicalCalendar#getTemporalHour()} returns the length of the hour in\r\n * milliseconds. This class can format this time.\r\n *\r\n * @author &copy; Eliyahu Hershfeld 2004 - 2019\r\n * @version 1.2\r\n */\r\nexport class ZmanimFormatter {\r\n    constructor(formatOrTimeZone, dateFormat, timeZoneId) {\r\n        this.prependZeroHours = false;\r\n        this.useSeconds = false;\r\n        this.useMillis = false;\r\n        this.timeFormat = ZmanimFormatter.SEXAGESIMAL_XSD_FORMAT;\r\n        let format;\r\n        if (dateFormat) {\r\n            format = formatOrTimeZone;\r\n        }\r\n        else {\r\n            format = 0;\r\n            dateFormat = 'h:mm:ss';\r\n            timeZoneId = formatOrTimeZone;\r\n        }\r\n        this.setTimeZone(timeZoneId);\r\n        if (this.prependZeroHours) {\r\n            this.hourNF = '00';\r\n        }\r\n        this.setTimeFormat(format);\r\n        this.setDateFormat(dateFormat);\r\n    }\r\n    /**\r\n     * @return the timeZone\r\n     */\r\n    getTimeZone() {\r\n        return this.timeZoneId;\r\n    }\r\n    /**\r\n     * @param timeZoneId\r\n     *            the timeZone to set\r\n     */\r\n    setTimeZone(timeZoneId) {\r\n        this.timeZoneId = timeZoneId;\r\n    }\r\n    /**\r\n     * Sets the format to use for formatting.\r\n     *\r\n     * @param format\r\n     *            int the format constant to use.\r\n     */\r\n    setTimeFormat(format) {\r\n        this.timeFormat = format;\r\n        switch (format) {\r\n            case ZmanimFormatter.SEXAGESIMAL_XSD_FORMAT:\r\n                this.setSettings(true, true, true);\r\n                break;\r\n            case ZmanimFormatter.SEXAGESIMAL_FORMAT:\r\n                this.setSettings(false, false, false);\r\n                break;\r\n            case ZmanimFormatter.SEXAGESIMAL_SECONDS_FORMAT:\r\n                this.setSettings(false, true, false);\r\n                break;\r\n            case ZmanimFormatter.SEXAGESIMAL_MILLIS_FORMAT:\r\n                this.setSettings(false, true, true);\r\n                break;\r\n            // case DECIMAL_FORMAT:\r\n            // default:\r\n        }\r\n    }\r\n    /**\r\n     * Sets the SimpleDateFormat Object\r\n     * @param dateFormat the SimpleDateFormat Object to set\r\n     */\r\n    setDateFormat(dateFormat) {\r\n        this.dateFormat = dateFormat;\r\n    }\r\n    /**\r\n     * returns the SimpleDateFormat Object\r\n     * @return the SimpleDateFormat Object\r\n     */\r\n    getDateFormat() {\r\n        return this.dateFormat;\r\n    }\r\n    setSettings(prependZeroHours, useSeconds, useMillis) {\r\n        this.prependZeroHours = prependZeroHours;\r\n        this.useSeconds = useSeconds;\r\n        this.useMillis = useMillis;\r\n    }\r\n    /**\r\n     * A method that formats milliseconds into a time format.\r\n     *\r\n     * @param milliseconds\r\n     *            The time in milliseconds.\r\n     * @return String The formatted <code>String</code>\r\n     */\r\n    /*\r\n        public format(milliseconds: number): string {\r\n            return this.format(milliseconds);\r\n        }\r\n    */\r\n    /**\r\n     * A method that formats milliseconds into a time format.\r\n     *\r\n     * @param millis\r\n     *            The time in milliseconds.\r\n     * @return String The formatted <code>String</code>\r\n     */\r\n    /*\r\n        public format(millis: number): string {\r\n            return format(new Time(millis));\r\n        }\r\n    */\r\n    /**\r\n     * A method that formats {@link Time}objects.\r\n     *\r\n     * @param time\r\n     *            The time <code>Object</code> to be formatted.\r\n     * @return String The formatted <code>String</code>\r\n     */\r\n    format(timeOrMillis) {\r\n        let time;\r\n        if (timeOrMillis instanceof Time) {\r\n            time = timeOrMillis;\r\n        }\r\n        else {\r\n            time = new Time(timeOrMillis);\r\n        }\r\n        if (this.timeFormat === ZmanimFormatter.XSD_DURATION_FORMAT) {\r\n            return ZmanimFormatter.formatXSDDurationTime(time);\r\n        }\r\n        let sb = (numeral(time.getHours()).format(this.hourNF)).concat(':')\r\n            .concat(numeral(time.getMinutes()).format(ZmanimFormatter.minuteSecondNF).toString());\r\n        if (this.useSeconds) {\r\n            sb = sb.concat(':').concat(numeral(time.getSeconds()).format(ZmanimFormatter.minuteSecondNF).toString());\r\n        }\r\n        if (this.useMillis) {\r\n            sb = sb.concat('.').concat(numeral(time.getMilliseconds()).format(ZmanimFormatter.milliNF).toString());\r\n        }\r\n        return sb;\r\n    }\r\n    /**\r\n     * Formats a date using this class's {@link #getDateFormat() date format}.\r\n     *\r\n     * @param dateTime - the date to format\r\n     * @return the formatted String\r\n     */\r\n    formatDateTime(dateTime) {\r\n        const _dateTime = dateTime.setZone(this.getTimeZone());\r\n        if (this.dateFormat === ZmanimFormatter.XSD_DATE_FORMAT) {\r\n            return this.getXSDateTime(_dateTime);\r\n        }\r\n        return _dateTime.toFormat(this.dateFormat);\r\n    }\r\n    /**\r\n     * The date:date-time function returns the current date and time as a date/time string. The date/time string that's\r\n     * returned must be a string in the format defined as the lexical representation of xs:dateTime in <a\r\n     * href=\"http://www.w3.org/TR/xmlschema11-2/#dateTime\">[3.3.8 dateTime]</a> of <a\r\n     * href=\"http://www.w3.org/TR/xmlschema11-2/\">[XML Schema 1.1 Part 2: Datatypes]</a>. The date/time format is\r\n     * basically CCYY-MM-DDThh:mm:ss, although implementers should consult <a\r\n     * href=\"http://www.w3.org/TR/xmlschema11-2/\">[XML Schema 1.1 Part 2: Datatypes]</a> and <a\r\n     * href=\"http://www.iso.ch/markete/8601.pdf\">[ISO 8601]</a> for details. The date/time string format must include a\r\n     * time zone, either a Z to indicate Coordinated Universal Time or a + or - followed by the difference between the\r\n     * difference from UTC represented as hh:mm.\r\n     * @param dateTime - the UTC Date Object\r\n     * @return the XSD dateTime\r\n     */\r\n    getXSDateTime(dateTime) {\r\n        return dateTime.setZone(this.getTimeZone())\r\n            .toFormat(ZmanimFormatter.XSD_DATE_FORMAT.concat('ZZ'));\r\n    }\r\n    /**\r\n     * Represent the hours and minutes with two-digit strings.\r\n     *\r\n     * @param digits\r\n     *            hours or minutes.\r\n     * @return two-digit String representation of hrs or minutes.\r\n     */\r\n    static formatDigits(digits) {\r\n        const dd = Math.abs(digits).toString();\r\n        return dd.length === 1 ? `0${dd}` : dd;\r\n    }\r\n    /**\r\n     * This returns the xml representation of an xsd:duration object.\r\n     *\r\n     * @param millis\r\n     *            the duration in milliseconds\r\n     * @return the xsd:duration formatted String\r\n     */\r\n    /*\r\n        public formatXSDDurationTime(millis: number): string {\r\n            return formatXSDDurationTime(new Time(millis));\r\n        }\r\n    */\r\n    /**\r\n     * This returns the xml representation of an xsd:duration object.\r\n     *\r\n     * @param time\r\n     *            the duration as a Time object\r\n     * @return the xsd:duration formatted String\r\n     */\r\n    static formatXSDDurationTime(timeOrMillis) {\r\n        let time;\r\n        if (timeOrMillis instanceof Time) {\r\n            time = timeOrMillis;\r\n        }\r\n        else {\r\n            time = new Time(timeOrMillis);\r\n        }\r\n        let duration;\r\n        if (time.getHours() !== 0 || time.getMinutes() !== 0 || time.getSeconds() !== 0 || time.getMilliseconds() !== 0) {\r\n            duration = ('P').concat('T');\r\n            if (time.getHours() !== 0)\r\n                duration = duration.concat(`${time.getHours()}H`);\r\n            if (time.getMinutes() !== 0)\r\n                duration = duration.concat(`${time.getMinutes()}M`);\r\n            if (time.getSeconds() !== 0 || time.getMilliseconds() !== 0) {\r\n                duration = duration.concat(`${time.getSeconds()}.${numeral(time.getMilliseconds()).format(ZmanimFormatter.milliNF)}`);\r\n                duration = duration.concat('S');\r\n            }\r\n            if (duration.length === 1)\r\n                duration.concat('T0S'); // zero seconds\r\n            if (time.isNegative()) {\r\n                duration = duration.substr(0, 0).concat('-').concat(duration.substr(0, duration.length));\r\n            }\r\n        }\r\n        return duration.toString();\r\n    }\r\n    static formatDecimal(num) {\r\n        return num - Math.trunc(num) > 0 ? num.toString() : numeral(num).format('0.0');\r\n    }\r\n    /**\r\n     * A method that returns an XML formatted <code>String</code> representing the serialized <code>Object</code>. The\r\n     * format used is:\r\n     *\r\n     * <pre>\r\n     *  &lt;AstronomicalTimes date=&quot;1969-02-08&quot; type=&quot;net.sourceforge.zmanim.AstronomicalCalendar algorithm=&quot;US Naval Almanac Algorithm&quot; location=&quot;Lakewood, NJ&quot; latitude=&quot;40.095965&quot; longitude=&quot;-74.22213&quot; elevation=&quot;31.0&quot; timeZoneName=&quot;Eastern Standard Time&quot; timeZoneID=&quot;America/New_York&quot; timeZoneOffset=&quot;-5&quot;&gt;\r\n     *     &lt;Sunrise&gt;2007-02-18T06:45:27-05:00&lt;/Sunrise&gt;\r\n     *     &lt;TemporalHour&gt;PT54M17.529S&lt;/TemporalHour&gt;\r\n     *     ...\r\n     *   &lt;/AstronomicalTimes&gt;\r\n     * </pre>\r\n     *\r\n     * Note that the output uses the <a href=\"http://www.w3.org/TR/xmlschema11-2/#dateTime\">xsd:dateTime</a> format for\r\n     * times such as sunrise, and <a href=\"http://www.w3.org/TR/xmlschema11-2/#duration\">xsd:duration</a> format for\r\n     * times that are a duration such as the length of a\r\n     * {@link net.sourceforge.zmanim.AstronomicalCalendar#getTemporalHour() temporal hour}. The output of this method is\r\n     * returned by the {@link #toString() toString}.\r\n     *\r\n     * @param astronomicalCalendar the AstronomicalCalendar Object\r\n     *\r\n     * @return The XML formatted <code>String</code>. The format will be:\r\n     *\r\n     *         <pre>\r\n     *  &lt;AstronomicalTimes date=&quot;1969-02-08&quot; type=&quot;net.sourceforge.zmanim.AstronomicalCalendar algorithm=&quot;US Naval Almanac Algorithm&quot; location=&quot;Lakewood, NJ&quot; latitude=&quot;40.095965&quot; longitude=&quot;-74.22213&quot; elevation=&quot;31.0&quot; timeZoneName=&quot;Eastern Standard Time&quot; timeZoneID=&quot;America/New_York&quot; timeZoneOffset=&quot;-5&quot;&gt;\r\n     *     &lt;Sunrise&gt;2007-02-18T06:45:27-05:00&lt;/Sunrise&gt;\r\n     *     &lt;TemporalHour&gt;PT54M17.529S&lt;/TemporalHour&gt;\r\n     *     ...\r\n     *  &lt;/AstronomicalTimes&gt;\r\n     * </pre>\r\n     *\r\n     *         TODO: add proper schema, and support for nulls. XSD duration (for solar hours), should probably return\r\n     *         nil and not P\r\n     * @deprecated\r\n     */\r\n    static toXML() {\r\n        throw new UnsupportedError('This method is not supported.');\r\n    }\r\n    /**\r\n     * A method that returns a JSON formatted <code>String</code> representing the serialized <code>Object</code>. The\r\n     * format used is:\r\n     * <pre>\r\n     * {\r\n     *    &quot;metadata&quot;:{\r\n     *      &quot;date&quot;:&quot;1969-02-08&quot;,\r\n     *      &quot;type&quot;:&quot;net.sourceforge.zmanim.AstronomicalCalendar&quot;,\r\n     *      &quot;algorithm&quot;:&quot;US Naval Almanac Algorithm&quot;,\r\n     *      &quot;location&quot;:&quot;Lakewood, NJ&quot;,\r\n     *      &quot;latitude&quot;:&quot;40.095965&quot;,\r\n     *      &quot;longitude&quot;:&quot;-74.22213&quot;,\r\n     *      &quot;elevation:&quot;31.0&quot;,\r\n     *      &quot;timeZoneName&quot;:&quot;Eastern Standard Time&quot;,\r\n     *      &quot;timeZoneID&quot;:&quot;America/New_York&quot;,\r\n     *      &quot;timeZoneOffset&quot;:&quot;-5&quot;},\r\n     *    &quot;AstronomicalTimes&quot;:{\r\n     *     &quot;Sunrise&quot;:&quot;2007-02-18T06:45:27-05:00&quot;,\r\n     *     &quot;TemporalHour&quot;:&quot;PT54M17.529S&quot;\r\n     *     ...\r\n     *     }\r\n     * }\r\n     * </pre>\r\n     *\r\n     * Note that the output uses the <a href=\"http://www.w3.org/TR/xmlschema11-2/#dateTime\">xsd:dateTime</a> format for\r\n     * times such as sunrise, and <a href=\"http://www.w3.org/TR/xmlschema11-2/#duration\">xsd:duration</a> format for\r\n     * times that are a duration such as the length of a\r\n     * {@link net.sourceforge.zmanim.AstronomicalCalendar#getTemporalHour() temporal hour}.\r\n     *\r\n     * @param astronomicalCalendar the AstronomicalCalendar Object\r\n     *\r\n     * @return The JSON formatted <code>String</code>. The format will be:\r\n     * <pre>\r\n     * {\r\n     *    &quot;metadata&quot;:{\r\n     *      &quot;date&quot;:&quot;1969-02-08&quot;,\r\n     *      &quot;type&quot;:&quot;net.sourceforge.zmanim.AstronomicalCalendar&quot;,\r\n     *      &quot;algorithm&quot;:&quot;US Naval Almanac Algorithm&quot;,\r\n     *      &quot;location&quot;:&quot;Lakewood, NJ&quot;,\r\n     *      &quot;latitude&quot;:&quot;40.095965&quot;,\r\n     *      &quot;longitude&quot;:&quot;-74.22213&quot;,\r\n     *      &quot;elevation:&quot;31.0&quot;,\r\n     *      &quot;timeZoneName&quot;:&quot;Eastern Standard Time&quot;,\r\n     *      &quot;timeZoneID&quot;:&quot;America/New_York&quot;,\r\n     *      &quot;timeZoneOffset&quot;:&quot;-5&quot;},\r\n     *    &quot;AstronomicalTimes&quot;:{\r\n     *     &quot;Sunrise&quot;:&quot;2007-02-18T06:45:27-05:00&quot;,\r\n     *     &quot;TemporalHour&quot;:&quot;PT54M17.529S&quot;\r\n     *     ...\r\n     *     }\r\n     * }\r\n     * </pre>\r\n     */\r\n    static toJSON(astronomicalCalendar) {\r\n        const json = {\r\n            metadata: ZmanimFormatter.getOutputMetadata(astronomicalCalendar),\r\n        };\r\n        const key = ZmanimFormatter.getOutputKey(astronomicalCalendar);\r\n        json[key] = ZmanimFormatter.getZmanimOutput(astronomicalCalendar);\r\n        return json;\r\n    }\r\n    // @ts-ignore\r\n    static getOutputKey(astronomicalCalendar) {\r\n        switch (true) {\r\n            case astronomicalCalendar instanceof ComplexZmanimCalendar:\r\n                return 'Zmanim';\r\n            case astronomicalCalendar instanceof ZmanimCalendar:\r\n                return 'BasicZmanim';\r\n            case astronomicalCalendar instanceof AstronomicalCalendar:\r\n                return 'AstronomicalTimes';\r\n        }\r\n    }\r\n    static getOutputMetadata(astronomicalCalendar) {\r\n        const df = 'yyyy-MM-dd';\r\n        return {\r\n            date: astronomicalCalendar.getDate().toFormat(df),\r\n            type: astronomicalCalendar.getClassName(),\r\n            algorithm: astronomicalCalendar.getAstronomicalCalculator().getCalculatorName(),\r\n            location: astronomicalCalendar.getGeoLocation().getLocationName(),\r\n            latitude: astronomicalCalendar.getGeoLocation().getLatitude().toString(),\r\n            longitude: astronomicalCalendar.getGeoLocation().getLongitude().toString(),\r\n            elevation: ZmanimFormatter.formatDecimal(astronomicalCalendar.getGeoLocation().getElevation()),\r\n            timeZoneName: TimeZone.getDisplayName(astronomicalCalendar.getGeoLocation().getTimeZone(), astronomicalCalendar.getDate()),\r\n            timeZoneID: astronomicalCalendar.getGeoLocation().getTimeZone(),\r\n            timeZoneOffset: ZmanimFormatter.formatDecimal(TimeZone.getOffset(astronomicalCalendar.getGeoLocation().getTimeZone(), astronomicalCalendar.getDate().valueOf()) / ZmanimFormatter.HOUR_MILLIS),\r\n        };\r\n    }\r\n    static getZmanimOutput(astronomicalCalendar) {\r\n        const formatter = new ZmanimFormatter(ZmanimFormatter.XSD_DURATION_FORMAT, ZmanimFormatter.XSD_DATE_FORMAT, astronomicalCalendar.getGeoLocation().getTimeZone());\r\n        /*\r\n            let dateList: Set<Date> = new Set();\r\n            let durationList: Set<number> = new Set();\r\n        */\r\n        const dateList = [];\r\n        let durationList = [];\r\n        const otherList = [];\r\n        // Get al the methods in the calendar\r\n        Utils.getAllMethodNames(astronomicalCalendar, true)\r\n            // Filter out methods that we don't want\r\n            .filter(method => includeMethod(method, astronomicalCalendar))\r\n            // Call each method and get the return values\r\n            .map(method => ({\r\n            methodName: method,\r\n            value: astronomicalCalendar[method].call(astronomicalCalendar),\r\n        }))\r\n            // Filter for return values of type Date or number\r\n            .filter(methodObj => DateTime.isDateTime(methodObj.value) || typeof methodObj.value === 'number' || methodObj.value === null)\r\n            // Separate the Dates and numbers\r\n            .forEach(methodObj => {\r\n            const tagName = methodObj.methodName.substring(3);\r\n            if (DateTime.isDateTime(methodObj.value)) {\r\n                // dateList.add(new KosherZmanim.Zman(methodObj.value, tagName));\r\n                const zman = {\r\n                    zman: methodObj.value,\r\n                    label: tagName,\r\n                };\r\n                dateList.push(zman);\r\n            }\r\n            else if (typeof methodObj.value === 'number') {\r\n                // durationList.add(new KosherZmanim.Zman(methodObj.value, tagName));\r\n                const zman = {\r\n                    duration: methodObj.value,\r\n                    label: tagName,\r\n                };\r\n                durationList.push(zman);\r\n            }\r\n            else {\r\n                otherList.push(tagName);\r\n            }\r\n        });\r\n        dateList.sort(Zman.compareDateOrder);\r\n        // Filter for values in milliseconds, and not values in minutes\r\n        durationList = durationList.filter((zman) => zman.duration > 1000)\r\n            .sort(Zman.compareDurationOrder);\r\n        const timesData = {};\r\n        dateList.forEach((zman) => {\r\n            timesData[zman.label] = formatter.formatDateTime(zman.zman);\r\n        });\r\n        durationList.forEach((zman) => {\r\n            timesData[zman.label] = formatter.format(Math.trunc(zman.duration));\r\n        });\r\n        otherList.forEach((tagName) => {\r\n            timesData[tagName] = 'N/A';\r\n        });\r\n        return timesData;\r\n    }\r\n}\r\nZmanimFormatter.minuteSecondNF = '00';\r\nZmanimFormatter.milliNF = '000';\r\n/**\r\n * Format using hours, minutes, seconds and milliseconds using the xsd:time format. This format will return\r\n * 00.00.00.0 when formatting 0.\r\n */\r\nZmanimFormatter.SEXAGESIMAL_XSD_FORMAT = 0;\r\n/**\r\n * Format using standard decimal format with 5 positions after the decimal.\r\n */\r\nZmanimFormatter.DECIMAL_FORMAT = 1;\r\n/** Format using hours and minutes. */\r\nZmanimFormatter.SEXAGESIMAL_FORMAT = 2;\r\n/** Format using hours, minutes and seconds. */\r\nZmanimFormatter.SEXAGESIMAL_SECONDS_FORMAT = 3;\r\n/** Format using hours, minutes, seconds and milliseconds. */\r\nZmanimFormatter.SEXAGESIMAL_MILLIS_FORMAT = 4;\r\n/** constant for milliseconds in a minute (60,000) */\r\nZmanimFormatter.MINUTE_MILLIS = 60 * 1000;\r\n/** constant for milliseconds in an hour (3,600,000) */\r\nZmanimFormatter.HOUR_MILLIS = ZmanimFormatter.MINUTE_MILLIS * 60;\r\n/**\r\n * Format using the XSD Duration format. This is in the format of PT1H6M7.869S (P for period (duration), T for time,\r\n * H, M and S indicate hours, minutes and seconds.\r\n */\r\nZmanimFormatter.XSD_DURATION_FORMAT = 5;\r\nZmanimFormatter.XSD_DATE_FORMAT = 'yyyy-LL-dd\\'T\\'HH:mm:ss';\r\n/**\r\n * Determines if a method should be output by the {@link #toJSON(AstronomicalCalendar)}\r\n *\r\n * @param {string} method - the method in question\r\n * @param {AstronomicalCalendar} astronomicalCalendar - The astronomical calendar, to be able to\r\n * check the parameterlist\r\n * @return if the method should be included in serialization\r\n */\r\nfunction includeMethod(method, astronomicalCalendar) {\r\n    // Filter out methods with parameters\r\n    return astronomicalCalendar[method].length === 0\r\n        // Filter out methods that don't start with \"get\"\r\n        && method.startsWith('get')\r\n        // Filter out excluded methods\r\n        && !methodNamesToExclude.includes(method);\r\n}\r\n//# sourceMappingURL=ZmanimFormatter.js.map"]},"metadata":{},"sourceType":"module"}