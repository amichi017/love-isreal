{"ast":null,"code":"/* eslint-disable no-inner-declarations */\nimport { DateTime, Info } from 'luxon';\nexport var Utils;\n\n(function (Utils) {\n  // https://stackoverflow.com/a/40577337/8037425\n  function getAllMethodNames(obj, excludeContructors = false) {\n    const methods = new Set(); // eslint-disable-next-line no-cond-assign\n\n    while ((obj = Reflect.getPrototypeOf(obj)) && Reflect.getPrototypeOf(obj)) {\n      const keys = Reflect.ownKeys(obj);\n      keys.filter(key => !excludeContructors || key !== 'constructor').forEach(key => methods.add(key));\n    } // Convert Symbols to strings, if there are any\n\n\n    return Array.from(methods, value => value.toString()).sort();\n  }\n\n  Utils.getAllMethodNames = getAllMethodNames;\n})(Utils || (Utils = {}));\n\nexport var TimeZone;\n\n(function (TimeZone) {\n  /**\r\n   * Returns the amount of time in milliseconds to add to UTC to get\r\n   * standard time in this time zone. Because this value is not\r\n   * affected by daylight saving time, it is called <I>raw\r\n   * offset</I>.\r\n   *\r\n   * Since JS doesn't have a native function for this, use the lesser offset of January and July.\r\n   *\r\n   * @return the amount of raw offset time in milliseconds to add to UTC.\r\n   */\n  function getRawOffset(timeZoneId) {\n    const janDateTime = DateTime.fromObject({\n      month: 1,\n      day: 1,\n      zone: timeZoneId\n    });\n    const julyDateTime = janDateTime.set({\n      month: 7\n    });\n    let rawOffsetMinutes;\n\n    if (janDateTime.offset === julyDateTime.offset) {\n      rawOffsetMinutes = janDateTime.offset;\n    } else {\n      const max = Math.max(janDateTime.offset, julyDateTime.offset);\n      rawOffsetMinutes = max < 0 ? 0 - max : 0 - Math.min(janDateTime.offset, julyDateTime.offset);\n    }\n\n    return rawOffsetMinutes * 60 * 1000;\n  }\n\n  TimeZone.getRawOffset = getRawOffset;\n  /**\r\n   * Returns a name in the specified style of this TimeZone suitable for presentation to the user in the default locale.\r\n   * @param {string} timeZoneId\r\n   * @param {DateTime} [date]\r\n   * @param {boolean} [short]\r\n   */\n\n  function getDisplayName(timeZoneId, date = DateTime.local(), short = false) {\n    return Info.normalizeZone(timeZoneId).offsetName(date.toMillis(), {\n      format: short ? 'short' : 'long'\n    });\n  }\n\n  TimeZone.getDisplayName = getDisplayName;\n  /**\r\n   * Returns the amount of time to be added to local standard time to get local wall clock time.\r\n   * The default implementation returns 3600000 milliseconds (i.e., one hour) if a call to useDaylightTime() returns true.\r\n   * Otherwise, 0 (zero) is returned.\r\n   * @param {string} timeZoneId\r\n   * @return {number}\r\n   */\n\n  function getDSTSavings(timeZoneId) {\n    return Info.hasDST(timeZoneId) ? 3600000 : 0;\n  }\n\n  TimeZone.getDSTSavings = getDSTSavings;\n  /**\r\n   * Returns the offset of this time zone from UTC at the specified date. If Daylight Saving Time is in effect at the\r\n   * specified date, the offset value is adjusted with the amount of daylight saving.\r\n   *\r\n   * This method returns a historically correct offset value if an underlying TimeZone implementation subclass\r\n   * supports historical Daylight Saving Time schedule and GMT offset changes.\r\n   * @param {string} timeZoneId\r\n   * @param {number} millisSinceEpoch\r\n   */\n\n  function getOffset(timeZoneId, millisSinceEpoch) {\n    return Info.normalizeZone(timeZoneId).offset(millisSinceEpoch) * 60 * 1000;\n  }\n\n  TimeZone.getOffset = getOffset;\n})(TimeZone || (TimeZone = {}));\n/**\r\n * java.util.Calendar\r\n */\n\n\nexport var Calendar;\n\n(function (Calendar) {\n  Calendar.JANUARY = 0;\n  Calendar.FEBRUARY = 1;\n  Calendar.MARCH = 2;\n  Calendar.APRIL = 3;\n  Calendar.MAY = 4;\n  Calendar.JUNE = 5;\n  Calendar.JULY = 6;\n  Calendar.AUGUST = 7;\n  Calendar.SEPTEMBER = 8;\n  Calendar.OCTOBER = 9;\n  Calendar.NOVEMBER = 10;\n  Calendar.DECEMBER = 11;\n  Calendar.SUNDAY = 1;\n  Calendar.MONDAY = 2;\n  Calendar.TUESDAY = 3;\n  Calendar.WEDNESDAY = 4;\n  Calendar.THURSDAY = 5;\n  Calendar.FRIDAY = 6;\n  Calendar.SATURDAY = 7;\n  Calendar.DATE = 5;\n  Calendar.MONTH = 2;\n  Calendar.YEAR = 1;\n})(Calendar || (Calendar = {}));\n/**\r\n * java.lang.Math\r\n */\n\n\nexport var MathUtils;\n\n(function (MathUtils) {\n  /**\r\n   * java.lang.Math.toRadians\r\n   * @param degrees\r\n   */\n  function degreesToRadians(degrees) {\n    return degrees * Math.PI / 180;\n  }\n\n  MathUtils.degreesToRadians = degreesToRadians;\n  /**\r\n   * java.lang.Math.toDegrees\r\n   * @param radians\r\n   */\n\n  function radiansToDegrees(radians) {\n    return radians * 180 / Math.PI;\n  }\n\n  MathUtils.radiansToDegrees = radiansToDegrees;\n})(MathUtils || (MathUtils = {}));\n/**\r\n * java.lang.String\r\n */\n\n\nexport var StringUtils;\n\n(function (StringUtils) {\n  /**\r\n   * Compares two strings lexicographically.\r\n   * The comparison is based on the Unicode value of each character in\r\n   * the strings. The character sequence represented by this\r\n   * {@code String} object is compared lexicographically to the\r\n   * character sequence represented by the argument string. The result is\r\n   * a negative integer if this {@code String} object\r\n   * lexicographically precedes the argument string. The result is a\r\n   * positive integer if this {@code String} object lexicographically\r\n   * follows the argument string. The result is zero if the strings\r\n   * are equal; {@code compareTo} returns {@code 0} exactly when\r\n   * the {@link #equals(Object)} method would return {@code true}.\r\n   * <p>\r\n   * This is the definition of lexicographic ordering. If two strings are\r\n   * different, then either they have different characters at some index\r\n   * that is a valid index for both strings, or their lengths are different,\r\n   * or both. If they have different characters at one or more index\r\n   * positions, let <i>k</i> be the smallest such index; then the string\r\n   * whose character at position <i>k</i> has the smaller value, as\r\n   * determined by using the &lt; operator, lexicographically precedes the\r\n   * other string. In this case, {@code compareTo} returns the\r\n   * difference of the two character values at position {@code k} in\r\n   * the two string -- that is, the value:\r\n   * <blockquote><pre>\r\n   * this.charAt(k)-anotherString.charAt(k)\r\n   * </pre></blockquote>\r\n   * If there is no index position at which they differ, then the shorter\r\n   * string lexicographically precedes the longer string. In this case,\r\n   * {@code compareTo} returns the difference of the lengths of the\r\n   * strings -- that is, the value:\r\n   * <blockquote><pre>\r\n   * this.length()-anotherString.length()\r\n   * </pre></blockquote>\r\n   *\r\n   * @param string1\r\n   * @param   string2   the {@code String} to be compared.\r\n   * @return  the value {@code 0} if the argument string is equal to\r\n   *          this string; a value less than {@code 0} if this string\r\n   *          is lexicographically less than the string argument; and a\r\n   *          value greater than {@code 0} if this string is\r\n   *          lexicographically greater than the string argument.\r\n   */\n  function compareTo(string1, string2) {\n    let k = 0;\n\n    while (k < Math.min(string1.length, string2.length)) {\n      if (string1.substr(k, 1) !== string2.substr(k, 1)) {\n        return string1.charCodeAt(k) - string2.charCodeAt(k);\n      }\n\n      k++;\n    }\n\n    return string1.length - string2.length;\n  }\n\n  StringUtils.compareTo = compareTo;\n})(StringUtils || (StringUtils = {}));\n\nexport var IntegerUtils;\n\n(function (IntegerUtils) {\n  /**\r\n   * Compares 2 numbers\r\n   * @param x\r\n   * @param y\r\n   */\n  function compare(x, y) {\n    if (x === y) return 0;\n    return x > y ? 1 : -1;\n  }\n\n  IntegerUtils.compare = compare;\n})(IntegerUtils || (IntegerUtils = {})); // export const Long_MIN_VALUE = 0;\n\n\nexport const Long_MIN_VALUE = NaN;","map":{"version":3,"sources":["../../../src/polyfills/Utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/* eslint-disable no-inner-declarations */\r\nimport { DateTime, Info } from 'luxon';\r\nexport var Utils;\r\n(function (Utils) {\r\n    // https://stackoverflow.com/a/40577337/8037425\r\n    function getAllMethodNames(obj, excludeContructors = false) {\r\n        const methods = new Set();\r\n        // eslint-disable-next-line no-cond-assign\r\n        while ((obj = Reflect.getPrototypeOf(obj)) && Reflect.getPrototypeOf(obj)) {\r\n            const keys = Reflect.ownKeys(obj);\r\n            keys.filter((key) => !excludeContructors || key !== 'constructor')\r\n                .forEach((key) => methods.add(key));\r\n        }\r\n        // Convert Symbols to strings, if there are any\r\n        return Array.from(methods, value => value.toString())\r\n            .sort();\r\n    }\r\n    Utils.getAllMethodNames = getAllMethodNames;\r\n})(Utils || (Utils = {}));\r\nexport var TimeZone;\r\n(function (TimeZone) {\r\n    /**\r\n     * Returns the amount of time in milliseconds to add to UTC to get\r\n     * standard time in this time zone. Because this value is not\r\n     * affected by daylight saving time, it is called <I>raw\r\n     * offset</I>.\r\n     *\r\n     * Since JS doesn't have a native function for this, use the lesser offset of January and July.\r\n     *\r\n     * @return the amount of raw offset time in milliseconds to add to UTC.\r\n     */\r\n    function getRawOffset(timeZoneId) {\r\n        const janDateTime = DateTime.fromObject({\r\n            month: 1,\r\n            day: 1,\r\n            zone: timeZoneId,\r\n        });\r\n        const julyDateTime = janDateTime.set({ month: 7 });\r\n        let rawOffsetMinutes;\r\n        if (janDateTime.offset === julyDateTime.offset) {\r\n            rawOffsetMinutes = janDateTime.offset;\r\n        }\r\n        else {\r\n            const max = Math.max(janDateTime.offset, julyDateTime.offset);\r\n            rawOffsetMinutes = max < 0\r\n                ? 0 - max\r\n                : 0 - Math.min(janDateTime.offset, julyDateTime.offset);\r\n        }\r\n        return rawOffsetMinutes * 60 * 1000;\r\n    }\r\n    TimeZone.getRawOffset = getRawOffset;\r\n    /**\r\n     * Returns a name in the specified style of this TimeZone suitable for presentation to the user in the default locale.\r\n     * @param {string} timeZoneId\r\n     * @param {DateTime} [date]\r\n     * @param {boolean} [short]\r\n     */\r\n    function getDisplayName(timeZoneId, date = DateTime.local(), short = false) {\r\n        return Info.normalizeZone(timeZoneId).offsetName(date.toMillis(), { format: short ? 'short' : 'long' });\r\n    }\r\n    TimeZone.getDisplayName = getDisplayName;\r\n    /**\r\n     * Returns the amount of time to be added to local standard time to get local wall clock time.\r\n     * The default implementation returns 3600000 milliseconds (i.e., one hour) if a call to useDaylightTime() returns true.\r\n     * Otherwise, 0 (zero) is returned.\r\n     * @param {string} timeZoneId\r\n     * @return {number}\r\n     */\r\n    function getDSTSavings(timeZoneId) {\r\n        return Info.hasDST(timeZoneId) ? 3600000 : 0;\r\n    }\r\n    TimeZone.getDSTSavings = getDSTSavings;\r\n    /**\r\n     * Returns the offset of this time zone from UTC at the specified date. If Daylight Saving Time is in effect at the\r\n     * specified date, the offset value is adjusted with the amount of daylight saving.\r\n     *\r\n     * This method returns a historically correct offset value if an underlying TimeZone implementation subclass\r\n     * supports historical Daylight Saving Time schedule and GMT offset changes.\r\n     * @param {string} timeZoneId\r\n     * @param {number} millisSinceEpoch\r\n     */\r\n    function getOffset(timeZoneId, millisSinceEpoch) {\r\n        return Info.normalizeZone(timeZoneId).offset(millisSinceEpoch) * 60 * 1000;\r\n    }\r\n    TimeZone.getOffset = getOffset;\r\n})(TimeZone || (TimeZone = {}));\r\n/**\r\n * java.util.Calendar\r\n */\r\nexport var Calendar;\r\n(function (Calendar) {\r\n    Calendar.JANUARY = 0;\r\n    Calendar.FEBRUARY = 1;\r\n    Calendar.MARCH = 2;\r\n    Calendar.APRIL = 3;\r\n    Calendar.MAY = 4;\r\n    Calendar.JUNE = 5;\r\n    Calendar.JULY = 6;\r\n    Calendar.AUGUST = 7;\r\n    Calendar.SEPTEMBER = 8;\r\n    Calendar.OCTOBER = 9;\r\n    Calendar.NOVEMBER = 10;\r\n    Calendar.DECEMBER = 11;\r\n    Calendar.SUNDAY = 1;\r\n    Calendar.MONDAY = 2;\r\n    Calendar.TUESDAY = 3;\r\n    Calendar.WEDNESDAY = 4;\r\n    Calendar.THURSDAY = 5;\r\n    Calendar.FRIDAY = 6;\r\n    Calendar.SATURDAY = 7;\r\n    Calendar.DATE = 5;\r\n    Calendar.MONTH = 2;\r\n    Calendar.YEAR = 1;\r\n})(Calendar || (Calendar = {}));\r\n/**\r\n * java.lang.Math\r\n */\r\nexport var MathUtils;\r\n(function (MathUtils) {\r\n    /**\r\n     * java.lang.Math.toRadians\r\n     * @param degrees\r\n     */\r\n    function degreesToRadians(degrees) {\r\n        return degrees * Math.PI / 180;\r\n    }\r\n    MathUtils.degreesToRadians = degreesToRadians;\r\n    /**\r\n     * java.lang.Math.toDegrees\r\n     * @param radians\r\n     */\r\n    function radiansToDegrees(radians) {\r\n        return radians * 180 / Math.PI;\r\n    }\r\n    MathUtils.radiansToDegrees = radiansToDegrees;\r\n})(MathUtils || (MathUtils = {}));\r\n/**\r\n * java.lang.String\r\n */\r\nexport var StringUtils;\r\n(function (StringUtils) {\r\n    /**\r\n     * Compares two strings lexicographically.\r\n     * The comparison is based on the Unicode value of each character in\r\n     * the strings. The character sequence represented by this\r\n     * {@code String} object is compared lexicographically to the\r\n     * character sequence represented by the argument string. The result is\r\n     * a negative integer if this {@code String} object\r\n     * lexicographically precedes the argument string. The result is a\r\n     * positive integer if this {@code String} object lexicographically\r\n     * follows the argument string. The result is zero if the strings\r\n     * are equal; {@code compareTo} returns {@code 0} exactly when\r\n     * the {@link #equals(Object)} method would return {@code true}.\r\n     * <p>\r\n     * This is the definition of lexicographic ordering. If two strings are\r\n     * different, then either they have different characters at some index\r\n     * that is a valid index for both strings, or their lengths are different,\r\n     * or both. If they have different characters at one or more index\r\n     * positions, let <i>k</i> be the smallest such index; then the string\r\n     * whose character at position <i>k</i> has the smaller value, as\r\n     * determined by using the &lt; operator, lexicographically precedes the\r\n     * other string. In this case, {@code compareTo} returns the\r\n     * difference of the two character values at position {@code k} in\r\n     * the two string -- that is, the value:\r\n     * <blockquote><pre>\r\n     * this.charAt(k)-anotherString.charAt(k)\r\n     * </pre></blockquote>\r\n     * If there is no index position at which they differ, then the shorter\r\n     * string lexicographically precedes the longer string. In this case,\r\n     * {@code compareTo} returns the difference of the lengths of the\r\n     * strings -- that is, the value:\r\n     * <blockquote><pre>\r\n     * this.length()-anotherString.length()\r\n     * </pre></blockquote>\r\n     *\r\n     * @param string1\r\n     * @param   string2   the {@code String} to be compared.\r\n     * @return  the value {@code 0} if the argument string is equal to\r\n     *          this string; a value less than {@code 0} if this string\r\n     *          is lexicographically less than the string argument; and a\r\n     *          value greater than {@code 0} if this string is\r\n     *          lexicographically greater than the string argument.\r\n     */\r\n    function compareTo(string1, string2) {\r\n        let k = 0;\r\n        while (k < Math.min(string1.length, string2.length)) {\r\n            if (string1.substr(k, 1) !== string2.substr(k, 1)) {\r\n                return string1.charCodeAt(k) - string2.charCodeAt(k);\r\n            }\r\n            k++;\r\n        }\r\n        return string1.length - string2.length;\r\n    }\r\n    StringUtils.compareTo = compareTo;\r\n})(StringUtils || (StringUtils = {}));\r\nexport var IntegerUtils;\r\n(function (IntegerUtils) {\r\n    /**\r\n     * Compares 2 numbers\r\n     * @param x\r\n     * @param y\r\n     */\r\n    function compare(x, y) {\r\n        if (x === y)\r\n            return 0;\r\n        return x > y ? 1 : -1;\r\n    }\r\n    IntegerUtils.compare = compare;\r\n})(IntegerUtils || (IntegerUtils = {}));\r\n// export const Long_MIN_VALUE = 0;\r\nexport const Long_MIN_VALUE = NaN;\r\n//# sourceMappingURL=Utils.js.map"]},"metadata":{},"sourceType":"module"}