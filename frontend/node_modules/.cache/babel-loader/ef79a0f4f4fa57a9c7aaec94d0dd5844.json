{"ast":null,"code":"import { Big } from 'big.js';\nimport { DateTime } from 'luxon';\nimport { Long_MIN_VALUE } from './polyfills/Utils';\nimport { GeoLocation } from './util/GeoLocation';\nimport { NOAACalculator } from './util/NOAACalculator';\nimport { UnsupportedError } from './polyfills/errors';\n/**\r\n * A Java calendar that calculates astronomical times such as {@link #getSunrise() sunrise} and {@link #getSunset()\r\n * sunset} times. This class contains a {@link #getCalendar() Calendar} and can therefore use the standard Calendar\r\n * functionality to change dates etc... The calculation engine used to calculate the astronomical times can be changed\r\n * to a different implementation by implementing the abstract {@link AstronomicalCalculator} and setting it with the\r\n * {@link #setAstronomicalCalculator(AstronomicalCalculator)}. A number of different calculation engine implementations\r\n * are included in the util package.\r\n * <b>Note:</b> There are times when the algorithms can't calculate proper values for sunrise, sunset and twilight. This\r\n * is usually caused by trying to calculate times for areas either very far North or South, where sunrise / sunset never\r\n * happen on that date. This is common when calculating twilight with a deep dip below the horizon for locations as far\r\n * south of the North Pole as London, in the northern hemisphere. The sun never reaches this dip at certain times of the\r\n * year. When the calculations encounter this condition a null will be returned when a\r\n * <code>{@link java.util.Date}</code> is expected and {@link Long#MIN_VALUE} when a <code>long</code> is expected. The\r\n * reason that <code>Exception</code>s are not thrown in these cases is because the lack of a rise/set or twilight is\r\n * not an exception, but an expected condition in many parts of the world.\r\n *\r\n * Here is a simple example of how to use the API to calculate sunrise.\r\n * First create the Calendar for the location you would like to calculate sunrise or sunset times for:\r\n *\r\n * <pre>\r\n * String locationName = &quot;Lakewood, NJ&quot;;\r\n * double latitude = 40.0828; // Lakewood, NJ\r\n * double longitude = -74.2094; // Lakewood, NJ\r\n * double elevation = 20; // optional elevation correction in Meters\r\n * // the String parameter in getTimeZone() has to be a valid timezone listed in\r\n * // {@link java.util.TimeZone#getAvailableIDs()}\r\n * TimeZone timeZone = TimeZone.getTimeZone(&quot;America/New_York&quot;);\r\n * GeoLocation location = new GeoLocation(locationName, latitude, longitude, elevation, timeZone);\r\n * AstronomicalCalendar ac = new AstronomicalCalendar(location);\r\n * </pre>\r\n *\r\n * To get the time of sunrise, first set the date you want (if not set, the date will default to today):\r\n *\r\n * <pre>\r\n * ac.getCalendar().set(Calendar.MONTH, Calendar.FEBRUARY);\r\n * ac.getCalendar().set(Calendar.DAY_OF_MONTH, 8);\r\n * Date sunrise = ac.getSunrise();\r\n * </pre>\r\n *\r\n *\r\n * @author &copy; Eliyahu Hershfeld 2004 - 2016\r\n */\n\nexport class AstronomicalCalendar {\n  /**\r\n   * Default constructor will set a default {@link GeoLocation#GeoLocation()}, a default\r\n   * {@link AstronomicalCalculator#getDefault() AstronomicalCalculator} and default the calendar to the current date.\r\n   */\n\n  /*\r\n  constructor() {\r\n      this(new GeoLocation());\r\n  }\r\n  */\n\n  /**\r\n   * A constructor that takes in <a href=\"http://en.wikipedia.org/wiki/Geolocation\">geolocation</a> information as a\r\n   * parameter. The default {@link AstronomicalCalculator#getDefault() AstronomicalCalculator} used for solar\r\n   * calculations is the the {@link net.sourceforge.zmanim.util.NOAACalculator}.\r\n   *\r\n   * @param geoLocation\r\n   *            The location information used for calculating astronomical sun times.\r\n   *\r\n   * @see #setAstronomicalCalculator(AstronomicalCalculator) for changing the calculator class.\r\n   */\n  constructor(geoLocation = new GeoLocation()) {\n    this.setDate(DateTime.fromObject({\n      zone: geoLocation.getTimeZone()\n    }));\n    this.setGeoLocation(geoLocation); // duplicate call\n\n    this.setAstronomicalCalculator(new NOAACalculator());\n  }\n  /**\r\n   * The getSunrise method Returns a <code>Date</code> representing the\r\n   * {@link AstronomicalCalculator#getElevationAdjustment(double) elevation adjusted} sunrise time. The zenith used\r\n   * for the calculation uses {@link #GEOMETRIC_ZENITH geometric zenith} of 90&deg; plus\r\n   * {@link AstronomicalCalculator#getElevationAdjustment(double)}. This is adjusted by the\r\n   * {@link AstronomicalCalculator} to add approximately 50/60 of a degree to account for 34 archminutes of refraction\r\n   * and 16 archminutes for the sun's radius for a total of {@link AstronomicalCalculator#adjustZenith 90.83333&deg;}.\r\n   * See documentation for the specific implementation of the {@link AstronomicalCalculator} that you are using.\r\n   *\r\n   * @return the <code>Date</code> representing the exact sunrise time. If the calculation can't be computed such as\r\n   *         in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it\r\n   *         does not set, a null will be returned. See detailed explanation on top of the page.\r\n   * @see AstronomicalCalculator#adjustZenith\r\n   * @see #getSeaLevelSunrise()\r\n   * @see AstronomicalCalendar#getUTCSunrise\r\n   */\n\n\n  getSunrise() {\n    const sunrise = this.getUTCSunrise(AstronomicalCalendar.GEOMETRIC_ZENITH);\n    if (Number.isNaN(sunrise)) return null;\n    return this.getDateFromTime(sunrise, true);\n  }\n  /**\r\n   * A method that returns the sunrise without {@link AstronomicalCalculator#getElevationAdjustment(double) elevation\r\n     * adjustment}. Non-sunrise and sunset calculations such as dawn and dusk, depend on the amount of visible light,\r\n   * something that is not affected by elevation. This method returns sunrise calculated at sea level. This forms the\r\n   * base for dawn calculations that are calculated as a dip below the horizon before sunrise.\r\n   *\r\n   * @return the <code>Date</code> representing the exact sea-level sunrise time. If the calculation can't be computed\r\n   *         such as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one\r\n   *         where it does not set, a null will be returned. See detailed explanation on top of the page.\r\n   * @see AstronomicalCalendar#getSunrise\r\n   * @see AstronomicalCalendar#getUTCSeaLevelSunrise\r\n   * @see #getSeaLevelSunset()\r\n   */\n\n\n  getSeaLevelSunrise() {\n    const sunrise = this.getUTCSeaLevelSunrise(AstronomicalCalendar.GEOMETRIC_ZENITH);\n    if (Number.isNaN(sunrise)) return null;\n    return this.getDateFromTime(sunrise, true);\n  }\n  /**\r\n   * A method that returns the beginning of civil twilight (dawn) using a zenith of {@link #CIVIL_ZENITH 96&deg;}.\r\n   *\r\n   * @return The <code>Date</code> of the beginning of civil twilight using a zenith of 96&deg;. If the calculation\r\n   *         can't be computed, null will be returned. See detailed explanation on top of the page.\r\n   * @see #CIVIL_ZENITH\r\n   */\n\n\n  getBeginCivilTwilight() {\n    return this.getSunriseOffsetByDegrees(AstronomicalCalendar.CIVIL_ZENITH);\n  }\n  /**\r\n   * A method that returns the beginning of nautical twilight using a zenith of {@link #NAUTICAL_ZENITH 102&deg;}.\r\n   *\r\n   * @return The <code>Date</code> of the beginning of nautical twilight using a zenith of 102&deg;. If the\r\n   *         calculation can't be computed null will be returned. See detailed explanation on top of the page.\r\n   * @see #NAUTICAL_ZENITH\r\n   */\n\n\n  getBeginNauticalTwilight() {\n    return this.getSunriseOffsetByDegrees(AstronomicalCalendar.NAUTICAL_ZENITH);\n  }\n  /**\r\n   * A method that returns the beginning of astronomical twilight using a zenith of {@link #ASTRONOMICAL_ZENITH\r\n     * 108&deg;}.\r\n   *\r\n   * @return The <code>Date</code> of the beginning of astronomical twilight using a zenith of 108&deg;. If the\r\n   *         calculation can't be computed, null will be returned. See detailed explanation on top of the page.\r\n   * @see #ASTRONOMICAL_ZENITH\r\n   */\n\n\n  getBeginAstronomicalTwilight() {\n    return this.getSunriseOffsetByDegrees(AstronomicalCalendar.ASTRONOMICAL_ZENITH);\n  }\n  /**\r\n   * The getSunset method Returns a <code>Date</code> representing the\r\n   * {@link AstronomicalCalculator#getElevationAdjustment(double) elevation adjusted} sunset time. The zenith used for\r\n   * the calculation uses {@link #GEOMETRIC_ZENITH geometric zenith} of 90&deg; plus\r\n   * {@link AstronomicalCalculator#getElevationAdjustment(double)}. This is adjusted by the\r\n   * {@link AstronomicalCalculator} to add approximately 50/60 of a degree to account for 34 archminutes of refraction\r\n   * and 16 archminutes for the sun's radius for a total of {@link AstronomicalCalculator#adjustZenith 90.83333&deg;}.\r\n   * See documentation for the specific implementation of the {@link AstronomicalCalculator} that you are using. Note:\r\n   * In certain cases the calculates sunset will occur before sunrise. This will typically happen when a timezone\r\n   * other than the local timezone is used (calculating Los Angeles sunset using a GMT timezone for example). In this\r\n   * case the sunset date will be incremented to the following date.\r\n   *\r\n   * @return the <code>Date</code> representing the exact sunset time. If the calculation can't be computed such as in\r\n   *         the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it\r\n   *         does not set, a null will be returned. See detailed explanation on top of the page.\r\n   * @see AstronomicalCalculator#adjustZenith\r\n   * @see #getSeaLevelSunset()\r\n   * @see AstronomicalCalendar#getUTCSunset\r\n   */\n\n\n  getSunset() {\n    const sunset = this.getUTCSunset(AstronomicalCalendar.GEOMETRIC_ZENITH);\n    if (Number.isNaN(sunset)) return null;\n    return this.getDateFromTime(sunset, false);\n  }\n  /**\r\n   * A method that returns the sunset without {@link AstronomicalCalculator#getElevationAdjustment(double) elevation\r\n     * adjustment}. Non-sunrise and sunset calculations such as dawn and dusk, depend on the amount of visible light,\r\n   * something that is not affected by elevation. This method returns sunset calculated at sea level. This forms the\r\n   * base for dusk calculations that are calculated as a dip below the horizon after sunset.\r\n   *\r\n   * @return the <code>Date</code> representing the exact sea-level sunset time. If the calculation can't be computed\r\n   *         such as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one\r\n   *         where it does not set, a null will be returned. See detailed explanation on top of the page.\r\n   * @see AstronomicalCalendar#getSunset\r\n   * @see AstronomicalCalendar#getUTCSeaLevelSunset 2see {@link #getSunset()}\r\n   */\n\n\n  getSeaLevelSunset() {\n    const sunset = this.getUTCSeaLevelSunset(AstronomicalCalendar.GEOMETRIC_ZENITH);\n    if (Number.isNaN(sunset)) return null;\n    return this.getDateFromTime(sunset, false);\n  }\n  /**\r\n   * A method that returns the end of civil twilight using a zenith of {@link #CIVIL_ZENITH 96&deg;}.\r\n   *\r\n   * @return The <code>Date</code> of the end of civil twilight using a zenith of {@link #CIVIL_ZENITH 96&deg;}. If\r\n   *         the calculation can't be computed, null will be returned. See detailed explanation on top of the page.\r\n   * @see #CIVIL_ZENITH\r\n   */\n\n\n  getEndCivilTwilight() {\n    return this.getSunsetOffsetByDegrees(AstronomicalCalendar.CIVIL_ZENITH);\n  }\n  /**\r\n   * A method that returns the end of nautical twilight using a zenith of {@link #NAUTICAL_ZENITH 102&deg;}.\r\n   *\r\n   * @return The <code>Date</code> of the end of nautical twilight using a zenith of {@link #NAUTICAL_ZENITH 102&deg;}\r\n   *         . If the calculation can't be computed, null will be returned. See detailed explanation on top of the\r\n   *         page.\r\n   * @see #NAUTICAL_ZENITH\r\n   */\n\n\n  getEndNauticalTwilight() {\n    return this.getSunsetOffsetByDegrees(AstronomicalCalendar.NAUTICAL_ZENITH);\n  }\n  /**\r\n   * A method that returns the end of astronomical twilight using a zenith of {@link #ASTRONOMICAL_ZENITH 108&deg;}.\r\n   *\r\n   * @return the <code>Date</code> of the end of astronomical twilight using a zenith of {@link #ASTRONOMICAL_ZENITH\r\n     *         108&deg;}. If the calculation can't be computed, null will be returned. See detailed explanation on top\r\n   *         of the page.\r\n   * @see #ASTRONOMICAL_ZENITH\r\n   */\n\n\n  getEndAstronomicalTwilight() {\n    return this.getSunsetOffsetByDegrees(AstronomicalCalendar.ASTRONOMICAL_ZENITH);\n  }\n  /**\r\n   * A utility method that returns a date offset by the offset time passed in. Please note that the level of light\r\n   * during twilight is not affected by elevation, so if this is being used to calculate an offset before sunrise or\r\n   * after sunset with the intent of getting a rough \"level of light\" calculation, the sunrise or sunset time passed\r\n   * to this method should be sea level sunrise and sunset.\r\n   *\r\n   * @param time\r\n   *            the start time\r\n   * @param offset\r\n   *            the offset in milliseconds to add to the time.\r\n   * @return the {@link java.util.Date} with the offset in milliseconds added to it\r\n   */\n\n\n  static getTimeOffset(time, offset) {\n    if (time === null || offset === Long_MIN_VALUE || Number.isNaN(offset)) {\n      return null;\n    }\n\n    return time.plus({\n      milliseconds: offset\n    });\n  }\n  /**\r\n   * A utility method that returns the time of an offset by degrees below or above the horizon of\r\n   * {@link #getSunrise() sunrise}. Note that the degree offset is from the vertical, so for a calculation of 14&deg;\r\n   * before sunrise, an offset of 14 + {@link #GEOMETRIC_ZENITH} = 104 would have to be passed as a parameter.\r\n   *\r\n   * @param offsetZenith\r\n   *            the degrees before {@link #getSunrise()} to use in the calculation. For time after sunrise use\r\n   *            negative numbers. Note that the degree offset is from the vertical, so for a calculation of 14&deg;\r\n   *            before sunrise, an offset of 14 + {@link #GEOMETRIC_ZENITH} = 104 would have to be passed as a\r\n   *            parameter.\r\n   * @return The {@link java.util.Date} of the offset after (or before) {@link #getSunrise()}. If the calculation\r\n   *         can't be computed such as in the Arctic Circle where there is at least one day a year where the sun does\r\n   *         not rise, and one where it does not set, a null will be returned. See detailed explanation on top of the\r\n   *         page.\r\n   */\n\n\n  getSunriseOffsetByDegrees(offsetZenith) {\n    const dawn = this.getUTCSunrise(offsetZenith);\n    if (Number.isNaN(dawn)) return null;\n    return this.getDateFromTime(dawn, true);\n  }\n  /**\r\n   * A utility method that returns the time of an offset by degrees below or above the horizon of {@link #getSunset()\r\n     * sunset}. Note that the degree offset is from the vertical, so for a calculation of 14&deg; after sunset, an\r\n   * offset of 14 + {@link #GEOMETRIC_ZENITH} = 104 would have to be passed as a parameter.\r\n   *\r\n   * @param offsetZenith\r\n   *            the degrees after {@link #getSunset()} to use in the calculation. For time before sunset use negative\r\n   *            numbers. Note that the degree offset is from the vertical, so for a calculation of 14&deg; after\r\n   *            sunset, an offset of 14 + {@link #GEOMETRIC_ZENITH} = 104 would have to be passed as a parameter.\r\n   * @return The {@link java.util.Date}of the offset after (or before) {@link #getSunset()}. If the calculation can't\r\n   *         be computed such as in the Arctic Circle where there is at least one day a year where the sun does not\r\n   *         rise, and one where it does not set, a null will be returned. See detailed explanation on top of the\r\n   *         page.\r\n   */\n\n\n  getSunsetOffsetByDegrees(offsetZenith) {\n    const sunset = this.getUTCSunset(offsetZenith);\n    if (Number.isNaN(sunset)) return null;\n    return this.getDateFromTime(sunset, false);\n  }\n  /**\r\n   * A method that returns the sunrise in UTC time without correction for time zone offset from GMT and without using\r\n   * daylight savings time.\r\n   *\r\n   * @param zenith\r\n   *            the degrees below the horizon. For time after sunrise use negative numbers.\r\n   * @return The time in the format: 18.75 for 18:45:00 UTC/GMT. If the calculation can't be computed such as in the\r\n   *         Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does\r\n   *         not set, {@link Double#NaN} will be returned. See detailed explanation on top of the page.\r\n   */\n\n\n  getUTCSunrise(zenith) {\n    return this.getAstronomicalCalculator().getUTCSunrise(this.getAdjustedDate(), this.getGeoLocation(), zenith, true);\n  }\n  /**\r\n   * A method that returns the sunrise in UTC time without correction for time zone offset from GMT and without using\r\n   * daylight savings time. Non-sunrise and sunset calculations such as dawn and dusk, depend on the amount of visible\r\n   * light, something that is not affected by elevation. This method returns UTC sunrise calculated at sea level. This\r\n   * forms the base for dawn calculations that are calculated as a dip below the horizon before sunrise.\r\n   *\r\n   * @param zenith\r\n   *            the degrees below the horizon. For time after sunrise use negative numbers.\r\n   * @return The time in the format: 18.75 for 18:45:00 UTC/GMT. If the calculation can't be computed such as in the\r\n   *         Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does\r\n   *         not set, {@link Double#NaN} will be returned. See detailed explanation on top of the page.\r\n   * @see AstronomicalCalendar#getUTCSunrise\r\n   * @see AstronomicalCalendar#getUTCSeaLevelSunset\r\n   */\n\n\n  getUTCSeaLevelSunrise(zenith) {\n    return this.getAstronomicalCalculator().getUTCSunrise(this.getAdjustedDate(), this.getGeoLocation(), zenith, false);\n  }\n  /**\r\n   * A method that returns the sunset in UTC time without correction for time zone offset from GMT and without using\r\n   * daylight savings time.\r\n   *\r\n   * @param zenith\r\n   *            the degrees below the horizon. For time after sunset use negative numbers.\r\n   * @return The time in the format: 18.75 for 18:45:00 UTC/GMT. If the calculation can't be computed such as in the\r\n   *         Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does\r\n   *         not set, {@link Double#NaN} will be returned. See detailed explanation on top of the page.\r\n   * @see AstronomicalCalendar#getUTCSeaLevelSunset\r\n   */\n\n\n  getUTCSunset(zenith) {\n    return this.getAstronomicalCalculator().getUTCSunset(this.getAdjustedDate(), this.getGeoLocation(), zenith, true);\n  }\n  /**\r\n   * A method that returns the sunset in UTC time without correction for elevation, time zone offset from GMT and\r\n   * without using daylight savings time. Non-sunrise and sunset calculations such as dawn and dusk, depend on the\r\n   * amount of visible light, something that is not affected by elevation. This method returns UTC sunset calculated\r\n   * at sea level. This forms the base for dusk calculations that are calculated as a dip below the horizon after\r\n   * sunset.\r\n   *\r\n   * @param zenith\r\n   *            the degrees below the horizon. For time before sunset use negative numbers.\r\n   * @return The time in the format: 18.75 for 18:45:00 UTC/GMT. If the calculation can't be computed such as in the\r\n   *         Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does\r\n   *         not set, {@link Double#NaN} will be returned. See detailed explanation on top of the page.\r\n   * @see AstronomicalCalendar#getUTCSunset\r\n   * @see AstronomicalCalendar#getUTCSeaLevelSunrise\r\n   */\n\n\n  getUTCSeaLevelSunset(zenith) {\n    return this.getAstronomicalCalculator().getUTCSunset(this.getAdjustedDate(), this.getGeoLocation(), zenith, false);\n  }\n  /**\r\n   * A method that returns an {@link AstronomicalCalculator#getElevationAdjustment(double) elevation adjusted}\r\n   * temporal (solar) hour. The day from {@link #getSunrise() sunrise} to {@link #getSunset() sunset} is split into 12\r\n   * equal parts with each one being a temporal hour.\r\n   *\r\n   * @see #getSunrise()\r\n   * @see #getSunset()\r\n   * @see #getTemporalHour(Date, Date)\r\n   *\r\n   * @return the <code>long</code> millisecond length of a temporal hour. If the calculation can't be computed,\r\n   *         {@link Long#MIN_VALUE} will be returned. See detailed explanation on top of the page.\r\n   *\r\n   * @see #getTemporalHour(Date, Date)\r\n   */\n\n  /*\r\n      public getTemporalHour(): number {\r\n          return this.getTemporalHour(this.getSeaLevelSunrise(), this.getSeaLevelSunset());\r\n      }\r\n  */\n\n  /**\r\n   * A utility method that will allow the calculation of a temporal (solar) hour based on the sunrise and sunset\r\n   * passed as parameters to this method. An example of the use of this method would be the calculation of a\r\n   * non-elevation adjusted temporal hour by passing in {@link #getSeaLevelSunrise() sea level sunrise} and\r\n   * {@link #getSeaLevelSunset() sea level sunset} as parameters.\r\n   *\r\n   * @param startOfday\r\n   *            The start of the day.\r\n   * @param endOfDay\r\n   *            The end of the day.\r\n   *\r\n   * @return the <code>long</code> millisecond length of the temporal hour. If the calculation can't be computed a\r\n   *         {@link Long#MIN_VALUE} will be returned. See detailed explanation on top of the page.\r\n   *\r\n   * @see #getTemporalHour()\r\n   */\n\n\n  getTemporalHour(startOfday = this.getSeaLevelSunrise(), endOfDay = this.getSeaLevelSunset()) {\n    if (startOfday === null || endOfDay === null) {\n      return Long_MIN_VALUE;\n    }\n\n    return (endOfDay.valueOf() - startOfday.valueOf()) / 12;\n  }\n  /**\r\n   * A method that returns sundial or solar noon. It occurs when the Sun is <a href\r\n   * =\"http://en.wikipedia.org/wiki/Transit_%28astronomy%29\">transiting</a> the <a\r\n   * href=\"http://en.wikipedia.org/wiki/Meridian_%28astronomy%29\">celestial meridian</a>. In this class it is\r\n   * calculated as halfway between sea level sunrise and sea level sunset, which can be slightly off the real transit\r\n   * time due to changes in declination (the lengthening or shortening day).\r\n   *\r\n   * @return the <code>Date</code> representing Sun's transit. If the calculation can't be computed such as in the\r\n   *         Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does\r\n   *         not set, null will be returned. See detailed explanation on top of the page.\r\n   * @see #getSunTransit(Date, Date)\r\n   * @see #getTemporalHour()\r\n   */\n\n  /*\r\n      public getSunTransit(): Date {\r\n          return this.getSunTransit(getSeaLevelSunrise(), this.getSeaLevelSunset());\r\n      }\r\n  */\n\n  /**\r\n   * A method that returns sundial or solar noon. It occurs when the Sun is <a href\r\n   * =\"http://en.wikipedia.org/wiki/Transit_%28astronomy%29\">transiting</a> the <a\r\n   * href=\"http://en.wikipedia.org/wiki/Meridian_%28astronomy%29\">celestial meridian</a>. In this class it is\r\n   * calculated as halfway between the sunrise and sunset passed to this method. This time can be slightly off the\r\n   * real transit time due to changes in declination (the lengthening or shortening day).\r\n   *\r\n   * @param startOfDay\r\n   *            the start of day for calculating the sun's transit. This can be sea level sunrise, visual sunrise (or\r\n   *            any arbitrary start of day) passed to this method.\r\n   * @param endOfDay\r\n   *            the end of day for calculating the sun's transit. This can be sea level sunset, visual sunset (or any\r\n   *            arbitrary end of day) passed to this method.\r\n   *\r\n   * @return the <code>Date</code> representing Sun's transit. If the calculation can't be computed such as in the\r\n   *         Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does\r\n   *         not set, null will be returned. See detailed explanation on top of the page.\r\n   */\n\n\n  getSunTransit(startOfDay = this.getSeaLevelSunrise(), endOfDay = this.getSeaLevelSunset()) {\n    const temporalHour = this.getTemporalHour(startOfDay, endOfDay);\n    return AstronomicalCalendar.getTimeOffset(startOfDay, temporalHour * 6);\n  }\n  /**\r\n   * A method that returns a <code>Date</code> from the time passed in as a parameter.\r\n   *\r\n   * @param time\r\n   *            The time to be set as the time for the <code>Date</code>. The time expected is in the format: 18.75\r\n   *            for 6:45:00 PM.\r\n   * @param isSunrise true if the time is sunrise, and false if it is sunset\r\n   * @return The Date.\r\n   */\n\n\n  getDateFromTime(time, isSunrise) {\n    if (Number.isNaN(time)) {\n      return null;\n    }\n\n    let calculatedTime = time;\n    const adjustedDate = this.getAdjustedDate();\n    let cal = DateTime.utc(adjustedDate.year, adjustedDate.month, adjustedDate.day);\n    const hours = Math.trunc(calculatedTime); // retain only the hours\n\n    calculatedTime -= hours;\n    const minutes = Math.trunc(calculatedTime *= 60); // retain only the minutes\n\n    calculatedTime -= minutes;\n    const seconds = Math.trunc(calculatedTime *= 60); // retain only the seconds\n\n    calculatedTime -= seconds; // remaining milliseconds\n    // Check if a date transition has occurred, or is about to occur - this indicates the date of the event is\n    // actually not the target date, but the day prior or after\n\n    const localTimeHours = Math.trunc(this.getGeoLocation().getLongitude() / 15);\n\n    if (isSunrise && localTimeHours + hours > 18) {\n      cal = cal.minus({\n        days: 1\n      });\n    } else if (!isSunrise && localTimeHours + hours < 6) {\n      cal = cal.plus({\n        days: 1\n      });\n    }\n\n    return cal.set({\n      hour: hours,\n      minute: minutes,\n      second: seconds,\n      millisecond: Math.trunc(calculatedTime * 1000)\n    });\n  }\n  /**\r\n   * Returns the dip below the horizon before sunrise that matches the offset minutes on passed in as a parameter. For\r\n   * example passing in 72 minutes for a calendar set to the equinox in Jerusalem returns a value close to 16.1&deg;\r\n   * Please note that this method is very slow and inefficient and should NEVER be used in a loop. TODO: Improve\r\n   * efficiency.\r\n   *\r\n   * @param minutes\r\n   *            offset\r\n   * @return the degrees below the horizon before sunrise that match the offset in minutes passed it as a parameter.\r\n   * @see #getSunsetSolarDipFromOffset(double)\r\n   */\n\n\n  getSunriseSolarDipFromOffset(minutes) {\n    if (Number.isNaN(minutes)) return null;\n    let offsetByDegrees = this.getSeaLevelSunrise();\n    const offsetByTime = AstronomicalCalendar.getTimeOffset(this.getSeaLevelSunrise(), -(minutes * AstronomicalCalendar.MINUTE_MILLIS));\n    let degrees = new Big(0);\n    const incrementor = new Big('0.0001'); // If `minutes` is not `NaN` and `offsetByDegrees` is not null, `offsetByTime` should not be null\n\n    while (offsetByDegrees === null || offsetByDegrees.valueOf() > offsetByTime.valueOf()) {\n      degrees = degrees.plus(incrementor);\n      offsetByDegrees = this.getSunriseOffsetByDegrees(AstronomicalCalendar.GEOMETRIC_ZENITH + Number.parseFloat(degrees.valueOf()));\n    }\n\n    return Number.parseFloat(degrees.valueOf());\n  }\n  /**\r\n   * Returns the dip below the horizon after sunset that matches the offset minutes on passed in as a parameter. For\r\n   * example passing in 72 minutes for a calendar set to the equinox in Jerusalem returns a value close to 16.1&deg;\r\n   * Please note that this method is very slow and inefficient and should NEVER be used in a loop. TODO: Improve\r\n   * efficiency.\r\n   *\r\n   * @param minutes\r\n   *            offset\r\n   * @return the degrees below the horizon after sunset that match the offset in minutes passed it as a parameter.\r\n   * @see #getSunriseSolarDipFromOffset(double)\r\n   */\n\n\n  getSunsetSolarDipFromOffset(minutes) {\n    if (Number.isNaN(minutes)) return null;\n    let offsetByDegrees = this.getSeaLevelSunset();\n    const offsetByTime = AstronomicalCalendar.getTimeOffset(this.getSeaLevelSunset(), minutes * AstronomicalCalendar.MINUTE_MILLIS);\n    let degrees = new Big(0);\n    const incrementor = new Big('0.001'); // If `minutes` is not `NaN` and `offsetByDegrees` is not null, `offsetByTime` should not be null\n\n    while (offsetByDegrees === null || offsetByDegrees < offsetByTime) {\n      degrees = degrees.plus(incrementor);\n      offsetByDegrees = this.getSunsetOffsetByDegrees(AstronomicalCalendar.GEOMETRIC_ZENITH + Number.parseFloat(degrees.valueOf()));\n    }\n\n    return Number.parseFloat(degrees.valueOf());\n  }\n  /**\r\n   * Adjusts the <code>Calendar</code> to deal with edge cases where the location crosses the antimeridian.\r\n   *\r\n   * @see GeoLocation#getAntimeridianAdjustment()\r\n   * @return the adjusted Calendar\r\n   */\n\n\n  getAdjustedDate() {\n    const offset = this.getGeoLocation().getAntimeridianAdjustment();\n    if (offset === 0) return this.getDate();\n    return this.getDate().plus({\n      days: offset\n    });\n  }\n  /**\r\n   * @return an XML formatted representation of the class. It returns the default output of the\r\n   *         {@link net.sourceforge.zmanim.util.ZmanimFormatter#toXML(AstronomicalCalendar) toXML} method.\r\n   * @see net.sourceforge.zmanim.util.ZmanimFormatter#toXML(AstronomicalCalendar)\r\n   * @see java.lang.Object#toString()\r\n   * @deprecated (This depends on a circular dependency).\r\n   */\n  // eslint-disable-next-line class-methods-use-this\n\n\n  toString() {\n    throw new UnsupportedError('This method is unsupported, due to the fact that it depends on a circular dependency.');\n  }\n  /**\r\n   * @return a JSON formatted representation of the class. It returns the default output of the\r\n   *         {@link net.sourceforge.zmanim.util.ZmanimFormatter#toJSON(AstronomicalCalendar) toJSON} method.\r\n   * @see net.sourceforge.zmanim.util.ZmanimFormatter#toJSON(AstronomicalCalendar)\r\n   * @see java.lang.Object#toString()\r\n   * @deprecated  This depends on a circular dependency. Use <pre>ZmanimFormatter.toJSON(astronomicalCalendar)</pre> instead.\r\n   */\n  // eslint-disable-next-line class-methods-use-this\n\n\n  toJSON() {\n    throw new UnsupportedError('This method is unsupported, due to the fact that it depends on a circular dependency. ' + 'Use `ZmanimFormatter.toJSON(astronomicalCalendar)` instead.');\n  }\n  /**\r\n   * @see java.lang.Object#equals(Object)\r\n   */\n\n\n  equals(object) {\n    if (this === object) {\n      return true;\n    }\n\n    if (!(object instanceof AstronomicalCalendar)) {\n      return false;\n    }\n\n    const aCal = object;\n    return this.getDate().equals(aCal.getDate()) && this.getGeoLocation().equals(aCal.getGeoLocation()) && this.getAstronomicalCalculator() === aCal.getAstronomicalCalculator();\n  }\n  /**\r\n   * A method that returns the currently set {@link GeoLocation} which contains location information used for the\r\n   * astronomical calculations.\r\n   *\r\n   * @return Returns the geoLocation.\r\n   */\n\n\n  getGeoLocation() {\n    return this.geoLocation;\n  }\n  /**\r\n   * Sets the {@link GeoLocation} <code>Object</code> to be used for astronomical calculations.\r\n   *\r\n   * @param geoLocation\r\n   *            The geoLocation to set.\r\n   */\n\n\n  setGeoLocation(geoLocation) {\n    this.geoLocation = geoLocation;\n    this.date = this.date.setZone(geoLocation.getTimeZone());\n  }\n  /**\r\n   * A method that returns the currently set AstronomicalCalculator.\r\n   *\r\n   * @return Returns the astronomicalCalculator.\r\n   * @see #setAstronomicalCalculator(AstronomicalCalculator)\r\n   */\n\n\n  getAstronomicalCalculator() {\n    return this.astronomicalCalculator;\n  }\n  /**\r\n   * A method to set the {@link AstronomicalCalculator} used for astronomical calculations. The Zmanim package ships\r\n   * with a number of different implementations of the <code>abstract</code> {@link AstronomicalCalculator} based on\r\n   * different algorithms, including {@link net.sourceforge.zmanim.util.SunTimesCalculator one implementation} based\r\n   * on the <a href = \"http://aa.usno.navy.mil/\">US Naval Observatory's</a> algorithm, and\r\n   * {@link net.sourceforge.zmanim.util.NOAACalculator another} based on <a href=\"http://noaa.gov\">NOAA's</a>\r\n   * algorithm. This allows easy runtime switching and comparison of different algorithms.\r\n   *\r\n   * @param astronomicalCalculator\r\n   *            The astronomicalCalculator to set.\r\n   */\n\n\n  setAstronomicalCalculator(astronomicalCalculator) {\n    this.astronomicalCalculator = astronomicalCalculator;\n  }\n  /**\r\n   * returns the Calendar object encapsulated in this class.\r\n   *\r\n   * @return Returns the calendar.\r\n   */\n\n\n  getDate() {\n    return this.date;\n  }\n  /**\r\n   * @param calendar\r\n   *            The calendar to set.\r\n   */\n\n\n  setDate(date) {\n    if (DateTime.isDateTime(date)) {\n      this.date = date;\n    } else if (date instanceof Date) {\n      this.date = DateTime.fromJSDate(date);\n    } else if (typeof date === 'string') {\n      this.date = DateTime.fromISO(date);\n    } else if (typeof date === 'number') {\n      this.date = DateTime.fromMillis(date);\n    }\n  }\n  /**\r\n   * A method that creates a <a href=\"http://en.wikipedia.org/wiki/Object_copy#Deep_copy\">deep copy</a> of the object.\r\n   * <b>Note:</b> If the {@link java.util.TimeZone} in the cloned {@link net.sourceforge.zmanim.util.GeoLocation} will\r\n   * be changed from the original, it is critical that\r\n   * {@link net.sourceforge.zmanim.AstronomicalCalendar#getCalendar()}.\r\n   * {@link java.util.Calendar#setTimeZone(TimeZone) setTimeZone(TimeZone)} be called in order for the\r\n   * AstronomicalCalendar to output times in the expected offset after being cloned.\r\n   *\r\n   * @see java.lang.Object#clone()\r\n   * @since 1.1\r\n   */\n\n\n  clone() {\n    const clonedCalendar = new AstronomicalCalendar();\n    clonedCalendar.setDate(this.date);\n    clonedCalendar.setAstronomicalCalculator(this.astronomicalCalculator);\n    clonedCalendar.setGeoLocation(this.geoLocation);\n    return clonedCalendar;\n  } // eslint-disable-next-line class-methods-use-this\n\n\n  getClassName() {\n    return 'net.sourceforge.zmanim.AstronomicalCalendar';\n  }\n\n}\n/**\r\n * 90&deg; below the vertical. Used as a basis for most calculations since the location of the sun is 90&deg; below\r\n * the horizon at sunrise and sunset.\r\n * <b>Note </b>: it is important to note that for sunrise and sunset the {@link AstronomicalCalculator#adjustZenith\r\n   * adjusted zenith} is required to account for the radius of the sun and refraction. The adjusted zenith should not\r\n * be used for calculations above or below 90&deg; since they are usually calculated as an offset to 90&deg;.\r\n */\n\nAstronomicalCalendar.GEOMETRIC_ZENITH = 90;\n/**\r\n * Default value for Sun's zenith and true rise/set Zenith (used in this class and subclasses) is the angle that the\r\n * center of the Sun makes to a line perpendicular to the Earth's surface. If the Sun were a point and the Earth\r\n * were without an atmosphere, true sunset and sunrise would correspond to a 90&deg; zenith. Because the Sun is not\r\n * a point, and because the atmosphere refracts light, this 90&deg; zenith does not, in fact, correspond to true\r\n * sunset or sunrise, instead the center of the Sun's disk must lie just below the horizon for the upper edge to be\r\n * obscured. This means that a zenith of just above 90&deg; must be used. The Sun subtends an angle of 16 minutes of\r\n * arc (this can be changed via the {@link #setSunRadius(double)} method , and atmospheric refraction accounts for\r\n * 34 minutes or so (this can be changed via the {@link #setRefraction(double)} method), giving a total of 50\r\n * arcminutes. The total value for ZENITH is 90+(5/6) or 90.8333333&deg; for true sunrise/sunset.\r\n */\n// const ZENITH: number = GEOMETRIC_ZENITH + 5.0 / 6.0;\n\n/** Sun's zenith at civil twilight (96&deg;). */\n\nAstronomicalCalendar.CIVIL_ZENITH = 96;\n/** Sun's zenith at nautical twilight (102&deg;). */\n\nAstronomicalCalendar.NAUTICAL_ZENITH = 102;\n/** Sun's zenith at astronomical twilight (108&deg;). */\n\nAstronomicalCalendar.ASTRONOMICAL_ZENITH = 108;\n/** constant for milliseconds in a minute (60,000) */\n\nAstronomicalCalendar.MINUTE_MILLIS = 60 * 1000;\n/** constant for milliseconds in an hour (3,600,000) */\n\nAstronomicalCalendar.HOUR_MILLIS = AstronomicalCalendar.MINUTE_MILLIS * 60;","map":{"version":3,"sources":["../../src/AstronomicalCalendar.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Big } from 'big.js';\r\nimport { DateTime } from 'luxon';\r\nimport { Long_MIN_VALUE } from './polyfills/Utils';\r\nimport { GeoLocation } from './util/GeoLocation';\r\nimport { NOAACalculator } from './util/NOAACalculator';\r\nimport { UnsupportedError } from './polyfills/errors';\r\n/**\r\n * A Java calendar that calculates astronomical times such as {@link #getSunrise() sunrise} and {@link #getSunset()\r\n * sunset} times. This class contains a {@link #getCalendar() Calendar} and can therefore use the standard Calendar\r\n * functionality to change dates etc... The calculation engine used to calculate the astronomical times can be changed\r\n * to a different implementation by implementing the abstract {@link AstronomicalCalculator} and setting it with the\r\n * {@link #setAstronomicalCalculator(AstronomicalCalculator)}. A number of different calculation engine implementations\r\n * are included in the util package.\r\n * <b>Note:</b> There are times when the algorithms can't calculate proper values for sunrise, sunset and twilight. This\r\n * is usually caused by trying to calculate times for areas either very far North or South, where sunrise / sunset never\r\n * happen on that date. This is common when calculating twilight with a deep dip below the horizon for locations as far\r\n * south of the North Pole as London, in the northern hemisphere. The sun never reaches this dip at certain times of the\r\n * year. When the calculations encounter this condition a null will be returned when a\r\n * <code>{@link java.util.Date}</code> is expected and {@link Long#MIN_VALUE} when a <code>long</code> is expected. The\r\n * reason that <code>Exception</code>s are not thrown in these cases is because the lack of a rise/set or twilight is\r\n * not an exception, but an expected condition in many parts of the world.\r\n *\r\n * Here is a simple example of how to use the API to calculate sunrise.\r\n * First create the Calendar for the location you would like to calculate sunrise or sunset times for:\r\n *\r\n * <pre>\r\n * String locationName = &quot;Lakewood, NJ&quot;;\r\n * double latitude = 40.0828; // Lakewood, NJ\r\n * double longitude = -74.2094; // Lakewood, NJ\r\n * double elevation = 20; // optional elevation correction in Meters\r\n * // the String parameter in getTimeZone() has to be a valid timezone listed in\r\n * // {@link java.util.TimeZone#getAvailableIDs()}\r\n * TimeZone timeZone = TimeZone.getTimeZone(&quot;America/New_York&quot;);\r\n * GeoLocation location = new GeoLocation(locationName, latitude, longitude, elevation, timeZone);\r\n * AstronomicalCalendar ac = new AstronomicalCalendar(location);\r\n * </pre>\r\n *\r\n * To get the time of sunrise, first set the date you want (if not set, the date will default to today):\r\n *\r\n * <pre>\r\n * ac.getCalendar().set(Calendar.MONTH, Calendar.FEBRUARY);\r\n * ac.getCalendar().set(Calendar.DAY_OF_MONTH, 8);\r\n * Date sunrise = ac.getSunrise();\r\n * </pre>\r\n *\r\n *\r\n * @author &copy; Eliyahu Hershfeld 2004 - 2016\r\n */\r\nexport class AstronomicalCalendar {\r\n    /**\r\n     * Default constructor will set a default {@link GeoLocation#GeoLocation()}, a default\r\n     * {@link AstronomicalCalculator#getDefault() AstronomicalCalculator} and default the calendar to the current date.\r\n     */\r\n    /*\r\n    constructor() {\r\n        this(new GeoLocation());\r\n    }\r\n    */\r\n    /**\r\n     * A constructor that takes in <a href=\"http://en.wikipedia.org/wiki/Geolocation\">geolocation</a> information as a\r\n     * parameter. The default {@link AstronomicalCalculator#getDefault() AstronomicalCalculator} used for solar\r\n     * calculations is the the {@link net.sourceforge.zmanim.util.NOAACalculator}.\r\n     *\r\n     * @param geoLocation\r\n     *            The location information used for calculating astronomical sun times.\r\n     *\r\n     * @see #setAstronomicalCalculator(AstronomicalCalculator) for changing the calculator class.\r\n     */\r\n    constructor(geoLocation = new GeoLocation()) {\r\n        this.setDate(DateTime.fromObject({ zone: geoLocation.getTimeZone() }));\r\n        this.setGeoLocation(geoLocation); // duplicate call\r\n        this.setAstronomicalCalculator(new NOAACalculator());\r\n    }\r\n    /**\r\n     * The getSunrise method Returns a <code>Date</code> representing the\r\n     * {@link AstronomicalCalculator#getElevationAdjustment(double) elevation adjusted} sunrise time. The zenith used\r\n     * for the calculation uses {@link #GEOMETRIC_ZENITH geometric zenith} of 90&deg; plus\r\n     * {@link AstronomicalCalculator#getElevationAdjustment(double)}. This is adjusted by the\r\n     * {@link AstronomicalCalculator} to add approximately 50/60 of a degree to account for 34 archminutes of refraction\r\n     * and 16 archminutes for the sun's radius for a total of {@link AstronomicalCalculator#adjustZenith 90.83333&deg;}.\r\n     * See documentation for the specific implementation of the {@link AstronomicalCalculator} that you are using.\r\n     *\r\n     * @return the <code>Date</code> representing the exact sunrise time. If the calculation can't be computed such as\r\n     *         in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it\r\n     *         does not set, a null will be returned. See detailed explanation on top of the page.\r\n     * @see AstronomicalCalculator#adjustZenith\r\n     * @see #getSeaLevelSunrise()\r\n     * @see AstronomicalCalendar#getUTCSunrise\r\n     */\r\n    getSunrise() {\r\n        const sunrise = this.getUTCSunrise(AstronomicalCalendar.GEOMETRIC_ZENITH);\r\n        if (Number.isNaN(sunrise))\r\n            return null;\r\n        return this.getDateFromTime(sunrise, true);\r\n    }\r\n    /**\r\n     * A method that returns the sunrise without {@link AstronomicalCalculator#getElevationAdjustment(double) elevation\r\n       * adjustment}. Non-sunrise and sunset calculations such as dawn and dusk, depend on the amount of visible light,\r\n     * something that is not affected by elevation. This method returns sunrise calculated at sea level. This forms the\r\n     * base for dawn calculations that are calculated as a dip below the horizon before sunrise.\r\n     *\r\n     * @return the <code>Date</code> representing the exact sea-level sunrise time. If the calculation can't be computed\r\n     *         such as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one\r\n     *         where it does not set, a null will be returned. See detailed explanation on top of the page.\r\n     * @see AstronomicalCalendar#getSunrise\r\n     * @see AstronomicalCalendar#getUTCSeaLevelSunrise\r\n     * @see #getSeaLevelSunset()\r\n     */\r\n    getSeaLevelSunrise() {\r\n        const sunrise = this.getUTCSeaLevelSunrise(AstronomicalCalendar.GEOMETRIC_ZENITH);\r\n        if (Number.isNaN(sunrise))\r\n            return null;\r\n        return this.getDateFromTime(sunrise, true);\r\n    }\r\n    /**\r\n     * A method that returns the beginning of civil twilight (dawn) using a zenith of {@link #CIVIL_ZENITH 96&deg;}.\r\n     *\r\n     * @return The <code>Date</code> of the beginning of civil twilight using a zenith of 96&deg;. If the calculation\r\n     *         can't be computed, null will be returned. See detailed explanation on top of the page.\r\n     * @see #CIVIL_ZENITH\r\n     */\r\n    getBeginCivilTwilight() {\r\n        return this.getSunriseOffsetByDegrees(AstronomicalCalendar.CIVIL_ZENITH);\r\n    }\r\n    /**\r\n     * A method that returns the beginning of nautical twilight using a zenith of {@link #NAUTICAL_ZENITH 102&deg;}.\r\n     *\r\n     * @return The <code>Date</code> of the beginning of nautical twilight using a zenith of 102&deg;. If the\r\n     *         calculation can't be computed null will be returned. See detailed explanation on top of the page.\r\n     * @see #NAUTICAL_ZENITH\r\n     */\r\n    getBeginNauticalTwilight() {\r\n        return this.getSunriseOffsetByDegrees(AstronomicalCalendar.NAUTICAL_ZENITH);\r\n    }\r\n    /**\r\n     * A method that returns the beginning of astronomical twilight using a zenith of {@link #ASTRONOMICAL_ZENITH\r\n       * 108&deg;}.\r\n     *\r\n     * @return The <code>Date</code> of the beginning of astronomical twilight using a zenith of 108&deg;. If the\r\n     *         calculation can't be computed, null will be returned. See detailed explanation on top of the page.\r\n     * @see #ASTRONOMICAL_ZENITH\r\n     */\r\n    getBeginAstronomicalTwilight() {\r\n        return this.getSunriseOffsetByDegrees(AstronomicalCalendar.ASTRONOMICAL_ZENITH);\r\n    }\r\n    /**\r\n     * The getSunset method Returns a <code>Date</code> representing the\r\n     * {@link AstronomicalCalculator#getElevationAdjustment(double) elevation adjusted} sunset time. The zenith used for\r\n     * the calculation uses {@link #GEOMETRIC_ZENITH geometric zenith} of 90&deg; plus\r\n     * {@link AstronomicalCalculator#getElevationAdjustment(double)}. This is adjusted by the\r\n     * {@link AstronomicalCalculator} to add approximately 50/60 of a degree to account for 34 archminutes of refraction\r\n     * and 16 archminutes for the sun's radius for a total of {@link AstronomicalCalculator#adjustZenith 90.83333&deg;}.\r\n     * See documentation for the specific implementation of the {@link AstronomicalCalculator} that you are using. Note:\r\n     * In certain cases the calculates sunset will occur before sunrise. This will typically happen when a timezone\r\n     * other than the local timezone is used (calculating Los Angeles sunset using a GMT timezone for example). In this\r\n     * case the sunset date will be incremented to the following date.\r\n     *\r\n     * @return the <code>Date</code> representing the exact sunset time. If the calculation can't be computed such as in\r\n     *         the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it\r\n     *         does not set, a null will be returned. See detailed explanation on top of the page.\r\n     * @see AstronomicalCalculator#adjustZenith\r\n     * @see #getSeaLevelSunset()\r\n     * @see AstronomicalCalendar#getUTCSunset\r\n     */\r\n    getSunset() {\r\n        const sunset = this.getUTCSunset(AstronomicalCalendar.GEOMETRIC_ZENITH);\r\n        if (Number.isNaN(sunset))\r\n            return null;\r\n        return this.getDateFromTime(sunset, false);\r\n    }\r\n    /**\r\n     * A method that returns the sunset without {@link AstronomicalCalculator#getElevationAdjustment(double) elevation\r\n       * adjustment}. Non-sunrise and sunset calculations such as dawn and dusk, depend on the amount of visible light,\r\n     * something that is not affected by elevation. This method returns sunset calculated at sea level. This forms the\r\n     * base for dusk calculations that are calculated as a dip below the horizon after sunset.\r\n     *\r\n     * @return the <code>Date</code> representing the exact sea-level sunset time. If the calculation can't be computed\r\n     *         such as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one\r\n     *         where it does not set, a null will be returned. See detailed explanation on top of the page.\r\n     * @see AstronomicalCalendar#getSunset\r\n     * @see AstronomicalCalendar#getUTCSeaLevelSunset 2see {@link #getSunset()}\r\n     */\r\n    getSeaLevelSunset() {\r\n        const sunset = this.getUTCSeaLevelSunset(AstronomicalCalendar.GEOMETRIC_ZENITH);\r\n        if (Number.isNaN(sunset))\r\n            return null;\r\n        return this.getDateFromTime(sunset, false);\r\n    }\r\n    /**\r\n     * A method that returns the end of civil twilight using a zenith of {@link #CIVIL_ZENITH 96&deg;}.\r\n     *\r\n     * @return The <code>Date</code> of the end of civil twilight using a zenith of {@link #CIVIL_ZENITH 96&deg;}. If\r\n     *         the calculation can't be computed, null will be returned. See detailed explanation on top of the page.\r\n     * @see #CIVIL_ZENITH\r\n     */\r\n    getEndCivilTwilight() {\r\n        return this.getSunsetOffsetByDegrees(AstronomicalCalendar.CIVIL_ZENITH);\r\n    }\r\n    /**\r\n     * A method that returns the end of nautical twilight using a zenith of {@link #NAUTICAL_ZENITH 102&deg;}.\r\n     *\r\n     * @return The <code>Date</code> of the end of nautical twilight using a zenith of {@link #NAUTICAL_ZENITH 102&deg;}\r\n     *         . If the calculation can't be computed, null will be returned. See detailed explanation on top of the\r\n     *         page.\r\n     * @see #NAUTICAL_ZENITH\r\n     */\r\n    getEndNauticalTwilight() {\r\n        return this.getSunsetOffsetByDegrees(AstronomicalCalendar.NAUTICAL_ZENITH);\r\n    }\r\n    /**\r\n     * A method that returns the end of astronomical twilight using a zenith of {@link #ASTRONOMICAL_ZENITH 108&deg;}.\r\n     *\r\n     * @return the <code>Date</code> of the end of astronomical twilight using a zenith of {@link #ASTRONOMICAL_ZENITH\r\n       *         108&deg;}. If the calculation can't be computed, null will be returned. See detailed explanation on top\r\n     *         of the page.\r\n     * @see #ASTRONOMICAL_ZENITH\r\n     */\r\n    getEndAstronomicalTwilight() {\r\n        return this.getSunsetOffsetByDegrees(AstronomicalCalendar.ASTRONOMICAL_ZENITH);\r\n    }\r\n    /**\r\n     * A utility method that returns a date offset by the offset time passed in. Please note that the level of light\r\n     * during twilight is not affected by elevation, so if this is being used to calculate an offset before sunrise or\r\n     * after sunset with the intent of getting a rough \"level of light\" calculation, the sunrise or sunset time passed\r\n     * to this method should be sea level sunrise and sunset.\r\n     *\r\n     * @param time\r\n     *            the start time\r\n     * @param offset\r\n     *            the offset in milliseconds to add to the time.\r\n     * @return the {@link java.util.Date} with the offset in milliseconds added to it\r\n     */\r\n    static getTimeOffset(time, offset) {\r\n        if (time === null || offset === Long_MIN_VALUE || Number.isNaN(offset)) {\r\n            return null;\r\n        }\r\n        return time.plus({ milliseconds: offset });\r\n    }\r\n    /**\r\n     * A utility method that returns the time of an offset by degrees below or above the horizon of\r\n     * {@link #getSunrise() sunrise}. Note that the degree offset is from the vertical, so for a calculation of 14&deg;\r\n     * before sunrise, an offset of 14 + {@link #GEOMETRIC_ZENITH} = 104 would have to be passed as a parameter.\r\n     *\r\n     * @param offsetZenith\r\n     *            the degrees before {@link #getSunrise()} to use in the calculation. For time after sunrise use\r\n     *            negative numbers. Note that the degree offset is from the vertical, so for a calculation of 14&deg;\r\n     *            before sunrise, an offset of 14 + {@link #GEOMETRIC_ZENITH} = 104 would have to be passed as a\r\n     *            parameter.\r\n     * @return The {@link java.util.Date} of the offset after (or before) {@link #getSunrise()}. If the calculation\r\n     *         can't be computed such as in the Arctic Circle where there is at least one day a year where the sun does\r\n     *         not rise, and one where it does not set, a null will be returned. See detailed explanation on top of the\r\n     *         page.\r\n     */\r\n    getSunriseOffsetByDegrees(offsetZenith) {\r\n        const dawn = this.getUTCSunrise(offsetZenith);\r\n        if (Number.isNaN(dawn))\r\n            return null;\r\n        return this.getDateFromTime(dawn, true);\r\n    }\r\n    /**\r\n     * A utility method that returns the time of an offset by degrees below or above the horizon of {@link #getSunset()\r\n       * sunset}. Note that the degree offset is from the vertical, so for a calculation of 14&deg; after sunset, an\r\n     * offset of 14 + {@link #GEOMETRIC_ZENITH} = 104 would have to be passed as a parameter.\r\n     *\r\n     * @param offsetZenith\r\n     *            the degrees after {@link #getSunset()} to use in the calculation. For time before sunset use negative\r\n     *            numbers. Note that the degree offset is from the vertical, so for a calculation of 14&deg; after\r\n     *            sunset, an offset of 14 + {@link #GEOMETRIC_ZENITH} = 104 would have to be passed as a parameter.\r\n     * @return The {@link java.util.Date}of the offset after (or before) {@link #getSunset()}. If the calculation can't\r\n     *         be computed such as in the Arctic Circle where there is at least one day a year where the sun does not\r\n     *         rise, and one where it does not set, a null will be returned. See detailed explanation on top of the\r\n     *         page.\r\n     */\r\n    getSunsetOffsetByDegrees(offsetZenith) {\r\n        const sunset = this.getUTCSunset(offsetZenith);\r\n        if (Number.isNaN(sunset))\r\n            return null;\r\n        return this.getDateFromTime(sunset, false);\r\n    }\r\n    /**\r\n     * A method that returns the sunrise in UTC time without correction for time zone offset from GMT and without using\r\n     * daylight savings time.\r\n     *\r\n     * @param zenith\r\n     *            the degrees below the horizon. For time after sunrise use negative numbers.\r\n     * @return The time in the format: 18.75 for 18:45:00 UTC/GMT. If the calculation can't be computed such as in the\r\n     *         Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does\r\n     *         not set, {@link Double#NaN} will be returned. See detailed explanation on top of the page.\r\n     */\r\n    getUTCSunrise(zenith) {\r\n        return this.getAstronomicalCalculator()\r\n            .getUTCSunrise(this.getAdjustedDate(), this.getGeoLocation(), zenith, true);\r\n    }\r\n    /**\r\n     * A method that returns the sunrise in UTC time without correction for time zone offset from GMT and without using\r\n     * daylight savings time. Non-sunrise and sunset calculations such as dawn and dusk, depend on the amount of visible\r\n     * light, something that is not affected by elevation. This method returns UTC sunrise calculated at sea level. This\r\n     * forms the base for dawn calculations that are calculated as a dip below the horizon before sunrise.\r\n     *\r\n     * @param zenith\r\n     *            the degrees below the horizon. For time after sunrise use negative numbers.\r\n     * @return The time in the format: 18.75 for 18:45:00 UTC/GMT. If the calculation can't be computed such as in the\r\n     *         Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does\r\n     *         not set, {@link Double#NaN} will be returned. See detailed explanation on top of the page.\r\n     * @see AstronomicalCalendar#getUTCSunrise\r\n     * @see AstronomicalCalendar#getUTCSeaLevelSunset\r\n     */\r\n    getUTCSeaLevelSunrise(zenith) {\r\n        return this.getAstronomicalCalculator()\r\n            .getUTCSunrise(this.getAdjustedDate(), this.getGeoLocation(), zenith, false);\r\n    }\r\n    /**\r\n     * A method that returns the sunset in UTC time without correction for time zone offset from GMT and without using\r\n     * daylight savings time.\r\n     *\r\n     * @param zenith\r\n     *            the degrees below the horizon. For time after sunset use negative numbers.\r\n     * @return The time in the format: 18.75 for 18:45:00 UTC/GMT. If the calculation can't be computed such as in the\r\n     *         Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does\r\n     *         not set, {@link Double#NaN} will be returned. See detailed explanation on top of the page.\r\n     * @see AstronomicalCalendar#getUTCSeaLevelSunset\r\n     */\r\n    getUTCSunset(zenith) {\r\n        return this.getAstronomicalCalculator()\r\n            .getUTCSunset(this.getAdjustedDate(), this.getGeoLocation(), zenith, true);\r\n    }\r\n    /**\r\n     * A method that returns the sunset in UTC time without correction for elevation, time zone offset from GMT and\r\n     * without using daylight savings time. Non-sunrise and sunset calculations such as dawn and dusk, depend on the\r\n     * amount of visible light, something that is not affected by elevation. This method returns UTC sunset calculated\r\n     * at sea level. This forms the base for dusk calculations that are calculated as a dip below the horizon after\r\n     * sunset.\r\n     *\r\n     * @param zenith\r\n     *            the degrees below the horizon. For time before sunset use negative numbers.\r\n     * @return The time in the format: 18.75 for 18:45:00 UTC/GMT. If the calculation can't be computed such as in the\r\n     *         Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does\r\n     *         not set, {@link Double#NaN} will be returned. See detailed explanation on top of the page.\r\n     * @see AstronomicalCalendar#getUTCSunset\r\n     * @see AstronomicalCalendar#getUTCSeaLevelSunrise\r\n     */\r\n    getUTCSeaLevelSunset(zenith) {\r\n        return this.getAstronomicalCalculator()\r\n            .getUTCSunset(this.getAdjustedDate(), this.getGeoLocation(), zenith, false);\r\n    }\r\n    /**\r\n     * A method that returns an {@link AstronomicalCalculator#getElevationAdjustment(double) elevation adjusted}\r\n     * temporal (solar) hour. The day from {@link #getSunrise() sunrise} to {@link #getSunset() sunset} is split into 12\r\n     * equal parts with each one being a temporal hour.\r\n     *\r\n     * @see #getSunrise()\r\n     * @see #getSunset()\r\n     * @see #getTemporalHour(Date, Date)\r\n     *\r\n     * @return the <code>long</code> millisecond length of a temporal hour. If the calculation can't be computed,\r\n     *         {@link Long#MIN_VALUE} will be returned. See detailed explanation on top of the page.\r\n     *\r\n     * @see #getTemporalHour(Date, Date)\r\n     */\r\n    /*\r\n        public getTemporalHour(): number {\r\n            return this.getTemporalHour(this.getSeaLevelSunrise(), this.getSeaLevelSunset());\r\n        }\r\n    */\r\n    /**\r\n     * A utility method that will allow the calculation of a temporal (solar) hour based on the sunrise and sunset\r\n     * passed as parameters to this method. An example of the use of this method would be the calculation of a\r\n     * non-elevation adjusted temporal hour by passing in {@link #getSeaLevelSunrise() sea level sunrise} and\r\n     * {@link #getSeaLevelSunset() sea level sunset} as parameters.\r\n     *\r\n     * @param startOfday\r\n     *            The start of the day.\r\n     * @param endOfDay\r\n     *            The end of the day.\r\n     *\r\n     * @return the <code>long</code> millisecond length of the temporal hour. If the calculation can't be computed a\r\n     *         {@link Long#MIN_VALUE} will be returned. See detailed explanation on top of the page.\r\n     *\r\n     * @see #getTemporalHour()\r\n     */\r\n    getTemporalHour(startOfday = this.getSeaLevelSunrise(), endOfDay = this.getSeaLevelSunset()) {\r\n        if (startOfday === null || endOfDay === null) {\r\n            return Long_MIN_VALUE;\r\n        }\r\n        return (endOfDay.valueOf() - startOfday.valueOf()) / 12;\r\n    }\r\n    /**\r\n     * A method that returns sundial or solar noon. It occurs when the Sun is <a href\r\n     * =\"http://en.wikipedia.org/wiki/Transit_%28astronomy%29\">transiting</a> the <a\r\n     * href=\"http://en.wikipedia.org/wiki/Meridian_%28astronomy%29\">celestial meridian</a>. In this class it is\r\n     * calculated as halfway between sea level sunrise and sea level sunset, which can be slightly off the real transit\r\n     * time due to changes in declination (the lengthening or shortening day).\r\n     *\r\n     * @return the <code>Date</code> representing Sun's transit. If the calculation can't be computed such as in the\r\n     *         Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does\r\n     *         not set, null will be returned. See detailed explanation on top of the page.\r\n     * @see #getSunTransit(Date, Date)\r\n     * @see #getTemporalHour()\r\n     */\r\n    /*\r\n        public getSunTransit(): Date {\r\n            return this.getSunTransit(getSeaLevelSunrise(), this.getSeaLevelSunset());\r\n        }\r\n    */\r\n    /**\r\n     * A method that returns sundial or solar noon. It occurs when the Sun is <a href\r\n     * =\"http://en.wikipedia.org/wiki/Transit_%28astronomy%29\">transiting</a> the <a\r\n     * href=\"http://en.wikipedia.org/wiki/Meridian_%28astronomy%29\">celestial meridian</a>. In this class it is\r\n     * calculated as halfway between the sunrise and sunset passed to this method. This time can be slightly off the\r\n     * real transit time due to changes in declination (the lengthening or shortening day).\r\n     *\r\n     * @param startOfDay\r\n     *            the start of day for calculating the sun's transit. This can be sea level sunrise, visual sunrise (or\r\n     *            any arbitrary start of day) passed to this method.\r\n     * @param endOfDay\r\n     *            the end of day for calculating the sun's transit. This can be sea level sunset, visual sunset (or any\r\n     *            arbitrary end of day) passed to this method.\r\n     *\r\n     * @return the <code>Date</code> representing Sun's transit. If the calculation can't be computed such as in the\r\n     *         Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does\r\n     *         not set, null will be returned. See detailed explanation on top of the page.\r\n     */\r\n    getSunTransit(startOfDay = this.getSeaLevelSunrise(), endOfDay = this.getSeaLevelSunset()) {\r\n        const temporalHour = this.getTemporalHour(startOfDay, endOfDay);\r\n        return AstronomicalCalendar.getTimeOffset(startOfDay, temporalHour * 6);\r\n    }\r\n    /**\r\n     * A method that returns a <code>Date</code> from the time passed in as a parameter.\r\n     *\r\n     * @param time\r\n     *            The time to be set as the time for the <code>Date</code>. The time expected is in the format: 18.75\r\n     *            for 6:45:00 PM.\r\n     * @param isSunrise true if the time is sunrise, and false if it is sunset\r\n     * @return The Date.\r\n     */\r\n    getDateFromTime(time, isSunrise) {\r\n        if (Number.isNaN(time)) {\r\n            return null;\r\n        }\r\n        let calculatedTime = time;\r\n        const adjustedDate = this.getAdjustedDate();\r\n        let cal = DateTime.utc(adjustedDate.year, adjustedDate.month, adjustedDate.day);\r\n        const hours = Math.trunc(calculatedTime); // retain only the hours\r\n        calculatedTime -= hours;\r\n        const minutes = Math.trunc(calculatedTime *= 60); // retain only the minutes\r\n        calculatedTime -= minutes;\r\n        const seconds = Math.trunc(calculatedTime *= 60); // retain only the seconds\r\n        calculatedTime -= seconds; // remaining milliseconds\r\n        // Check if a date transition has occurred, or is about to occur - this indicates the date of the event is\r\n        // actually not the target date, but the day prior or after\r\n        const localTimeHours = Math.trunc(this.getGeoLocation().getLongitude() / 15);\r\n        if (isSunrise && localTimeHours + hours > 18) {\r\n            cal = cal.minus({ days: 1 });\r\n        }\r\n        else if (!isSunrise && localTimeHours + hours < 6) {\r\n            cal = cal.plus({ days: 1 });\r\n        }\r\n        return cal.set({\r\n            hour: hours,\r\n            minute: minutes,\r\n            second: seconds,\r\n            millisecond: Math.trunc(calculatedTime * 1000),\r\n        });\r\n    }\r\n    /**\r\n     * Returns the dip below the horizon before sunrise that matches the offset minutes on passed in as a parameter. For\r\n     * example passing in 72 minutes for a calendar set to the equinox in Jerusalem returns a value close to 16.1&deg;\r\n     * Please note that this method is very slow and inefficient and should NEVER be used in a loop. TODO: Improve\r\n     * efficiency.\r\n     *\r\n     * @param minutes\r\n     *            offset\r\n     * @return the degrees below the horizon before sunrise that match the offset in minutes passed it as a parameter.\r\n     * @see #getSunsetSolarDipFromOffset(double)\r\n     */\r\n    getSunriseSolarDipFromOffset(minutes) {\r\n        if (Number.isNaN(minutes))\r\n            return null;\r\n        let offsetByDegrees = this.getSeaLevelSunrise();\r\n        const offsetByTime = AstronomicalCalendar.getTimeOffset(this.getSeaLevelSunrise(), -(minutes * AstronomicalCalendar.MINUTE_MILLIS));\r\n        let degrees = new Big(0);\r\n        const incrementor = new Big('0.0001');\r\n        // If `minutes` is not `NaN` and `offsetByDegrees` is not null, `offsetByTime` should not be null\r\n        while (offsetByDegrees === null || offsetByDegrees.valueOf() > offsetByTime.valueOf()) {\r\n            degrees = degrees.plus(incrementor);\r\n            offsetByDegrees = this.getSunriseOffsetByDegrees(AstronomicalCalendar.GEOMETRIC_ZENITH + Number.parseFloat(degrees.valueOf()));\r\n        }\r\n        return Number.parseFloat(degrees.valueOf());\r\n    }\r\n    /**\r\n     * Returns the dip below the horizon after sunset that matches the offset minutes on passed in as a parameter. For\r\n     * example passing in 72 minutes for a calendar set to the equinox in Jerusalem returns a value close to 16.1&deg;\r\n     * Please note that this method is very slow and inefficient and should NEVER be used in a loop. TODO: Improve\r\n     * efficiency.\r\n     *\r\n     * @param minutes\r\n     *            offset\r\n     * @return the degrees below the horizon after sunset that match the offset in minutes passed it as a parameter.\r\n     * @see #getSunriseSolarDipFromOffset(double)\r\n     */\r\n    getSunsetSolarDipFromOffset(minutes) {\r\n        if (Number.isNaN(minutes))\r\n            return null;\r\n        let offsetByDegrees = this.getSeaLevelSunset();\r\n        const offsetByTime = AstronomicalCalendar.getTimeOffset(this.getSeaLevelSunset(), minutes * AstronomicalCalendar.MINUTE_MILLIS);\r\n        let degrees = new Big(0);\r\n        const incrementor = new Big('0.001');\r\n        // If `minutes` is not `NaN` and `offsetByDegrees` is not null, `offsetByTime` should not be null\r\n        while (offsetByDegrees === null || offsetByDegrees < offsetByTime) {\r\n            degrees = degrees.plus(incrementor);\r\n            offsetByDegrees = this.getSunsetOffsetByDegrees(AstronomicalCalendar.GEOMETRIC_ZENITH + Number.parseFloat(degrees.valueOf()));\r\n        }\r\n        return Number.parseFloat(degrees.valueOf());\r\n    }\r\n    /**\r\n     * Adjusts the <code>Calendar</code> to deal with edge cases where the location crosses the antimeridian.\r\n     *\r\n     * @see GeoLocation#getAntimeridianAdjustment()\r\n     * @return the adjusted Calendar\r\n     */\r\n    getAdjustedDate() {\r\n        const offset = this.getGeoLocation().getAntimeridianAdjustment();\r\n        if (offset === 0)\r\n            return this.getDate();\r\n        return this.getDate().plus({ days: offset });\r\n    }\r\n    /**\r\n     * @return an XML formatted representation of the class. It returns the default output of the\r\n     *         {@link net.sourceforge.zmanim.util.ZmanimFormatter#toXML(AstronomicalCalendar) toXML} method.\r\n     * @see net.sourceforge.zmanim.util.ZmanimFormatter#toXML(AstronomicalCalendar)\r\n     * @see java.lang.Object#toString()\r\n     * @deprecated (This depends on a circular dependency).\r\n     */\r\n    // eslint-disable-next-line class-methods-use-this\r\n    toString() {\r\n        throw new UnsupportedError('This method is unsupported, due to the fact that it depends on a circular dependency.');\r\n    }\r\n    /**\r\n     * @return a JSON formatted representation of the class. It returns the default output of the\r\n     *         {@link net.sourceforge.zmanim.util.ZmanimFormatter#toJSON(AstronomicalCalendar) toJSON} method.\r\n     * @see net.sourceforge.zmanim.util.ZmanimFormatter#toJSON(AstronomicalCalendar)\r\n     * @see java.lang.Object#toString()\r\n     * @deprecated  This depends on a circular dependency. Use <pre>ZmanimFormatter.toJSON(astronomicalCalendar)</pre> instead.\r\n     */\r\n    // eslint-disable-next-line class-methods-use-this\r\n    toJSON() {\r\n        throw new UnsupportedError('This method is unsupported, due to the fact that it depends on a circular dependency. '\r\n            + 'Use `ZmanimFormatter.toJSON(astronomicalCalendar)` instead.');\r\n    }\r\n    /**\r\n     * @see java.lang.Object#equals(Object)\r\n     */\r\n    equals(object) {\r\n        if (this === object) {\r\n            return true;\r\n        }\r\n        if (!(object instanceof AstronomicalCalendar)) {\r\n            return false;\r\n        }\r\n        const aCal = object;\r\n        return this.getDate().equals(aCal.getDate()) && this.getGeoLocation().equals(aCal.getGeoLocation())\r\n            && this.getAstronomicalCalculator() === aCal.getAstronomicalCalculator();\r\n    }\r\n    /**\r\n     * A method that returns the currently set {@link GeoLocation} which contains location information used for the\r\n     * astronomical calculations.\r\n     *\r\n     * @return Returns the geoLocation.\r\n     */\r\n    getGeoLocation() {\r\n        return this.geoLocation;\r\n    }\r\n    /**\r\n     * Sets the {@link GeoLocation} <code>Object</code> to be used for astronomical calculations.\r\n     *\r\n     * @param geoLocation\r\n     *            The geoLocation to set.\r\n     */\r\n    setGeoLocation(geoLocation) {\r\n        this.geoLocation = geoLocation;\r\n        this.date = this.date.setZone(geoLocation.getTimeZone());\r\n    }\r\n    /**\r\n     * A method that returns the currently set AstronomicalCalculator.\r\n     *\r\n     * @return Returns the astronomicalCalculator.\r\n     * @see #setAstronomicalCalculator(AstronomicalCalculator)\r\n     */\r\n    getAstronomicalCalculator() {\r\n        return this.astronomicalCalculator;\r\n    }\r\n    /**\r\n     * A method to set the {@link AstronomicalCalculator} used for astronomical calculations. The Zmanim package ships\r\n     * with a number of different implementations of the <code>abstract</code> {@link AstronomicalCalculator} based on\r\n     * different algorithms, including {@link net.sourceforge.zmanim.util.SunTimesCalculator one implementation} based\r\n     * on the <a href = \"http://aa.usno.navy.mil/\">US Naval Observatory's</a> algorithm, and\r\n     * {@link net.sourceforge.zmanim.util.NOAACalculator another} based on <a href=\"http://noaa.gov\">NOAA's</a>\r\n     * algorithm. This allows easy runtime switching and comparison of different algorithms.\r\n     *\r\n     * @param astronomicalCalculator\r\n     *            The astronomicalCalculator to set.\r\n     */\r\n    setAstronomicalCalculator(astronomicalCalculator) {\r\n        this.astronomicalCalculator = astronomicalCalculator;\r\n    }\r\n    /**\r\n     * returns the Calendar object encapsulated in this class.\r\n     *\r\n     * @return Returns the calendar.\r\n     */\r\n    getDate() {\r\n        return this.date;\r\n    }\r\n    /**\r\n     * @param calendar\r\n     *            The calendar to set.\r\n     */\r\n    setDate(date) {\r\n        if (DateTime.isDateTime(date)) {\r\n            this.date = date;\r\n        }\r\n        else if (date instanceof Date) {\r\n            this.date = DateTime.fromJSDate(date);\r\n        }\r\n        else if (typeof date === 'string') {\r\n            this.date = DateTime.fromISO(date);\r\n        }\r\n        else if (typeof date === 'number') {\r\n            this.date = DateTime.fromMillis(date);\r\n        }\r\n    }\r\n    /**\r\n     * A method that creates a <a href=\"http://en.wikipedia.org/wiki/Object_copy#Deep_copy\">deep copy</a> of the object.\r\n     * <b>Note:</b> If the {@link java.util.TimeZone} in the cloned {@link net.sourceforge.zmanim.util.GeoLocation} will\r\n     * be changed from the original, it is critical that\r\n     * {@link net.sourceforge.zmanim.AstronomicalCalendar#getCalendar()}.\r\n     * {@link java.util.Calendar#setTimeZone(TimeZone) setTimeZone(TimeZone)} be called in order for the\r\n     * AstronomicalCalendar to output times in the expected offset after being cloned.\r\n     *\r\n     * @see java.lang.Object#clone()\r\n     * @since 1.1\r\n     */\r\n    clone() {\r\n        const clonedCalendar = new AstronomicalCalendar();\r\n        clonedCalendar.setDate(this.date);\r\n        clonedCalendar.setAstronomicalCalculator(this.astronomicalCalculator);\r\n        clonedCalendar.setGeoLocation(this.geoLocation);\r\n        return clonedCalendar;\r\n    }\r\n    // eslint-disable-next-line class-methods-use-this\r\n    getClassName() {\r\n        return 'net.sourceforge.zmanim.AstronomicalCalendar';\r\n    }\r\n}\r\n/**\r\n * 90&deg; below the vertical. Used as a basis for most calculations since the location of the sun is 90&deg; below\r\n * the horizon at sunrise and sunset.\r\n * <b>Note </b>: it is important to note that for sunrise and sunset the {@link AstronomicalCalculator#adjustZenith\r\n   * adjusted zenith} is required to account for the radius of the sun and refraction. The adjusted zenith should not\r\n * be used for calculations above or below 90&deg; since they are usually calculated as an offset to 90&deg;.\r\n */\r\nAstronomicalCalendar.GEOMETRIC_ZENITH = 90;\r\n/**\r\n * Default value for Sun's zenith and true rise/set Zenith (used in this class and subclasses) is the angle that the\r\n * center of the Sun makes to a line perpendicular to the Earth's surface. If the Sun were a point and the Earth\r\n * were without an atmosphere, true sunset and sunrise would correspond to a 90&deg; zenith. Because the Sun is not\r\n * a point, and because the atmosphere refracts light, this 90&deg; zenith does not, in fact, correspond to true\r\n * sunset or sunrise, instead the center of the Sun's disk must lie just below the horizon for the upper edge to be\r\n * obscured. This means that a zenith of just above 90&deg; must be used. The Sun subtends an angle of 16 minutes of\r\n * arc (this can be changed via the {@link #setSunRadius(double)} method , and atmospheric refraction accounts for\r\n * 34 minutes or so (this can be changed via the {@link #setRefraction(double)} method), giving a total of 50\r\n * arcminutes. The total value for ZENITH is 90+(5/6) or 90.8333333&deg; for true sunrise/sunset.\r\n */\r\n// const ZENITH: number = GEOMETRIC_ZENITH + 5.0 / 6.0;\r\n/** Sun's zenith at civil twilight (96&deg;). */\r\nAstronomicalCalendar.CIVIL_ZENITH = 96;\r\n/** Sun's zenith at nautical twilight (102&deg;). */\r\nAstronomicalCalendar.NAUTICAL_ZENITH = 102;\r\n/** Sun's zenith at astronomical twilight (108&deg;). */\r\nAstronomicalCalendar.ASTRONOMICAL_ZENITH = 108;\r\n/** constant for milliseconds in a minute (60,000) */\r\nAstronomicalCalendar.MINUTE_MILLIS = 60 * 1000;\r\n/** constant for milliseconds in an hour (3,600,000) */\r\nAstronomicalCalendar.HOUR_MILLIS = AstronomicalCalendar.MINUTE_MILLIS * 60;\r\n//# sourceMappingURL=AstronomicalCalendar.js.map"]},"metadata":{},"sourceType":"module"}