{"ast":null,"code":"import { MathUtils } from '../polyfills/Utils';\n/**\r\n * A class for various location calculations\r\n * Most of the code in this class is ported from <a href=\"http://www.movable-type.co.uk/\">Chris Veness'</a>\r\n * <a href=\"http://www.fsf.org/licensing/licenses/lgpl.html\">LGPL</a> Javascript Implementation\r\n *\r\n * @author &copy; Eliyahu Hershfeld 2009 - 2019\r\n */\n\nexport class GeoLocationUtils {\n  /**\r\n   * Calculate the <a href=\"http://en.wikipedia.org/wiki/Great_circle\">geodesic</a> initial bearing between this Object and\r\n   * a second Object passed to this method using <a href=\"http://en.wikipedia.org/wiki/Thaddeus_Vincenty\">Thaddeus\r\n   * Vincenty's</a> inverse formula See T Vincenty, \"<a href=\"http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf\">Direct and\r\n   * Inverse Solutions of Geodesics on the Ellipsoid with application of nested equations</a>\", Survey Review, vol XXII\r\n   * no 176, 1975.\r\n   *\r\n   * @param location\r\n   *            the initial location\r\n   * @param destination\r\n   *            the destination location\r\n   * @return the geodesic bearing\r\n   */\n  static getGeodesicInitialBearing(location, destination) {\n    return GeoLocationUtils.vincentyFormula(location, destination, GeoLocationUtils.INITIAL_BEARING);\n  }\n  /**\r\n   * Calculate the <a href=\"http://en.wikipedia.org/wiki/Great_circle\">geodesic</a> final bearing between this Object\r\n   * and a second Object passed to this method using <a href=\"http://en.wikipedia.org/wiki/Thaddeus_Vincenty\">Thaddeus Vincenty's</a>\r\n   * inverse formula See T Vincenty, \"<a href=\"http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf\">Direct and Inverse Solutions of Geodesics\r\n   * on the Ellipsoid with application of nested equations</a>\", Survey Review, vol XXII no 176, 1975.\r\n   *\r\n   * @param location\r\n   *            the initial location\r\n   * @param destination\r\n   *            the destination location\r\n   * @return the geodesic bearing\r\n   */\n\n\n  static getGeodesicFinalBearing(location, destination) {\n    return GeoLocationUtils.vincentyFormula(location, destination, GeoLocationUtils.FINAL_BEARING);\n  }\n  /**\r\n   * Calculate <a href=\"http://en.wikipedia.org/wiki/Great-circle_distance\">geodesic distance</a> in Meters\r\n   * between this Object and a second Object passed to this method using <a\r\n   * href=\"http://en.wikipedia.org/wiki/Thaddeus_Vincenty\">Thaddeus Vincenty's</a> inverse formula See T Vincenty,\r\n   * \"<a href=\"http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf\">Direct and Inverse Solutions of Geodesics on the\r\n   * Ellipsoid with application of nested equations</a>\", Survey Review, vol XXII no 176, 1975. This uses the\r\n   * WGS-84 geodetic model.\r\n   * @param location\r\n   *            the initial location\r\n   * @param destination\r\n   *            the destination location\r\n   * @return the geodesic distance in Meters\r\n   */\n\n\n  static getGeodesicDistance(location, destination) {\n    return GeoLocationUtils.vincentyFormula(location, destination, GeoLocationUtils.DISTANCE);\n  }\n  /**\r\n   * Calculates the initial <a href=\"http://en.wikipedia.org/wiki/Great_circle\">geodesic</a> bearing, final bearing or\r\n   * <a href=\"http://en.wikipedia.org/wiki/Great-circle_distance\">geodesic distance</a> using <a href=\r\n   * \"http://en.wikipedia.org/wiki/Thaddeus_Vincenty\">Thaddeus Vincenty's</a> inverse formula See T Vincenty, \"<a\r\n   * href=\"http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf\">Direct and Inverse Solutions of Geodesics on the Ellipsoid\r\n   * with application of nested equations</a>\", Survey Review, vol XXII no 176, 1975.\r\n   *\r\n   * @param location\r\n   *            the initial location\r\n   * @param destination\r\n   *            the destination location\r\n   * @param formula\r\n   *            This formula calculates initial bearing ({@link #INITIAL_BEARING}),\r\n   *            final bearing ({@link #FINAL_BEARING}) and distance ({@link #DISTANCE}).\r\n   * @return\r\n   *            the geodesic distance, initial or final bearing (based on the formula passed in) between the location\r\n   *            and destination in Meters\r\n   * @see #getGeodesicDistance(GeoLocation, GeoLocation)\r\n   * @see #getGeodesicInitialBearing(GeoLocation, GeoLocation)\r\n   * @see #getGeodesicFinalBearing(GeoLocation, GeoLocation)\r\n   */\n\n\n  static vincentyFormula(location, destination, formula) {\n    const a = 6378137; // length of semi-major axis of the ellipsoid (radius at equator) in metres based on WGS-84\n\n    const b = 6356752.3142; // length of semi-minor axis of the ellipsoid (radius at the poles) in meters based on WGS-84\n\n    const f = 1 / 298.257223563; // flattening of the ellipsoid based on WGS-84\n\n    const L = MathUtils.degreesToRadians(destination.getLongitude() - location.getLongitude()); // difference in longitude of two points;\n\n    const U1 = Math.atan((1 - f) * Math.tan(MathUtils.degreesToRadians(location.getLatitude()))); // reduced latitude (latitude on the auxiliary sphere)\n\n    const U2 = Math.atan((1 - f) * Math.tan(MathUtils.degreesToRadians(destination.getLatitude()))); // reduced latitude (latitude on the auxiliary sphere)\n\n    const sinU1 = Math.sin(U1);\n    const cosU1 = Math.cos(U1);\n    const sinU2 = Math.sin(U2);\n    const cosU2 = Math.cos(U2);\n    let lambda = L;\n    let lambdaP = 2 * Math.PI;\n    let iterLimit = 20;\n    let sinLambda = 0;\n    let cosLambda = 0;\n    let sinSigma = 0;\n    let cosSigma = 0;\n    let sigma = 0;\n    let sinAlpha = 0;\n    let cosSqAlpha = 0;\n    let cos2SigmaM = 0;\n    let C;\n\n    while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0) {\n      sinLambda = Math.sin(lambda);\n      cosLambda = Math.cos(lambda);\n      sinSigma = Math.sqrt(cosU2 * sinLambda * (cosU2 * sinLambda) + (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));\n      if (sinSigma === 0) return 0; // co-incident points\n\n      cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;\n      sigma = Math.atan2(sinSigma, cosSigma);\n      sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;\n      cosSqAlpha = 1 - sinAlpha * sinAlpha;\n      cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;\n      if (Number.isNaN(cos2SigmaM)) cos2SigmaM = 0; // equatorial line: cosSqAlpha=0 (§6)\n\n      C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));\n      lambdaP = lambda;\n      lambda = L + (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));\n    }\n\n    if (iterLimit === 0) return Number.NaN; // formula failed to converge\n\n    const uSq = cosSqAlpha * (a * a - b * b) / (b * b);\n    const A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));\n    const B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));\n    const deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));\n    const distance = b * A * (sigma - deltaSigma); // initial bearing\n\n    const fwdAz = MathUtils.radiansToDegrees(Math.atan2(cosU2 * sinLambda, cosU1 * sinU2 - sinU1 * cosU2 * cosLambda)); // final bearing\n\n    const revAz = MathUtils.radiansToDegrees(Math.atan2(cosU1 * sinLambda, -sinU1 * cosU2 + cosU1 * sinU2 * cosLambda));\n\n    if (formula === GeoLocationUtils.DISTANCE) {\n      return distance;\n    } else if (formula === GeoLocationUtils.INITIAL_BEARING) {\n      return fwdAz;\n    } else if (formula === GeoLocationUtils.FINAL_BEARING) {\n      return revAz;\n    } // should never happen\n\n\n    return Number.NaN;\n  }\n  /**\r\n   * Returns the <a href=\"http://en.wikipedia.org/wiki/Rhumb_line\">rhumb line</a>\r\n   * bearing from the current location to the GeoLocation passed in.\r\n   *\r\n   * @param location\r\n   *            the initial location\r\n   * @param destination\r\n   *            the destination location\r\n   * @return the bearing in degrees\r\n   */\n\n\n  static getRhumbLineBearing(location, destination) {\n    let dLon = MathUtils.degreesToRadians(destination.getLongitude() - location.getLongitude());\n    const dPhi = Math.log(Math.tan(MathUtils.degreesToRadians(destination.getLatitude()) / 2 + Math.PI / 4) / Math.tan(MathUtils.degreesToRadians(location.getLatitude()) / 2 + Math.PI / 4));\n    if (Math.abs(dLon) > Math.PI) dLon = dLon > 0 ? -(2 * Math.PI - dLon) : 2 * Math.PI + dLon;\n    return MathUtils.radiansToDegrees(Math.atan2(dLon, dPhi));\n  }\n  /**\r\n   * Returns the <a href=\"http://en.wikipedia.org/wiki/Rhumb_line\">rhumb line</a> distance from the current\r\n   * location to the GeoLocation passed in. Ported from <a href=\"http://www.movable-type.co.uk/\">Chris Veness'</a>\r\n   * Javascript Implementation.\r\n   *\r\n   * @param location\r\n   *            the initial location\r\n   * @param destination\r\n   *            the destination location\r\n   * @return the distance in Meters\r\n   */\n\n\n  static getRhumbLineDistance(location, destination) {\n    const earthRadius = 6378137; // earth's mean radius in km\n\n    const dLat = MathUtils.degreesToRadians(location.getLatitude()) - MathUtils.degreesToRadians(destination.getLatitude());\n    let dLon = Math.abs(MathUtils.degreesToRadians(location.getLongitude()) - MathUtils.degreesToRadians(destination.getLongitude()));\n    const dPhi = Math.log(Math.tan(MathUtils.degreesToRadians(location.getLatitude()) / 2 + Math.PI / 4) / Math.tan(MathUtils.degreesToRadians(destination.getLatitude()) / 2 + Math.PI / 4));\n    let q = dLat / dPhi;\n\n    if (!Number.isFinite(q)) {\n      q = Math.cos(MathUtils.degreesToRadians(destination.getLatitude()));\n    } // if dLon over 180° take shorter rhumb across 180° meridian:\n\n\n    if (dLon > Math.PI) {\n      dLon = 2 * Math.PI - dLon;\n    }\n\n    const d = Math.sqrt(dLat * dLat + q * q * dLon * dLon);\n    return d * earthRadius;\n  }\n\n}\nGeoLocationUtils.DISTANCE = 0;\nGeoLocationUtils.INITIAL_BEARING = 1;\nGeoLocationUtils.FINAL_BEARING = 2;","map":{"version":3,"sources":["../../../src/util/GeoLocationUtils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { MathUtils } from '../polyfills/Utils';\r\n/**\r\n * A class for various location calculations\r\n * Most of the code in this class is ported from <a href=\"http://www.movable-type.co.uk/\">Chris Veness'</a>\r\n * <a href=\"http://www.fsf.org/licensing/licenses/lgpl.html\">LGPL</a> Javascript Implementation\r\n *\r\n * @author &copy; Eliyahu Hershfeld 2009 - 2019\r\n */\r\nexport class GeoLocationUtils {\r\n    /**\r\n     * Calculate the <a href=\"http://en.wikipedia.org/wiki/Great_circle\">geodesic</a> initial bearing between this Object and\r\n     * a second Object passed to this method using <a href=\"http://en.wikipedia.org/wiki/Thaddeus_Vincenty\">Thaddeus\r\n     * Vincenty's</a> inverse formula See T Vincenty, \"<a href=\"http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf\">Direct and\r\n     * Inverse Solutions of Geodesics on the Ellipsoid with application of nested equations</a>\", Survey Review, vol XXII\r\n     * no 176, 1975.\r\n     *\r\n     * @param location\r\n     *            the initial location\r\n     * @param destination\r\n     *            the destination location\r\n     * @return the geodesic bearing\r\n     */\r\n    static getGeodesicInitialBearing(location, destination) {\r\n        return GeoLocationUtils.vincentyFormula(location, destination, GeoLocationUtils.INITIAL_BEARING);\r\n    }\r\n    /**\r\n     * Calculate the <a href=\"http://en.wikipedia.org/wiki/Great_circle\">geodesic</a> final bearing between this Object\r\n     * and a second Object passed to this method using <a href=\"http://en.wikipedia.org/wiki/Thaddeus_Vincenty\">Thaddeus Vincenty's</a>\r\n     * inverse formula See T Vincenty, \"<a href=\"http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf\">Direct and Inverse Solutions of Geodesics\r\n     * on the Ellipsoid with application of nested equations</a>\", Survey Review, vol XXII no 176, 1975.\r\n     *\r\n     * @param location\r\n     *            the initial location\r\n     * @param destination\r\n     *            the destination location\r\n     * @return the geodesic bearing\r\n     */\r\n    static getGeodesicFinalBearing(location, destination) {\r\n        return GeoLocationUtils.vincentyFormula(location, destination, GeoLocationUtils.FINAL_BEARING);\r\n    }\r\n    /**\r\n     * Calculate <a href=\"http://en.wikipedia.org/wiki/Great-circle_distance\">geodesic distance</a> in Meters\r\n     * between this Object and a second Object passed to this method using <a\r\n     * href=\"http://en.wikipedia.org/wiki/Thaddeus_Vincenty\">Thaddeus Vincenty's</a> inverse formula See T Vincenty,\r\n     * \"<a href=\"http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf\">Direct and Inverse Solutions of Geodesics on the\r\n     * Ellipsoid with application of nested equations</a>\", Survey Review, vol XXII no 176, 1975. This uses the\r\n     * WGS-84 geodetic model.\r\n     * @param location\r\n     *            the initial location\r\n     * @param destination\r\n     *            the destination location\r\n     * @return the geodesic distance in Meters\r\n     */\r\n    static getGeodesicDistance(location, destination) {\r\n        return GeoLocationUtils.vincentyFormula(location, destination, GeoLocationUtils.DISTANCE);\r\n    }\r\n    /**\r\n     * Calculates the initial <a href=\"http://en.wikipedia.org/wiki/Great_circle\">geodesic</a> bearing, final bearing or\r\n     * <a href=\"http://en.wikipedia.org/wiki/Great-circle_distance\">geodesic distance</a> using <a href=\r\n     * \"http://en.wikipedia.org/wiki/Thaddeus_Vincenty\">Thaddeus Vincenty's</a> inverse formula See T Vincenty, \"<a\r\n     * href=\"http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf\">Direct and Inverse Solutions of Geodesics on the Ellipsoid\r\n     * with application of nested equations</a>\", Survey Review, vol XXII no 176, 1975.\r\n     *\r\n     * @param location\r\n     *            the initial location\r\n     * @param destination\r\n     *            the destination location\r\n     * @param formula\r\n     *            This formula calculates initial bearing ({@link #INITIAL_BEARING}),\r\n     *            final bearing ({@link #FINAL_BEARING}) and distance ({@link #DISTANCE}).\r\n     * @return\r\n     *            the geodesic distance, initial or final bearing (based on the formula passed in) between the location\r\n     *            and destination in Meters\r\n     * @see #getGeodesicDistance(GeoLocation, GeoLocation)\r\n     * @see #getGeodesicInitialBearing(GeoLocation, GeoLocation)\r\n     * @see #getGeodesicFinalBearing(GeoLocation, GeoLocation)\r\n     */\r\n    static vincentyFormula(location, destination, formula) {\r\n        const a = 6378137; // length of semi-major axis of the ellipsoid (radius at equator) in metres based on WGS-84\r\n        const b = 6356752.3142; // length of semi-minor axis of the ellipsoid (radius at the poles) in meters based on WGS-84\r\n        const f = 1 / 298.257223563; // flattening of the ellipsoid based on WGS-84\r\n        const L = MathUtils.degreesToRadians(destination.getLongitude() - location.getLongitude()); // difference in longitude of two points;\r\n        const U1 = Math.atan((1 - f) * Math.tan(MathUtils.degreesToRadians(location.getLatitude()))); // reduced latitude (latitude on the auxiliary sphere)\r\n        const U2 = Math.atan((1 - f) * Math.tan(MathUtils.degreesToRadians(destination.getLatitude()))); // reduced latitude (latitude on the auxiliary sphere)\r\n        const sinU1 = Math.sin(U1);\r\n        const cosU1 = Math.cos(U1);\r\n        const sinU2 = Math.sin(U2);\r\n        const cosU2 = Math.cos(U2);\r\n        let lambda = L;\r\n        let lambdaP = 2 * Math.PI;\r\n        let iterLimit = 20;\r\n        let sinLambda = 0;\r\n        let cosLambda = 0;\r\n        let sinSigma = 0;\r\n        let cosSigma = 0;\r\n        let sigma = 0;\r\n        let sinAlpha = 0;\r\n        let cosSqAlpha = 0;\r\n        let cos2SigmaM = 0;\r\n        let C;\r\n        while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0) {\r\n            sinLambda = Math.sin(lambda);\r\n            cosLambda = Math.cos(lambda);\r\n            sinSigma = Math.sqrt((cosU2 * sinLambda) * (cosU2 * sinLambda)\r\n                + (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda)\r\n                    * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));\r\n            if (sinSigma === 0)\r\n                return 0; // co-incident points\r\n            cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;\r\n            sigma = Math.atan2(sinSigma, cosSigma);\r\n            sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;\r\n            cosSqAlpha = 1 - sinAlpha * sinAlpha;\r\n            cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;\r\n            if (Number.isNaN(cos2SigmaM))\r\n                cos2SigmaM = 0; // equatorial line: cosSqAlpha=0 (§6)\r\n            C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));\r\n            lambdaP = lambda;\r\n            lambda = L + (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));\r\n        }\r\n        if (iterLimit === 0)\r\n            return Number.NaN; // formula failed to converge\r\n        const uSq = cosSqAlpha * (a * a - b * b) / (b * b);\r\n        const A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));\r\n        const B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));\r\n        const deltaSigma = B * sinSigma * (cos2SigmaM + B / 4\r\n            * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM\r\n                * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));\r\n        const distance = b * A * (sigma - deltaSigma);\r\n        // initial bearing\r\n        const fwdAz = MathUtils.radiansToDegrees(Math.atan2(cosU2 * sinLambda, cosU1\r\n            * sinU2 - sinU1 * cosU2 * cosLambda));\r\n        // final bearing\r\n        const revAz = MathUtils.radiansToDegrees(Math.atan2(cosU1 * sinLambda, -sinU1\r\n            * cosU2 + cosU1 * sinU2 * cosLambda));\r\n        if (formula === GeoLocationUtils.DISTANCE) {\r\n            return distance;\r\n        }\r\n        else if (formula === GeoLocationUtils.INITIAL_BEARING) {\r\n            return fwdAz;\r\n        }\r\n        else if (formula === GeoLocationUtils.FINAL_BEARING) {\r\n            return revAz;\r\n        }\r\n        // should never happen\r\n        return Number.NaN;\r\n    }\r\n    /**\r\n     * Returns the <a href=\"http://en.wikipedia.org/wiki/Rhumb_line\">rhumb line</a>\r\n     * bearing from the current location to the GeoLocation passed in.\r\n     *\r\n     * @param location\r\n     *            the initial location\r\n     * @param destination\r\n     *            the destination location\r\n     * @return the bearing in degrees\r\n     */\r\n    static getRhumbLineBearing(location, destination) {\r\n        let dLon = MathUtils.degreesToRadians(destination.getLongitude() - location.getLongitude());\r\n        const dPhi = Math.log(Math.tan(MathUtils.degreesToRadians(destination.getLatitude())\r\n            / 2 + Math.PI / 4)\r\n            / Math.tan(MathUtils.degreesToRadians(location.getLatitude()) / 2 + Math.PI / 4));\r\n        if (Math.abs(dLon) > Math.PI)\r\n            dLon = dLon > 0 ? -(2 * Math.PI - dLon) : (2 * Math.PI + dLon);\r\n        return MathUtils.radiansToDegrees(Math.atan2(dLon, dPhi));\r\n    }\r\n    /**\r\n     * Returns the <a href=\"http://en.wikipedia.org/wiki/Rhumb_line\">rhumb line</a> distance from the current\r\n     * location to the GeoLocation passed in. Ported from <a href=\"http://www.movable-type.co.uk/\">Chris Veness'</a>\r\n     * Javascript Implementation.\r\n     *\r\n     * @param location\r\n     *            the initial location\r\n     * @param destination\r\n     *            the destination location\r\n     * @return the distance in Meters\r\n     */\r\n    static getRhumbLineDistance(location, destination) {\r\n        const earthRadius = 6378137; // earth's mean radius in km\r\n        const dLat = MathUtils.degreesToRadians(location.getLatitude())\r\n            - MathUtils.degreesToRadians(destination.getLatitude());\r\n        let dLon = Math.abs(MathUtils.degreesToRadians(location.getLongitude())\r\n            - MathUtils.degreesToRadians(destination.getLongitude()));\r\n        const dPhi = Math.log(Math.tan(MathUtils.degreesToRadians(location.getLatitude()) / 2 + Math.PI / 4)\r\n            / Math.tan(MathUtils.degreesToRadians(destination.getLatitude()) / 2 + Math.PI / 4));\r\n        let q = dLat / dPhi;\r\n        if (!Number.isFinite(q)) {\r\n            q = Math.cos(MathUtils.degreesToRadians(destination.getLatitude()));\r\n        }\r\n        // if dLon over 180° take shorter rhumb across 180° meridian:\r\n        if (dLon > Math.PI) {\r\n            dLon = 2 * Math.PI - dLon;\r\n        }\r\n        const d = Math.sqrt(dLat * dLat + q * q * dLon * dLon);\r\n        return d * earthRadius;\r\n    }\r\n}\r\nGeoLocationUtils.DISTANCE = 0;\r\nGeoLocationUtils.INITIAL_BEARING = 1;\r\nGeoLocationUtils.FINAL_BEARING = 2;\r\n//# sourceMappingURL=GeoLocationUtils.js.map"]},"metadata":{},"sourceType":"module"}