{"ast":null,"code":"import _classCallCheck from \"C:\\\\react\\\\my-app\\\\frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\react\\\\my-app\\\\frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { DateTime } from 'luxon';\nimport { MathUtils, TimeZone } from '../polyfills/Utils';\nimport { IllegalArgumentException, UnsupportedError } from '../polyfills/errors';\n/**\r\n * A class that contains location information such as latitude and longitude required for astronomical calculations. The\r\n * elevation field may not be used by some calculation engines and would be ignored if set. Check the documentation for\r\n * specific implementations of the {@link AstronomicalCalculator} to see if elevation is calculated as part of the\r\n * algorithm.\r\n *\r\n * @author &copy; Eliyahu Hershfeld 2004 - 2016\r\n * @version 1.1\r\n */\n\nexport var GeoLocation = /*#__PURE__*/function () {\n  function GeoLocation() {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Greenwich, England';\n    var latitude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 51.4772;\n    var longitude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var elevationOrTimeZoneId = arguments.length > 3 ? arguments[3] : undefined;\n    var timeZoneId = arguments.length > 4 ? arguments[4] : undefined;\n\n    _classCallCheck(this, GeoLocation);\n\n    this.locationName = null;\n    var elevation = 0;\n\n    if (timeZoneId) {\n      elevation = elevationOrTimeZoneId;\n    } else {\n      timeZoneId = elevationOrTimeZoneId;\n    }\n\n    this.setLocationName(name);\n    this.setLatitude(latitude);\n    this.setLongitude(longitude);\n    this.setElevation(elevation);\n    this.setTimeZone(timeZoneId);\n  }\n  /**\r\n   * Method to get the elevation in Meters.\r\n   *\r\n   * @return Returns the elevation in Meters.\r\n   */\n\n\n  _createClass(GeoLocation, [{\n    key: \"getElevation\",\n    value: function getElevation() {\n      return this.elevation;\n    }\n    /**\r\n     * Method to set the elevation in Meters <b>above </b> sea level.\r\n     *\r\n     * @param elevation\r\n     *            The elevation to set in Meters. An IllegalArgumentException will be thrown if the value is a negative.\r\n     */\n\n  }, {\n    key: \"setElevation\",\n    value: function setElevation(elevation) {\n      if (elevation < 0) {\n        throw new IllegalArgumentException('Elevation cannot be negative');\n      }\n\n      this.elevation = elevation;\n    }\n  }, {\n    key: \"setLatitude\",\n    value: function setLatitude(degreesOrLatitude, minutes, seconds, direction) {\n      if (!minutes) {\n        var latitude = degreesOrLatitude;\n\n        if (latitude > 90 || latitude < -90) {\n          throw new IllegalArgumentException('Latitude must be between -90 and  90');\n        }\n\n        this.latitude = latitude;\n      } else {\n        var degrees = degreesOrLatitude;\n        var tempLat = degrees + (minutes + seconds / 60) / 60;\n\n        if (tempLat > 90 || tempLat < 0) {\n          // FIXME An exception should be thrown if degrees, minutes or seconds are negative\n          throw new IllegalArgumentException('Latitude must be between 0 and  90. Use direction of S instead of negative.');\n        }\n\n        if (direction === 'S') {\n          tempLat *= -1;\n        } else if (!(direction === 'N')) {\n          throw new IllegalArgumentException('Latitude direction must be N or S');\n        }\n\n        this.latitude = tempLat;\n      }\n    }\n    /**\r\n     * @return Returns the latitude.\r\n     */\n\n  }, {\n    key: \"getLatitude\",\n    value: function getLatitude() {\n      return this.latitude;\n    }\n  }, {\n    key: \"setLongitude\",\n    value: function setLongitude(degreesOrLongitude, minutes, seconds, direction) {\n      if (!minutes) {\n        var longitude = degreesOrLongitude;\n\n        if (longitude > 180 || longitude < -180) {\n          throw new IllegalArgumentException('Longitude must be between -180 and  180');\n        }\n\n        this.longitude = longitude;\n      } else {\n        var degrees = degreesOrLongitude;\n        var longTemp = degrees + (minutes + seconds / 60) / 60;\n\n        if (longTemp > 180 || this.longitude < 0) {\n          // FIXME An exception should be thrown if degrees, minutes or seconds are negative\n          throw new IllegalArgumentException('Longitude must be between 0 and  180.  Use a direction of W instead of negative.');\n        }\n\n        if (direction === 'W') {\n          longTemp *= -1;\n        } else if (!(direction === 'E')) {\n          throw new IllegalArgumentException('Longitude direction must be E or W');\n        }\n\n        this.longitude = longTemp;\n      }\n    }\n    /**\r\n     * @return Returns the longitude.\r\n     */\n\n  }, {\n    key: \"getLongitude\",\n    value: function getLongitude() {\n      return this.longitude;\n    }\n    /**\r\n     * @return Returns the location name.\r\n     */\n\n  }, {\n    key: \"getLocationName\",\n    value: function getLocationName() {\n      return this.locationName;\n    }\n    /**\r\n     * @param name\r\n     *            The setter method for the display name.\r\n     */\n\n  }, {\n    key: \"setLocationName\",\n    value: function setLocationName(name) {\n      this.locationName = name;\n    }\n    /**\r\n     * @return Returns the timeZone.\r\n     */\n\n  }, {\n    key: \"getTimeZone\",\n    value: function getTimeZone() {\n      return this.timeZoneId;\n    }\n    /**\r\n     * Method to set the TimeZone. If this is ever set after the GeoLocation is set in the\r\n     * {@link net.sourceforge.zmanim.AstronomicalCalendar}, it is critical that\r\n     * {@link net.sourceforge.zmanim.AstronomicalCalendar#getCalendar()}.\r\n     * {@link java.util.Calendar#setTimeZone(TimeZone) setTimeZone(TimeZone)} be called in order for the\r\n     * AstronomicalCalendar to output times in the expected offset. This situation will arise if the\r\n     * AstronomicalCalendar is ever {@link net.sourceforge.zmanim.AstronomicalCalendar#clone() cloned}.\r\n     *\r\n     * @param timeZone\r\n     *            The timeZone to set.\r\n     */\n\n  }, {\n    key: \"setTimeZone\",\n    value: function setTimeZone(timeZoneId) {\n      this.timeZoneId = timeZoneId;\n    }\n    /**\r\n     * A method that will return the location's local mean time offset in milliseconds from local <a\r\n     * href=\"http://en.wikipedia.org/wiki/Standard_time\">standard time</a>. The globe is split into 360&deg;, with\r\n     * 15&deg; per hour of the day. For a local that is at a longitude that is evenly divisible by 15 (longitude % 15 ==\r\n     * 0), at solar {@link net.sourceforge.zmanim.AstronomicalCalendar#getSunTransit() noon} (with adjustment for the <a\r\n     * href=\"http://en.wikipedia.org/wiki/Equation_of_time\">equation of time</a>) the sun should be directly overhead,\r\n     * so a user who is 1&deg; west of this will have noon at 4 minutes after standard time noon, and conversely, a user\r\n     * who is 1&deg; east of the 15&deg; longitude will have noon at 11:56 AM. Lakewood, N.J., whose longitude is\r\n     * -74.2094, is 0.7906 away from the closest multiple of 15 at -75&deg;. This is multiplied by 4 to yield 3 minutes\r\n     * and 10 seconds earlier than standard time. The offset returned does not account for the <a\r\n     * href=\"http://en.wikipedia.org/wiki/Daylight_saving_time\">Daylight saving time</a> offset since this class is\r\n     * unaware of dates.\r\n     *\r\n     * @return the offset in milliseconds not accounting for Daylight saving time. A positive value will be returned\r\n     *         East of the 15&deg; timezone line, and a negative value West of it.\r\n     * @since 1.1\r\n     */\n\n  }, {\n    key: \"getLocalMeanTimeOffset\",\n    value: function getLocalMeanTimeOffset() {\n      return this.getLongitude() * 4 * GeoLocation.MINUTE_MILLIS - TimeZone.getRawOffset(this.getTimeZone());\n    }\n    /**\r\n     * Adjust the date for <a href=\"https://en.wikipedia.org/wiki/180th_meridian\">antimeridian</a> crossover. This is\r\n     * needed to deal with edge cases such as Samoa that use a different calendar date than expected based on their\r\n     * geographic location.\r\n     *\r\n     * The actual Time Zone offset may deviate from the expected offset based on the longitude. Since the 'absolute time'\r\n     * calculations are always based on longitudinal offset from UTC for a given date, the date is presumed to only\r\n     * increase East of the Prime Meridian, and to only decrease West of it. For Time Zones that cross the antimeridian,\r\n     * the date will be artificially adjusted before calculation to conform with this presumption.\r\n     *\r\n     * For example, Apia, Samoa with a longitude of -171.75 uses a local offset of +14:00.  When calculating sunrise for\r\n     * 2018-02-03, the calculator should operate using 2018-02-02 since the expected zone is -11.  After determining the\r\n     * UTC time, the local DST offset of <a href=\"https://en.wikipedia.org/wiki/UTC%2B14:00\">UTC+14:00</a> should be applied\r\n     * to bring the date back to 2018-02-03.\r\n     *\r\n     * @return the number of days to adjust the date This will typically be 0 unless the date crosses the antimeridian\r\n     */\n\n  }, {\n    key: \"getAntimeridianAdjustment\",\n    value: function getAntimeridianAdjustment() {\n      var localHoursOffset = this.getLocalMeanTimeOffset() / GeoLocation.HOUR_MILLIS; // if the offset is 20 hours or more in the future (never expected anywhere other\n      // than a location using a timezone across the anti meridian to the east such as Samoa)\n\n      if (localHoursOffset >= 20) {\n        // roll the date forward a day\n        return 1;\n      } else if (localHoursOffset <= -20) {\n        // if the offset is 20 hours or more in the past (no current location is known\n        // that crosses the antimeridian to the west, but better safe than sorry)\n        // roll the date back a day\n        return -1;\n      } // 99.999% of the world will have no adjustment\n\n\n      return 0;\n    }\n    /**\r\n     * Calculate the initial <a href=\"http://en.wikipedia.org/wiki/Great_circle\">geodesic</a> bearing between this\r\n     * Object and a second Object passed to this method using <a\r\n     * href=\"http://en.wikipedia.org/wiki/Thaddeus_Vincenty\">Thaddeus Vincenty's</a> inverse formula See T Vincenty, \"<a\r\n     * href=\"http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf\">Direct and Inverse Solutions of Geodesics on the Ellipsoid\r\n     * with application of nested equations</a>\", Survey Review, vol XXII no 176, 1975\r\n     *\r\n     * @param location\r\n     *            the destination location\r\n     * @return the initial bearing\r\n     */\n\n  }, {\n    key: \"getGeodesicInitialBearing\",\n    value: function getGeodesicInitialBearing(location) {\n      return this.vincentyFormula(location, GeoLocation.INITIAL_BEARING);\n    }\n    /**\r\n     * Calculate the final <a href=\"http://en.wikipedia.org/wiki/Great_circle\">geodesic</a> bearing between this Object\r\n     * and a second Object passed to this method using <a href=\"http://en.wikipedia.org/wiki/Thaddeus_Vincenty\">Thaddeus\r\n     * Vincenty's</a> inverse formula See T Vincenty, \"<a href=\"http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf\">Direct and\r\n     * Inverse Solutions of Geodesics on the Ellipsoid with application of nested equations</a>\", Survey Review, vol\r\n     * XXII no 176, 1975\r\n     *\r\n     * @param location\r\n     *            the destination location\r\n     * @return the final bearing\r\n     */\n\n  }, {\n    key: \"getGeodesicFinalBearing\",\n    value: function getGeodesicFinalBearing(location) {\n      return this.vincentyFormula(location, GeoLocation.FINAL_BEARING);\n    }\n    /**\r\n     * Calculate <a href=\"http://en.wikipedia.org/wiki/Great-circle_distance\">geodesic distance</a> in Meters between\r\n     * this Object and a second Object passed to this method using <a\r\n     * href=\"http://en.wikipedia.org/wiki/Thaddeus_Vincenty\">Thaddeus Vincenty's</a> inverse formula See T Vincenty, \"<a\r\n     * href=\"http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf\">Direct and Inverse Solutions of Geodesics on the Ellipsoid\r\n     * with application of nested equations</a>\", Survey Review, vol XXII no 176, 1975\r\n     *\r\n     * @see #vincentyFormula(GeoLocation, int)\r\n     * @param location\r\n     *            the destination location\r\n     * @return the geodesic distance in Meters\r\n     */\n\n  }, {\n    key: \"getGeodesicDistance\",\n    value: function getGeodesicDistance(location) {\n      return this.vincentyFormula(location, GeoLocation.DISTANCE);\n    }\n    /**\r\n     * Calculate <a href=\"http://en.wikipedia.org/wiki/Great-circle_distance\">geodesic distance</a> in Meters between\r\n     * this Object and a second Object passed to this method using <a\r\n     * href=\"http://en.wikipedia.org/wiki/Thaddeus_Vincenty\">Thaddeus Vincenty's</a> inverse formula See T Vincenty, \"<a\r\n     * href=\"http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf\">Direct and Inverse Solutions of Geodesics on the Ellipsoid\r\n     * with application of nested equations</a>\", Survey Review, vol XXII no 176, 1975\r\n     *\r\n     * @param location\r\n     *            the destination location\r\n     * @param formula\r\n     *            This formula calculates initial bearing ({@link #INITIAL_BEARING}), final bearing (\r\n     *            {@link #FINAL_BEARING}) and distance ({@link #DISTANCE}).\r\n     * @return geodesic distance in Meters\r\n     */\n\n  }, {\n    key: \"vincentyFormula\",\n    value: function vincentyFormula(location, formula) {\n      var a = 6378137;\n      var b = 6356752.3142;\n      var f = 1 / 298.257223563; // WGS-84 ellipsiod\n\n      var L = MathUtils.degreesToRadians(location.getLongitude() - this.getLongitude());\n      var U1 = Math.atan((1 - f) * Math.tan(MathUtils.degreesToRadians(this.getLatitude())));\n      var U2 = Math.atan((1 - f) * Math.tan(MathUtils.degreesToRadians(location.getLatitude())));\n      var sinU1 = Math.sin(U1);\n      var cosU1 = Math.cos(U1);\n      var sinU2 = Math.sin(U2);\n      var cosU2 = Math.cos(U2);\n      var lambda = L;\n      var lambdaP = 2 * Math.PI;\n      var iterLimit = 20;\n      var sinLambda = 0;\n      var cosLambda = 0;\n      var sinSigma = 0;\n      var cosSigma = 0;\n      var sigma = 0;\n      var sinAlpha = 0;\n      var cosSqAlpha = 0;\n      var cos2SigmaM = 0;\n      var C;\n\n      while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0) {\n        sinLambda = Math.sin(lambda);\n        cosLambda = Math.cos(lambda);\n        sinSigma = Math.sqrt(cosU2 * sinLambda * (cosU2 * sinLambda) + (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));\n        if (sinSigma === 0) return 0; // co-incident points\n\n        cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;\n        sigma = Math.atan2(sinSigma, cosSigma);\n        sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;\n        cosSqAlpha = 1 - sinAlpha * sinAlpha;\n        cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;\n        if (Number.isNaN(cos2SigmaM)) cos2SigmaM = 0; // equatorial line: cosSqAlpha=0 (§6)\n\n        C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));\n        lambdaP = lambda;\n        lambda = L + (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));\n      }\n\n      if (iterLimit === 0) return Number.NaN; // formula failed to converge\n\n      var uSq = cosSqAlpha * (a * a - b * b) / (b * b);\n      var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));\n      var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));\n      var deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));\n      var distance = b * A * (sigma - deltaSigma); // initial bearing\n\n      var fwdAz = MathUtils.radiansToDegrees(Math.atan2(cosU2 * sinLambda, cosU1 * sinU2 - sinU1 * cosU2 * cosLambda)); // final bearing\n\n      var revAz = MathUtils.radiansToDegrees(Math.atan2(cosU1 * sinLambda, -sinU1 * cosU2 + cosU1 * sinU2 * cosLambda));\n\n      if (formula === GeoLocation.DISTANCE) {\n        return distance;\n      } else if (formula === GeoLocation.INITIAL_BEARING) {\n        return fwdAz;\n      } else if (formula === GeoLocation.FINAL_BEARING) {\n        return revAz;\n      } // should never happen\n\n\n      return Number.NaN;\n    }\n    /**\r\n     * Returns the <a href=\"http://en.wikipedia.org/wiki/Rhumb_line\">rhumb line</a> bearing from the current location to\r\n     * the GeoLocation passed in.\r\n     *\r\n     * @param location\r\n     *            destination location\r\n     * @return the bearing in degrees\r\n     */\n\n  }, {\n    key: \"getRhumbLineBearing\",\n    value: function getRhumbLineBearing(location) {\n      var dLon = MathUtils.degreesToRadians(location.getLongitude() - this.getLongitude());\n      var dPhi = Math.log(Math.tan(MathUtils.degreesToRadians(location.getLatitude()) / 2 + Math.PI / 4) / Math.tan(MathUtils.degreesToRadians(this.getLatitude()) / 2 + Math.PI / 4));\n      if (Math.abs(dLon) > Math.PI) dLon = dLon > 0 ? -(2 * Math.PI - dLon) : 2 * Math.PI + dLon;\n      return MathUtils.radiansToDegrees(Math.atan2(dLon, dPhi));\n    }\n    /**\r\n     * Returns the <a href=\"http://en.wikipedia.org/wiki/Rhumb_line\">rhumb line</a> distance from the current location\r\n     * to the GeoLocation passed in.\r\n     *\r\n     * @param location\r\n     *            the destination location\r\n     * @return the distance in Meters\r\n     */\n\n  }, {\n    key: \"getRhumbLineDistance\",\n    value: function getRhumbLineDistance(location) {\n      var earthRadius = 6378137; // earth's mean radius in km\n\n      var dLat = MathUtils.degreesToRadians(location.getLatitude()) - MathUtils.degreesToRadians(this.getLatitude());\n      var dLon = Math.abs(MathUtils.degreesToRadians(location.getLongitude()) - MathUtils.degreesToRadians(this.getLongitude()));\n      var dPhi = Math.log(Math.tan(MathUtils.degreesToRadians(location.getLatitude()) / 2 + Math.PI / 4) / Math.tan(MathUtils.degreesToRadians(this.getLatitude()) / 2 + Math.PI / 4));\n      var q = dLat / dPhi;\n\n      if (!Number.isFinite(q)) {\n        q = Math.cos(MathUtils.degreesToRadians(this.getLatitude()));\n      } // if dLon over 180° take shorter rhumb across 180° meridian:\n\n\n      if (dLon > Math.PI) {\n        dLon = 2 * Math.PI - dLon;\n      }\n\n      var d = Math.sqrt(dLat * dLat + q * q * dLon * dLon);\n      return d * earthRadius;\n    }\n    /**\r\n     * A method that returns an XML formatted <code>String</code> representing the serialized <code>Object</code>. Very\r\n     * similar to the toString method but the return value is in an xml format. The format currently used (subject to\r\n     * change) is:\r\n     *\r\n     * <pre>\r\n     *   &lt;GeoLocation&gt;\r\n     *        &lt;LocationName&gt;Lakewood, NJ&lt;/LocationName&gt;\r\n     *        &lt;Latitude&gt;40.0828&amp;deg&lt;/Latitude&gt;\r\n     *        &lt;Longitude&gt;-74.2094&amp;deg&lt;/Longitude&gt;\r\n     *        &lt;Elevation&gt;0 Meters&lt;/Elevation&gt;\r\n     *        &lt;TimezoneName&gt;America/New_York&lt;/TimezoneName&gt;\r\n     *        &lt;TimeZoneDisplayName&gt;Eastern Standard Time&lt;/TimeZoneDisplayName&gt;\r\n     *        &lt;TimezoneGMTOffset&gt;-5&lt;/TimezoneGMTOffset&gt;\r\n     *        &lt;TimezoneDSTOffset&gt;1&lt;/TimezoneDSTOffset&gt;\r\n     *   &lt;/GeoLocation&gt;\r\n     * </pre>\r\n     *\r\n     * @return The XML formatted <code>String</code>.\r\n     * @deprecated\r\n     */\n    // eslint-disable-next-line class-methods-use-this\n\n  }, {\n    key: \"toXML\",\n    value: function toXML() {\n      throw new UnsupportedError('This method is deprecated');\n    }\n    /**\r\n     * @see java.lang.Object#equals(Object)\r\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(object) {\n      if (this === object) return true;\n      if (!(object instanceof GeoLocation)) return false;\n      var geo = object;\n      return this.latitude === geo.latitude && this.longitude === geo.longitude && this.elevation === geo.elevation && this.locationName === geo.locationName && this.timeZoneId === geo.getTimeZone();\n    }\n    /**\r\n     * @see java.lang.Object#toString()\r\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"Location Name:\\t\\t\\t\".concat(this.getLocationName()).concat(\"\\nLatitude:\\t\\t\\t\".concat(this.getLatitude().toString(), \"\\xB0\")).concat(\"\\nLongitude:\\t\\t\\t\".concat(this.getLongitude().toString(), \"\\xB0\")).concat(\"\\nElevation:\\t\\t\\t\".concat(this.getElevation().toString(), \" Meters\")).concat(\"\\nTimezone ID:\\t\\t\\t\".concat(this.getTimeZone())).concat(\"\\nTimezone Display Name:\\t\\t\".concat(TimeZone.getDisplayName(this.getTimeZone()))).concat(\" (\".concat(TimeZone.getDisplayName(this.getTimeZone(), DateTime.local(), true), \")\")).concat(\"\\nTimezone GMT Offset:\\t\\t\".concat((TimeZone.getRawOffset(this.getTimeZone()) / GeoLocation.HOUR_MILLIS).toString())).concat(\"\\nTimezone DST Offset:\\t\\t\".concat((TimeZone.getDSTSavings(this.getTimeZone()) / GeoLocation.HOUR_MILLIS).toString()));\n    }\n    /**\r\n     * An implementation of the {@link java.lang.Object#clone()} method that creates a <a\r\n     * href=\"http://en.wikipedia.org/wiki/Object_copy#Deep_copy\">deep copy</a> of the object.\r\n     * <b>Note:</b> If the {@link java.util.TimeZone} in the clone will be changed from the original, it is critical\r\n     * that {@link net.sourceforge.zmanim.AstronomicalCalendar#getCalendar()}.\r\n     * {@link java.util.Calendar#setTimeZone(TimeZone) setTimeZone(TimeZone)} is called after cloning in order for the\r\n     * AstronomicalCalendar to output times in the expected offset.\r\n     *\r\n     * @see java.lang.Object#clone()\r\n     * @since 1.1\r\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return JSON.parse(JSON.stringify(this));\n    }\n  }]);\n\n  return GeoLocation;\n}();\nGeoLocation.DISTANCE = 0;\nGeoLocation.INITIAL_BEARING = 1;\nGeoLocation.FINAL_BEARING = 2;\n/** constant for milliseconds in a minute (60,000) */\n\nGeoLocation.MINUTE_MILLIS = 60 * 1000;\n/** constant for milliseconds in an hour (3,600,000) */\n\nGeoLocation.HOUR_MILLIS = GeoLocation.MINUTE_MILLIS * 60;","map":{"version":3,"sources":["../../../src/util/GeoLocation.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { DateTime } from 'luxon';\r\nimport { MathUtils, TimeZone } from '../polyfills/Utils';\r\nimport { IllegalArgumentException, UnsupportedError } from '../polyfills/errors';\r\n/**\r\n * A class that contains location information such as latitude and longitude required for astronomical calculations. The\r\n * elevation field may not be used by some calculation engines and would be ignored if set. Check the documentation for\r\n * specific implementations of the {@link AstronomicalCalculator} to see if elevation is calculated as part of the\r\n * algorithm.\r\n *\r\n * @author &copy; Eliyahu Hershfeld 2004 - 2016\r\n * @version 1.1\r\n */\r\nexport class GeoLocation {\r\n    constructor(name = 'Greenwich, England', latitude = 51.4772, longitude = 0, elevationOrTimeZoneId, timeZoneId) {\r\n        this.locationName = null;\r\n        let elevation = 0;\r\n        if (timeZoneId) {\r\n            elevation = elevationOrTimeZoneId;\r\n        }\r\n        else {\r\n            timeZoneId = elevationOrTimeZoneId;\r\n        }\r\n        this.setLocationName(name);\r\n        this.setLatitude(latitude);\r\n        this.setLongitude(longitude);\r\n        this.setElevation(elevation);\r\n        this.setTimeZone(timeZoneId);\r\n    }\r\n    /**\r\n     * Method to get the elevation in Meters.\r\n     *\r\n     * @return Returns the elevation in Meters.\r\n     */\r\n    getElevation() {\r\n        return this.elevation;\r\n    }\r\n    /**\r\n     * Method to set the elevation in Meters <b>above </b> sea level.\r\n     *\r\n     * @param elevation\r\n     *            The elevation to set in Meters. An IllegalArgumentException will be thrown if the value is a negative.\r\n     */\r\n    setElevation(elevation) {\r\n        if (elevation < 0) {\r\n            throw new IllegalArgumentException('Elevation cannot be negative');\r\n        }\r\n        this.elevation = elevation;\r\n    }\r\n    setLatitude(degreesOrLatitude, minutes, seconds, direction) {\r\n        if (!minutes) {\r\n            const latitude = degreesOrLatitude;\r\n            if (latitude > 90 || latitude < -90) {\r\n                throw new IllegalArgumentException('Latitude must be between -90 and  90');\r\n            }\r\n            this.latitude = latitude;\r\n        }\r\n        else {\r\n            const degrees = degreesOrLatitude;\r\n            let tempLat = degrees + ((minutes + (seconds / 60)) / 60);\r\n            if (tempLat > 90 || tempLat < 0) { // FIXME An exception should be thrown if degrees, minutes or seconds are negative\r\n                throw new IllegalArgumentException('Latitude must be between 0 and  90. Use direction of S instead of negative.');\r\n            }\r\n            if (direction === 'S') {\r\n                tempLat *= -1;\r\n            }\r\n            else if (!(direction === 'N')) {\r\n                throw new IllegalArgumentException('Latitude direction must be N or S');\r\n            }\r\n            this.latitude = tempLat;\r\n        }\r\n    }\r\n    /**\r\n     * @return Returns the latitude.\r\n     */\r\n    getLatitude() {\r\n        return this.latitude;\r\n    }\r\n    setLongitude(degreesOrLongitude, minutes, seconds, direction) {\r\n        if (!minutes) {\r\n            const longitude = degreesOrLongitude;\r\n            if (longitude > 180 || longitude < -180) {\r\n                throw new IllegalArgumentException('Longitude must be between -180 and  180');\r\n            }\r\n            this.longitude = longitude;\r\n        }\r\n        else {\r\n            const degrees = degreesOrLongitude;\r\n            let longTemp = degrees + ((minutes + (seconds / 60)) / 60);\r\n            if (longTemp > 180 || this.longitude < 0) { // FIXME An exception should be thrown if degrees, minutes or seconds are negative\r\n                throw new IllegalArgumentException('Longitude must be between 0 and  180.  Use a direction of W instead of negative.');\r\n            }\r\n            if (direction === 'W') {\r\n                longTemp *= -1;\r\n            }\r\n            else if (!(direction === 'E')) {\r\n                throw new IllegalArgumentException('Longitude direction must be E or W');\r\n            }\r\n            this.longitude = longTemp;\r\n        }\r\n    }\r\n    /**\r\n     * @return Returns the longitude.\r\n     */\r\n    getLongitude() {\r\n        return this.longitude;\r\n    }\r\n    /**\r\n     * @return Returns the location name.\r\n     */\r\n    getLocationName() {\r\n        return this.locationName;\r\n    }\r\n    /**\r\n     * @param name\r\n     *            The setter method for the display name.\r\n     */\r\n    setLocationName(name) {\r\n        this.locationName = name;\r\n    }\r\n    /**\r\n     * @return Returns the timeZone.\r\n     */\r\n    getTimeZone() {\r\n        return this.timeZoneId;\r\n    }\r\n    /**\r\n     * Method to set the TimeZone. If this is ever set after the GeoLocation is set in the\r\n     * {@link net.sourceforge.zmanim.AstronomicalCalendar}, it is critical that\r\n     * {@link net.sourceforge.zmanim.AstronomicalCalendar#getCalendar()}.\r\n     * {@link java.util.Calendar#setTimeZone(TimeZone) setTimeZone(TimeZone)} be called in order for the\r\n     * AstronomicalCalendar to output times in the expected offset. This situation will arise if the\r\n     * AstronomicalCalendar is ever {@link net.sourceforge.zmanim.AstronomicalCalendar#clone() cloned}.\r\n     *\r\n     * @param timeZone\r\n     *            The timeZone to set.\r\n     */\r\n    setTimeZone(timeZoneId) {\r\n        this.timeZoneId = timeZoneId;\r\n    }\r\n    /**\r\n     * A method that will return the location's local mean time offset in milliseconds from local <a\r\n     * href=\"http://en.wikipedia.org/wiki/Standard_time\">standard time</a>. The globe is split into 360&deg;, with\r\n     * 15&deg; per hour of the day. For a local that is at a longitude that is evenly divisible by 15 (longitude % 15 ==\r\n     * 0), at solar {@link net.sourceforge.zmanim.AstronomicalCalendar#getSunTransit() noon} (with adjustment for the <a\r\n     * href=\"http://en.wikipedia.org/wiki/Equation_of_time\">equation of time</a>) the sun should be directly overhead,\r\n     * so a user who is 1&deg; west of this will have noon at 4 minutes after standard time noon, and conversely, a user\r\n     * who is 1&deg; east of the 15&deg; longitude will have noon at 11:56 AM. Lakewood, N.J., whose longitude is\r\n     * -74.2094, is 0.7906 away from the closest multiple of 15 at -75&deg;. This is multiplied by 4 to yield 3 minutes\r\n     * and 10 seconds earlier than standard time. The offset returned does not account for the <a\r\n     * href=\"http://en.wikipedia.org/wiki/Daylight_saving_time\">Daylight saving time</a> offset since this class is\r\n     * unaware of dates.\r\n     *\r\n     * @return the offset in milliseconds not accounting for Daylight saving time. A positive value will be returned\r\n     *         East of the 15&deg; timezone line, and a negative value West of it.\r\n     * @since 1.1\r\n     */\r\n    getLocalMeanTimeOffset() {\r\n        return this.getLongitude() * 4 * GeoLocation.MINUTE_MILLIS - TimeZone.getRawOffset(this.getTimeZone());\r\n    }\r\n    /**\r\n     * Adjust the date for <a href=\"https://en.wikipedia.org/wiki/180th_meridian\">antimeridian</a> crossover. This is\r\n     * needed to deal with edge cases such as Samoa that use a different calendar date than expected based on their\r\n     * geographic location.\r\n     *\r\n     * The actual Time Zone offset may deviate from the expected offset based on the longitude. Since the 'absolute time'\r\n     * calculations are always based on longitudinal offset from UTC for a given date, the date is presumed to only\r\n     * increase East of the Prime Meridian, and to only decrease West of it. For Time Zones that cross the antimeridian,\r\n     * the date will be artificially adjusted before calculation to conform with this presumption.\r\n     *\r\n     * For example, Apia, Samoa with a longitude of -171.75 uses a local offset of +14:00.  When calculating sunrise for\r\n     * 2018-02-03, the calculator should operate using 2018-02-02 since the expected zone is -11.  After determining the\r\n     * UTC time, the local DST offset of <a href=\"https://en.wikipedia.org/wiki/UTC%2B14:00\">UTC+14:00</a> should be applied\r\n     * to bring the date back to 2018-02-03.\r\n     *\r\n     * @return the number of days to adjust the date This will typically be 0 unless the date crosses the antimeridian\r\n     */\r\n    getAntimeridianAdjustment() {\r\n        const localHoursOffset = this.getLocalMeanTimeOffset() / GeoLocation.HOUR_MILLIS;\r\n        // if the offset is 20 hours or more in the future (never expected anywhere other\r\n        // than a location using a timezone across the anti meridian to the east such as Samoa)\r\n        if (localHoursOffset >= 20) {\r\n            // roll the date forward a day\r\n            return 1;\r\n        }\r\n        else if (localHoursOffset <= -20) {\r\n            // if the offset is 20 hours or more in the past (no current location is known\r\n            // that crosses the antimeridian to the west, but better safe than sorry)\r\n            // roll the date back a day\r\n            return -1;\r\n        }\r\n        // 99.999% of the world will have no adjustment\r\n        return 0;\r\n    }\r\n    /**\r\n     * Calculate the initial <a href=\"http://en.wikipedia.org/wiki/Great_circle\">geodesic</a> bearing between this\r\n     * Object and a second Object passed to this method using <a\r\n     * href=\"http://en.wikipedia.org/wiki/Thaddeus_Vincenty\">Thaddeus Vincenty's</a> inverse formula See T Vincenty, \"<a\r\n     * href=\"http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf\">Direct and Inverse Solutions of Geodesics on the Ellipsoid\r\n     * with application of nested equations</a>\", Survey Review, vol XXII no 176, 1975\r\n     *\r\n     * @param location\r\n     *            the destination location\r\n     * @return the initial bearing\r\n     */\r\n    getGeodesicInitialBearing(location) {\r\n        return this.vincentyFormula(location, GeoLocation.INITIAL_BEARING);\r\n    }\r\n    /**\r\n     * Calculate the final <a href=\"http://en.wikipedia.org/wiki/Great_circle\">geodesic</a> bearing between this Object\r\n     * and a second Object passed to this method using <a href=\"http://en.wikipedia.org/wiki/Thaddeus_Vincenty\">Thaddeus\r\n     * Vincenty's</a> inverse formula See T Vincenty, \"<a href=\"http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf\">Direct and\r\n     * Inverse Solutions of Geodesics on the Ellipsoid with application of nested equations</a>\", Survey Review, vol\r\n     * XXII no 176, 1975\r\n     *\r\n     * @param location\r\n     *            the destination location\r\n     * @return the final bearing\r\n     */\r\n    getGeodesicFinalBearing(location) {\r\n        return this.vincentyFormula(location, GeoLocation.FINAL_BEARING);\r\n    }\r\n    /**\r\n     * Calculate <a href=\"http://en.wikipedia.org/wiki/Great-circle_distance\">geodesic distance</a> in Meters between\r\n     * this Object and a second Object passed to this method using <a\r\n     * href=\"http://en.wikipedia.org/wiki/Thaddeus_Vincenty\">Thaddeus Vincenty's</a> inverse formula See T Vincenty, \"<a\r\n     * href=\"http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf\">Direct and Inverse Solutions of Geodesics on the Ellipsoid\r\n     * with application of nested equations</a>\", Survey Review, vol XXII no 176, 1975\r\n     *\r\n     * @see #vincentyFormula(GeoLocation, int)\r\n     * @param location\r\n     *            the destination location\r\n     * @return the geodesic distance in Meters\r\n     */\r\n    getGeodesicDistance(location) {\r\n        return this.vincentyFormula(location, GeoLocation.DISTANCE);\r\n    }\r\n    /**\r\n     * Calculate <a href=\"http://en.wikipedia.org/wiki/Great-circle_distance\">geodesic distance</a> in Meters between\r\n     * this Object and a second Object passed to this method using <a\r\n     * href=\"http://en.wikipedia.org/wiki/Thaddeus_Vincenty\">Thaddeus Vincenty's</a> inverse formula See T Vincenty, \"<a\r\n     * href=\"http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf\">Direct and Inverse Solutions of Geodesics on the Ellipsoid\r\n     * with application of nested equations</a>\", Survey Review, vol XXII no 176, 1975\r\n     *\r\n     * @param location\r\n     *            the destination location\r\n     * @param formula\r\n     *            This formula calculates initial bearing ({@link #INITIAL_BEARING}), final bearing (\r\n     *            {@link #FINAL_BEARING}) and distance ({@link #DISTANCE}).\r\n     * @return geodesic distance in Meters\r\n     */\r\n    vincentyFormula(location, formula) {\r\n        const a = 6378137;\r\n        const b = 6356752.3142;\r\n        const f = 1 / 298.257223563; // WGS-84 ellipsiod\r\n        const L = MathUtils.degreesToRadians(location.getLongitude() - this.getLongitude());\r\n        const U1 = Math.atan((1 - f) * Math.tan(MathUtils.degreesToRadians(this.getLatitude())));\r\n        const U2 = Math.atan((1 - f) * Math.tan(MathUtils.degreesToRadians(location.getLatitude())));\r\n        const sinU1 = Math.sin(U1);\r\n        const cosU1 = Math.cos(U1);\r\n        const sinU2 = Math.sin(U2);\r\n        const cosU2 = Math.cos(U2);\r\n        let lambda = L;\r\n        let lambdaP = 2 * Math.PI;\r\n        let iterLimit = 20;\r\n        let sinLambda = 0;\r\n        let cosLambda = 0;\r\n        let sinSigma = 0;\r\n        let cosSigma = 0;\r\n        let sigma = 0;\r\n        let sinAlpha = 0;\r\n        let cosSqAlpha = 0;\r\n        let cos2SigmaM = 0;\r\n        let C;\r\n        while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0) {\r\n            sinLambda = Math.sin(lambda);\r\n            cosLambda = Math.cos(lambda);\r\n            sinSigma = Math.sqrt((cosU2 * sinLambda) * (cosU2 * sinLambda)\r\n                + (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));\r\n            if (sinSigma === 0)\r\n                return 0; // co-incident points\r\n            cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;\r\n            sigma = Math.atan2(sinSigma, cosSigma);\r\n            sinAlpha = (cosU1 * cosU2 * sinLambda) / sinSigma;\r\n            cosSqAlpha = 1 - sinAlpha * sinAlpha;\r\n            cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;\r\n            if (Number.isNaN(cos2SigmaM))\r\n                cos2SigmaM = 0; // equatorial line: cosSqAlpha=0 (§6)\r\n            C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));\r\n            lambdaP = lambda;\r\n            lambda = L + (1 - C) * f * sinAlpha\r\n                * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));\r\n        }\r\n        if (iterLimit === 0)\r\n            return Number.NaN; // formula failed to converge\r\n        const uSq = cosSqAlpha * (a * a - b * b) / (b * b);\r\n        const A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));\r\n        const B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));\r\n        const deltaSigma = B * sinSigma\r\n            * (cos2SigmaM + B / 4\r\n                * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM\r\n                    * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));\r\n        const distance = b * A * (sigma - deltaSigma);\r\n        // initial bearing\r\n        const fwdAz = MathUtils.radiansToDegrees(Math.atan2(cosU2 * sinLambda, cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));\r\n        // final bearing\r\n        const revAz = MathUtils.radiansToDegrees(Math.atan2(cosU1 * sinLambda, -sinU1 * cosU2 + cosU1 * sinU2 * cosLambda));\r\n        if (formula === GeoLocation.DISTANCE) {\r\n            return distance;\r\n        }\r\n        else if (formula === GeoLocation.INITIAL_BEARING) {\r\n            return fwdAz;\r\n        }\r\n        else if (formula === GeoLocation.FINAL_BEARING) {\r\n            return revAz;\r\n        }\r\n        // should never happen\r\n        return Number.NaN;\r\n    }\r\n    /**\r\n     * Returns the <a href=\"http://en.wikipedia.org/wiki/Rhumb_line\">rhumb line</a> bearing from the current location to\r\n     * the GeoLocation passed in.\r\n     *\r\n     * @param location\r\n     *            destination location\r\n     * @return the bearing in degrees\r\n     */\r\n    getRhumbLineBearing(location) {\r\n        let dLon = MathUtils.degreesToRadians(location.getLongitude() - this.getLongitude());\r\n        const dPhi = Math.log(Math.tan(MathUtils.degreesToRadians(location.getLatitude()) / 2 + Math.PI / 4)\r\n            / Math.tan(MathUtils.degreesToRadians(this.getLatitude()) / 2 + Math.PI / 4));\r\n        if (Math.abs(dLon) > Math.PI)\r\n            dLon = dLon > 0 ? -(2 * Math.PI - dLon) : (2 * Math.PI + dLon);\r\n        return MathUtils.radiansToDegrees(Math.atan2(dLon, dPhi));\r\n    }\r\n    /**\r\n     * Returns the <a href=\"http://en.wikipedia.org/wiki/Rhumb_line\">rhumb line</a> distance from the current location\r\n     * to the GeoLocation passed in.\r\n     *\r\n     * @param location\r\n     *            the destination location\r\n     * @return the distance in Meters\r\n     */\r\n    getRhumbLineDistance(location) {\r\n        const earthRadius = 6378137; // earth's mean radius in km\r\n        const dLat = MathUtils.degreesToRadians(location.getLatitude()) - MathUtils.degreesToRadians(this.getLatitude());\r\n        let dLon = Math.abs(MathUtils.degreesToRadians(location.getLongitude()) - MathUtils.degreesToRadians(this.getLongitude()));\r\n        const dPhi = Math.log(Math.tan(MathUtils.degreesToRadians(location.getLatitude()) / 2 + Math.PI / 4)\r\n            / Math.tan(MathUtils.degreesToRadians(this.getLatitude()) / 2 + Math.PI / 4));\r\n        let q = dLat / dPhi;\r\n        if (!Number.isFinite(q)) {\r\n            q = Math.cos(MathUtils.degreesToRadians(this.getLatitude()));\r\n        }\r\n        // if dLon over 180° take shorter rhumb across 180° meridian:\r\n        if (dLon > Math.PI) {\r\n            dLon = 2 * Math.PI - dLon;\r\n        }\r\n        const d = Math.sqrt(dLat * dLat + q * q * dLon * dLon);\r\n        return d * earthRadius;\r\n    }\r\n    /**\r\n     * A method that returns an XML formatted <code>String</code> representing the serialized <code>Object</code>. Very\r\n     * similar to the toString method but the return value is in an xml format. The format currently used (subject to\r\n     * change) is:\r\n     *\r\n     * <pre>\r\n     *   &lt;GeoLocation&gt;\r\n     *        &lt;LocationName&gt;Lakewood, NJ&lt;/LocationName&gt;\r\n     *        &lt;Latitude&gt;40.0828&amp;deg&lt;/Latitude&gt;\r\n     *        &lt;Longitude&gt;-74.2094&amp;deg&lt;/Longitude&gt;\r\n     *        &lt;Elevation&gt;0 Meters&lt;/Elevation&gt;\r\n     *        &lt;TimezoneName&gt;America/New_York&lt;/TimezoneName&gt;\r\n     *        &lt;TimeZoneDisplayName&gt;Eastern Standard Time&lt;/TimeZoneDisplayName&gt;\r\n     *        &lt;TimezoneGMTOffset&gt;-5&lt;/TimezoneGMTOffset&gt;\r\n     *        &lt;TimezoneDSTOffset&gt;1&lt;/TimezoneDSTOffset&gt;\r\n     *   &lt;/GeoLocation&gt;\r\n     * </pre>\r\n     *\r\n     * @return The XML formatted <code>String</code>.\r\n     * @deprecated\r\n     */\r\n    // eslint-disable-next-line class-methods-use-this\r\n    toXML() {\r\n        throw new UnsupportedError('This method is deprecated');\r\n    }\r\n    /**\r\n     * @see java.lang.Object#equals(Object)\r\n     */\r\n    equals(object) {\r\n        if (this === object)\r\n            return true;\r\n        if (!(object instanceof GeoLocation))\r\n            return false;\r\n        const geo = object;\r\n        return this.latitude === geo.latitude\r\n            && this.longitude === geo.longitude\r\n            && this.elevation === geo.elevation\r\n            && this.locationName === geo.locationName\r\n            && this.timeZoneId === geo.getTimeZone();\r\n    }\r\n    /**\r\n     * @see java.lang.Object#toString()\r\n     */\r\n    toString() {\r\n        return (`Location Name:\\t\\t\\t${this.getLocationName()}`)\r\n            .concat(`\\nLatitude:\\t\\t\\t${this.getLatitude().toString()}\\u00B0`)\r\n            .concat(`\\nLongitude:\\t\\t\\t${this.getLongitude().toString()}\\u00B0`)\r\n            .concat(`\\nElevation:\\t\\t\\t${this.getElevation().toString()} Meters`)\r\n            .concat(`\\nTimezone ID:\\t\\t\\t${this.getTimeZone()}`)\r\n            .concat(`\\nTimezone Display Name:\\t\\t${TimeZone.getDisplayName(this.getTimeZone())}`)\r\n            .concat(` (${TimeZone.getDisplayName(this.getTimeZone(), DateTime.local(), true)})`)\r\n            .concat(`\\nTimezone GMT Offset:\\t\\t${(TimeZone.getRawOffset(this.getTimeZone()) / GeoLocation.HOUR_MILLIS).toString()}`)\r\n            .concat(`\\nTimezone DST Offset:\\t\\t${(TimeZone.getDSTSavings(this.getTimeZone()) / GeoLocation.HOUR_MILLIS).toString()}`);\r\n    }\r\n    /**\r\n     * An implementation of the {@link java.lang.Object#clone()} method that creates a <a\r\n     * href=\"http://en.wikipedia.org/wiki/Object_copy#Deep_copy\">deep copy</a> of the object.\r\n     * <b>Note:</b> If the {@link java.util.TimeZone} in the clone will be changed from the original, it is critical\r\n     * that {@link net.sourceforge.zmanim.AstronomicalCalendar#getCalendar()}.\r\n     * {@link java.util.Calendar#setTimeZone(TimeZone) setTimeZone(TimeZone)} is called after cloning in order for the\r\n     * AstronomicalCalendar to output times in the expected offset.\r\n     *\r\n     * @see java.lang.Object#clone()\r\n     * @since 1.1\r\n     */\r\n    clone() {\r\n        return JSON.parse(JSON.stringify(this));\r\n    }\r\n}\r\nGeoLocation.DISTANCE = 0;\r\nGeoLocation.INITIAL_BEARING = 1;\r\nGeoLocation.FINAL_BEARING = 2;\r\n/** constant for milliseconds in a minute (60,000) */\r\nGeoLocation.MINUTE_MILLIS = 60 * 1000;\r\n/** constant for milliseconds in an hour (3,600,000) */\r\nGeoLocation.HOUR_MILLIS = GeoLocation.MINUTE_MILLIS * 60;\r\n//# sourceMappingURL=GeoLocation.js.map"]},"metadata":{},"sourceType":"module"}