{"ast":null,"code":"import { DateTime } from 'luxon';\nimport { Calendar, IntegerUtils } from '../polyfills/Utils';\nimport { IllegalArgumentException } from '../polyfills/errors';\n/**\r\n * The JewishDate is the base calendar class, that supports maintenance of a {@link java.util.GregorianCalendar}\r\n * instance along with the corresponding Jewish date. This class can use the standard Java Date and Calendar\r\n * classes for setting and maintaining the dates, but it does not subclass these classes or use them internally\r\n * in any calculations. This class also does not have a concept of a time (which the Date class does). Please\r\n * note that the calendar does not currently support dates prior to 1/1/1 Gregorian. Also keep in mind that the\r\n * Gregorian calendar started on October 15, 1582, so any calculations prior to that are suspect (at least from\r\n * a Gregorian perspective). While 1/1/1 Gregorian and forward are technically supported, any calculations prior to <a\r\n * href=\"http://en.wikipedia.org/wiki/Hillel_II\">Hillel II's (Hakatan's</a>) calendar (4119 in the Jewish Calendar / 359\r\n * CE Julian as recorded by <a href=\"http://en.wikipedia.org/wiki/Hai_Gaon\">Rav Hai Gaon</a>) would be just an\r\n * approximation.\r\n *\r\n * This open source Java code was written by <a href=\"http://www.facebook.com/avromf\">Avrom Finkelstien</a> from his C++\r\n * code. It was refactored to fit the KosherJava Zmanim API with simplification of the code, enhancements and some bug\r\n * fixing.\r\n *\r\n * Some of Avrom's original C++ code was translated from <a href=\"https://web.archive.org/web/20120124134148/http://emr.cs.uiuc.edu/~reingold/calendar.C\">C/C++\r\n * code</a> in <a href=\"http://www.calendarists.com\">Calendrical Calculations</a> by Nachum Dershowitz and Edward M.\r\n * Reingold, Software-- Practice &amp; Experience, vol. 20, no. 9 (September, 1990), pp. 899- 928. Any method with the mark\r\n * \"ND+ER\" indicates that the method was taken from this source with minor modifications.\r\n *\r\n * If you are looking for a class that implements a Jewish calendar version of the Calendar class, one is available from\r\n * the <a href=\"http://site.icu-project.org/\" >ICU (International Components for Unicode)</a> project, formerly part of\r\n * IBM's DeveloperWorks.\r\n *\r\n * @see net.sourceforge.zmanim.hebrewcalendar.JewishCalendar\r\n * @see net.sourceforge.zmanim.hebrewcalendar.HebrewDateFormatter\r\n * @see java.util.Date\r\n * @see java.util.Calendar\r\n * @author &copy; Avrom Finkelstien 2002\r\n * @author &copy; Eliyahu Hershfeld 2011 - 2015\r\n */\n\nexport class JewishDate {\n  constructor(jewishYearOrDateTimeOrDateOrMolad, jewishMonth, jewishDayOfMonth) {\n    if (!jewishYearOrDateTimeOrDateOrMolad) {\n      this.resetDate();\n    } else if (jewishMonth) {\n      this.setJewishDate(jewishYearOrDateTimeOrDateOrMolad, jewishMonth, jewishDayOfMonth);\n    } else if (jewishYearOrDateTimeOrDateOrMolad instanceof Date) {\n      this.setDate(DateTime.fromJSDate(jewishYearOrDateTimeOrDateOrMolad));\n    } else if (DateTime.isDateTime(jewishYearOrDateTimeOrDateOrMolad)) {\n      this.setDate(jewishYearOrDateTimeOrDateOrMolad);\n    } else if (typeof jewishYearOrDateTimeOrDateOrMolad === 'number') {\n      const molad = jewishYearOrDateTimeOrDateOrMolad;\n      this.absDateToDate(JewishDate.moladToAbsDate(molad)); // long chalakimSince = getChalakimSinceMoladTohu(year, JewishDate.TISHREI);// tishrei\n\n      const conjunctionDay = Math.trunc(molad / JewishDate.CHALAKIM_PER_DAY);\n      const conjunctionParts = Math.trunc(molad - conjunctionDay * JewishDate.CHALAKIM_PER_DAY);\n      this.setMoladTime(conjunctionParts);\n    }\n  }\n  /**\r\n   * Returns the molad hours. Only a JewishDate object populated with {@link #getMolad()},\r\n   * {@link #setJewishDate(int, int, int, int, int, int)} or {@link #setMoladHours(int)} will have this field\r\n   * populated. A regular JewishDate object will have this field set to 0.\r\n   *\r\n   * @return the molad hours\r\n   * @see #setMoladHours(int)\r\n   * @see #getMolad()\r\n   * @see #setJewishDate(int, int, int, int, int, int)\r\n   */\n\n\n  getMoladHours() {\n    return this.moladHours;\n  }\n  /**\r\n   * Sets the molad hours.\r\n   *\r\n   * @param moladHours\r\n   *            the molad hours to set\r\n   * @see #getMoladHours()\r\n   * @see #getMolad()\r\n   * @see #setJewishDate(int, int, int, int, int, int)\r\n   *\r\n   */\n\n\n  setMoladHours(moladHours) {\n    this.moladHours = moladHours;\n  }\n  /**\r\n   * Returns the molad minutes. Only an object populated with {@link #getMolad()},\r\n   * {@link #setJewishDate(int, int, int, int, int, int)} or or {@link #setMoladMinutes(int)} will have these fields\r\n   * populated. A regular JewishDate object will have this field set to 0.\r\n   *\r\n   * @return the molad minutes\r\n   * @see #setMoladMinutes(int)\r\n   * @see #getMolad()\r\n   * @see #setJewishDate(int, int, int, int, int, int)\r\n   */\n\n\n  getMoladMinutes() {\n    return this.moladMinutes;\n  }\n  /**\r\n   * Sets the molad minutes. The expectation is that the traditional minute-less chalakim will be broken out to\r\n   * minutes and {@link #setMoladChalakim(int) chalakim/parts} , so 793 (TaShTZaG) parts would have the minutes set to\r\n   * 44 and chalakim to 1.\r\n   *\r\n   * @param moladMinutes\r\n   *            the molad minutes to set\r\n   * @see #getMoladMinutes()\r\n   * @see #setMoladChalakim(int)\r\n   * @see #getMolad()\r\n   * @see #setJewishDate(int, int, int, int, int, int)\r\n   *\r\n   */\n\n\n  setMoladMinutes(moladMinutes) {\n    this.moladMinutes = moladMinutes;\n  }\n  /**\r\n   * Sets the molad chalakim/parts. The expectation is that the traditional minute-less chalakim will be broken out to\r\n   * {@link #setMoladMinutes(int) minutes} and chalakim, so 793 (TaShTZaG) parts would have the minutes set to 44 and\r\n   * chalakim to 1.\r\n   *\r\n   * @param moladChalakim\r\n   *            the molad chalakim/parts to set\r\n   * @see #getMoladChalakim()\r\n   * @see #setMoladMinutes(int)\r\n   * @see #getMolad()\r\n   * @see #setJewishDate(int, int, int, int, int, int)\r\n   *\r\n   */\n\n\n  setMoladChalakim(moladChalakim) {\n    this.moladChalakim = moladChalakim;\n  }\n  /**\r\n   * Returns the molad chalakim/parts. Only an object populated with {@link #getMolad()},\r\n   * {@link #setJewishDate(int, int, int, int, int, int)} or or {@link #setMoladChalakim(int)} will have these fields\r\n   * populated. A regular JewishDate object will have this field set to 0.\r\n   *\r\n   * @return the molad chalakim/parts\r\n   * @see #setMoladChalakim(int)\r\n   * @see #getMolad()\r\n   * @see #setJewishDate(int, int, int, int, int, int)\r\n   */\n\n\n  getMoladChalakim() {\n    return this.moladChalakim;\n  }\n  /**\r\n   * Returns the last day in a gregorian month\r\n   *\r\n   * @param month\r\n   *            the Gregorian month\r\n   * @return the last day of the Gregorian month\r\n   */\n\n\n  getLastDayOfGregorianMonth(month) {\n    return JewishDate.getLastDayOfGregorianMonth(month, this.gregorianYear);\n  }\n  /**\r\n   * Returns the number of days in a given month in a given month and year.\r\n   *\r\n   * @param month\r\n   *            the month. As with other cases in this class, this is 1-based, not zero-based.\r\n   * @param year\r\n   *            the year (only impacts February)\r\n   * @return the number of days in the month in the given year\r\n   */\n\n\n  static getLastDayOfGregorianMonth(month, year) {\n    switch (month) {\n      case 2:\n        if (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) {\n          return 29;\n        }\n\n        return 28;\n\n      case 4:\n      case 6:\n      case 9:\n      case 11:\n        return 30;\n\n      default:\n        return 31;\n    }\n  }\n  /**\r\n   * Computes the Gregorian date from the absolute date. ND+ER\r\n   * @param absDate - the absolute date\r\n   */\n\n\n  absDateToDate(absDate) {\n    let year = Math.trunc(absDate / 366); // Search forward year by year from approximate year\n\n    while (absDate >= JewishDate.gregorianDateToAbsDate(year + 1, 1, 1)) {\n      year++;\n    }\n\n    let month = 1; // Search forward month by month from January\n\n    while (absDate > JewishDate.gregorianDateToAbsDate(year, month, JewishDate.getLastDayOfGregorianMonth(month, year))) {\n      month++;\n    }\n\n    const dayOfMonth = absDate - JewishDate.gregorianDateToAbsDate(year, month, 1) + 1;\n    this.setInternalGregorianDate(year, month, dayOfMonth);\n  }\n  /**\r\n   * Returns the absolute date (days since January 1, 0001 on the Gregorian calendar).\r\n   *\r\n   * @return the number of days since January 1, 1\r\n   */\n\n\n  getAbsDate() {\n    return this.gregorianAbsDate;\n  }\n  /**\r\n   * Computes the absolute date from a Gregorian date. ND+ER\r\n   *\r\n   * @param year\r\n   *            the Gregorian year\r\n   * @param month\r\n   *            the Gregorian month. Unlike the Java Calendar where January has the value of 0,This expects a 1 for\r\n   *            January\r\n   * @param dayOfMonth\r\n   *            the day of the month (1st, 2nd, etc...)\r\n   * @return the absolute Gregorian day\r\n   */\n\n\n  static gregorianDateToAbsDate(year, month, dayOfMonth) {\n    let absDate = dayOfMonth;\n\n    for (let m = month - 1; m > 0; m--) {\n      absDate += JewishDate.getLastDayOfGregorianMonth(m, year); // days in prior months of the year\n    }\n\n    return absDate // days this year\n    + 365 * (year - 1) // days in previous years ignoring leap days\n    + Math.trunc((year - 1) / 4) // Julian leap days before this year\n    - Math.trunc((year - 1) / 100) // minus prior century years\n    + Math.trunc((year - 1) / 400); // plus prior years divisible by 400\n  }\n  /**\r\n   * Returns if the year is a Jewish leap year. Years 3, 6, 8, 11, 14, 17 and 19 in the 19 year cycle are leap years.\r\n   *\r\n   * @param year\r\n   *            the Jewish year.\r\n   * @return true if it is a leap year\r\n   * @see #isJewishLeapYear()\r\n   */\n\n\n  static isJewishLeapYear(year) {\n    return (7 * year + 1) % 19 < 7;\n  }\n  /**\r\n   * Returns if the year the calendar is set to is a Jewish leap year. Years 3, 6, 8, 11, 14, 17 and 19 in the 19 year\r\n   * cycle are leap years.\r\n   *\r\n   * @return true if it is a leap year\r\n   * @see #isJewishLeapYear(int)\r\n   */\n\n\n  isJewishLeapYear() {\n    return JewishDate.isJewishLeapYear(this.getJewishYear());\n  }\n  /**\r\n   * Returns the last month of a given Jewish year. This will be 12 on a non {@link #isJewishLeapYear(int) leap year}\r\n   * or 13 on a leap year.\r\n   *\r\n   * @param year\r\n   *            the Jewish year.\r\n   * @return 12 on a non leap year or 13 on a leap year\r\n   * @see #isJewishLeapYear(int)\r\n   */\n\n\n  static getLastMonthOfJewishYear(year) {\n    return JewishDate.isJewishLeapYear(year) ? JewishDate.ADAR_II : JewishDate.ADAR;\n  }\n  /**\r\n   * Returns the number of days elapsed from the Sunday prior to the start of the Jewish calendar to the mean\r\n   * conjunction of Tishri of the Jewish year.\r\n   *\r\n   * @param year\r\n   *            the Jewish year\r\n   * @return the number of days elapsed from prior to the molad Tohu BaHaRaD (Be = Monday, Ha= 5 hours and Rad =204\r\n   *         chalakim/parts) prior to the start of the Jewish calendar, to the mean conjunction of Tishri of the\r\n   *         Jewish year. BeHaRaD is 23:11:20 on Sunday night(5 hours 204/1080 chalakim after sunset on Sunday\r\n   *         evening).\r\n   */\n\n\n  static getJewishCalendarElapsedDays(year) {\n    const chalakimSince = JewishDate.getChalakimSinceMoladTohu(year, JewishDate.TISHREI);\n    const moladDay = Math.trunc(chalakimSince / JewishDate.CHALAKIM_PER_DAY);\n    const moladParts = Math.trunc(chalakimSince - moladDay * JewishDate.CHALAKIM_PER_DAY); // delay Rosh Hashana for the 4 dechiyos\n\n    return JewishDate.addDechiyos(year, moladDay, moladParts);\n  } // private static int getJewishCalendarElapsedDaysOLD(int year) {\n  // // Jewish lunar month = 29 days, 12 hours and 793 chalakim\n  // // Molad Tohu = BeHaRaD - Monday, 5 hours (11 PM) and 204 chalakim\n  // final int chalakimTashTZag = 793; // chalakim in a lunar month\n  // final int chalakimTohuRaD = 204; // chalakim from original molad Tohu BeHaRaD\n  // final int hoursTohuHa = 5; // hours from original molad Tohu BeHaRaD\n  // final int dayTohu = 1; // Monday (0 based)\n  //\n  // int monthsElapsed = (235 * ((year - 1) / 19)) // Months in complete 19 year lunar (Metonic) cycles so far\n  // + (12 * ((year - 1) % 19)) // Regular months in this cycle\n  // + ((7 * ((year - 1) % 19) + 1) / 19); // Leap months this cycle\n  // // start with Molad Tohu BeHaRaD\n  // // start with RaD of BeHaRaD and add TaShTzaG (793) chalakim plus elapsed chalakim\n  // int partsElapsed = chalakimTohuRaD + chalakimTashTZag * (monthsElapsed % 1080);\n  // // start with Ha hours of BeHaRaD, add 12 hour remainder of lunar month add hours elapsed\n  // int hoursElapsed = hoursTohuHa + 12 * monthsElapsed + 793 * (monthsElapsed / 1080) + partsElapsed / 1080;\n  // // start with Monday of BeHaRaD = 1 (0 based), add 29 days of the lunar months elapsed\n  // int conjunctionDay = dayTohu + 29 * monthsElapsed + hoursElapsed / 24;\n  // int conjunctionParts = 1080 * (hoursElapsed % 24) + partsElapsed % 1080;\n  // return addDechiyos(year, conjunctionDay, conjunctionParts);\n  // }\n\n  /**\r\n   * Adds the 4 dechiyos for molad Tishrei. These are:\r\n   * <ol>\r\n   * <li>Lo ADU Rosh - Rosh Hashana can't fall on a Sunday, Wednesday or Friday. If the molad fell on one of these\r\n   * days, Rosh Hashana is delayed to the following day.</li>\r\n   * <li>Molad Zaken - If the molad of Tishrei falls after 12 noon, Rosh Hashana is delayed to the following day. If\r\n   * the following day is ADU, it will be delayed an additional day.</li>\r\n   * <li>GaTRaD - If on a non leap year the molad of Tishrei falls on a Tuesday (Ga) on or after 9 hours (T) and 204\r\n   * chalakim (TRaD) it is delayed till Thursday (one day delay, plus one day for Lo ADU Rosh)</li>\r\n   * <li>BeTuTaKFoT - if the year following a leap year falls on a Monday (Be) on or after 15 hours (Tu) and 589\r\n   * chalakim (TaKFoT) it is delayed till Tuesday</li>\r\n   * </ol>\r\n   *\r\n   * @param year - the year\r\n   * @param moladDay - the molad day\r\n   * @param moladParts - the molad parts\r\n   * @return the number of elapsed days in the JewishCalendar adjusted for the 4 dechiyos.\r\n   */\n\n\n  static addDechiyos(year, moladDay, moladParts) {\n    let roshHashanaDay = moladDay; // if no dechiyos\n    // delay Rosh Hashana for the dechiyos of the Molad - new moon 1 - Molad Zaken, 2- GaTRaD 3- BeTuTaKFoT\n\n    if (moladParts >= 19440 || // Dechiya of Molad Zaken - molad is >= midday (18 hours * 1080 chalakim)\n    moladDay % 7 === 2 && // start Dechiya of GaTRaD - Ga = is a Tuesday\n    moladParts >= 9924 // TRaD = 9 hours, 204 parts or later (9 * 1080 + 204)\n    && !JewishDate.isJewishLeapYear(year) // of a non-leap year - end Dechiya of GaTRaD\n    || moladDay % 7 === 1 && // start Dechiya of BeTuTaKFoT - Be = is on a Monday\n    moladParts >= 16789 // TRaD = 15 hours, 589 parts or later (15 * 1080 + 589)\n    && JewishDate.isJewishLeapYear(year - 1)) {\n      // in a year following a leap year - end Dechiya of BeTuTaKFoT\n      roshHashanaDay += 1; // Then postpone Rosh HaShanah one day\n    } // start 4th Dechiya - Lo ADU Rosh - Rosh Hashana can't occur on A- sunday, D- Wednesday, U - Friday\n\n\n    if (roshHashanaDay % 7 === 0 || // If Rosh HaShanah would occur on Sunday,\n    roshHashanaDay % 7 === 3 // or Wednesday,\n    || roshHashanaDay % 7 === 5) {\n      // or Friday - end 4th Dechiya - Lo ADU Rosh\n      roshHashanaDay++; // Then postpone it one (more) day\n    }\n\n    return roshHashanaDay;\n  }\n  /**\r\n   * Returns the number of chalakim (parts - 1080 to the hour) from the original hypothetical Molad Tohu to the year\r\n   * and month passed in.\r\n   *\r\n   * @param year\r\n   *            the Jewish year\r\n   * @param month\r\n   *            the Jewish month the Jewish month, with the month numbers starting from Nisan. Use the JewishDate\r\n   *            constants such as {@link JewishDate#TISHREI}.\r\n   * @return the number of chalakim (parts - 1080 to the hour) from the original hypothetical Molad Tohu\r\n   */\n\n\n  static getChalakimSinceMoladTohu(year, month) {\n    // Jewish lunar month = 29 days, 12 hours and 793 chalakim\n    // chalakim since Molad Tohu BeHaRaD - 1 day, 5 hours and 204 chalakim\n    const monthOfYear = JewishDate.getJewishMonthOfYear(year, month);\n    const monthsElapsed = 235 * Math.trunc((year - 1) / 19) + // Months in complete 19 year lunar (Metonic) cycles so far\n    12 * ((year - 1) % 19) // Regular months in this cycle\n    + Math.trunc((7 * ((year - 1) % 19) + 1) / 19) // Leap months this cycle\n    + (monthOfYear - 1); // add elapsed months till the start of the molad of the month\n    // return chalakim prior to BeHaRaD + number of chalakim since\n\n    return JewishDate.CHALAKIM_MOLAD_TOHU + JewishDate.CHALAKIM_PER_MONTH * monthsElapsed;\n  }\n  /**\r\n   * Returns the number of chalakim (parts - 1080 to the hour) from the original hypothetical Molad Tohu to the Jewish\r\n   * year and month that this Object is set to.\r\n   *\r\n   * @return the number of chalakim (parts - 1080 to the hour) from the original hypothetical Molad Tohu\r\n   */\n\n\n  getChalakimSinceMoladTohu() {\n    return JewishDate.getChalakimSinceMoladTohu(this.jewishYear, this.jewishMonth);\n  }\n  /**\r\n   * Converts the {@link JewishDate#NISSAN} based constants used by this class to numeric month starting from\r\n   * {@link JewishDate#TISHREI}. This is required for Molad claculations.\r\n   *\r\n   * @param year\r\n   *            The Jewish year\r\n   * @param month\r\n   *            The Jewish Month\r\n   * @return the Jewish month of the year starting with Tishrei\r\n   */\n\n\n  static getJewishMonthOfYear(year, month) {\n    const isLeapYear = JewishDate.isJewishLeapYear(year);\n    return (month + (isLeapYear ? 6 : 5)) % (isLeapYear ? 13 : 12) + 1;\n  }\n  /**\r\n   * Validates the components of a Jewish date for validity. It will throw an {@link IllegalArgumentException} if the\r\n   * Jewish date is earlier than 18 Teves, 3761 (1/1/1 Gregorian), a month < 1 or > 12 (or 13 on a\r\n   * {@link #isJewishLeapYear(int) leap year}), the day of month is < 1 or > 30, an hour < 0 or > 23, a minute < 0 >\r\n   * 59 or chalakim < 0 > 17. For larger a larger number of chalakim such as 793 (TaShTzaG) break the chalakim into\r\n   * minutes (18 chalakim per minutes, so it would be 44 minutes and 1 chelek in the case of 793/TaShTzaG).\r\n   *\r\n   * @param year\r\n   *            the Jewish year to validate. It will reject any year <= 3761 (lower than the year 1 Gregorian).\r\n   * @param month\r\n   *            the Jewish month to validate. It will reject a month < 1 or > 12 (or 13 on a leap year) .\r\n   * @param dayOfMonth\r\n   *            the day of the Jewish month to validate. It will reject any value < 1 or > 30 TODO: check calling\r\n   *            methods to see if there is any reason that the class can validate that 30 is invalid for some months.\r\n   * @param hours\r\n   *            the hours (for molad calculations). It will reject an hour < 0 or > 23\r\n   * @param minutes\r\n   *            the minutes (for molad calculations). It will reject a minute < 0 or > 59\r\n   * @param chalakim\r\n   *            the chalakim/parts (for molad calculations). It will reject a chalakim < 0 or > 17. For larger numbers\r\n   *            such as 793 (TaShTzaG) break the chalakim into minutes (18 chalakim per minutes, so it would be 44\r\n   *            minutes and 1 chelek in the case of 793/TaShTzaG)\r\n   *\r\n   * @throws IllegalArgumentException\r\n   *             if a A Jewish date earlier than 18 Teves, 3761 (1/1/1 Gregorian), a month < 1 or > 12 (or 13 on a\r\n   *             leap year), the day of month is < 1 or > 30, an hour < 0 or > 23, a minute < 0 > 59 or chalakim < 0 >\r\n   *             17. For larger a larger number of chalakim such as 793 (TaShTzaG) break the chalakim into minutes (18\r\n   *             chalakim per minutes, so it would be 44 minutes and 1 chelek in the case of 793 (TaShTzaG).\r\n   */\n\n\n  static validateJewishDate(year, month, dayOfMonth, hours, minutes, chalakim) {\n    if (month < JewishDate.NISSAN || month > JewishDate.getLastMonthOfJewishYear(year)) {\n      throw new IllegalArgumentException(`The Jewish month has to be between 1 and 12 (or 13 on a leap year). ${month} is invalid for the year ${year}.`);\n    }\n\n    if (dayOfMonth < 1 || dayOfMonth > 30) {\n      throw new IllegalArgumentException(`The Jewish day of month can't be < 1 or > 30. ${dayOfMonth} is invalid.`);\n    } // reject dates prior to 18 Teves, 3761 (1/1/1 AD). This restriction can be relaxed if the date coding is\n    // changed/corrected\n\n\n    if (year < 3761 || year === 3761 && month >= JewishDate.TISHREI && month < JewishDate.TEVES || year === 3761 && month === JewishDate.TEVES && dayOfMonth < 18) {\n      throw new IllegalArgumentException(`A Jewish date earlier than 18 Teves, 3761 (1/1/1 Gregorian) can't be set. ${year}, ${month}, ${dayOfMonth} is invalid.`);\n    }\n\n    if (hours < 0 || hours > 23) {\n      throw new IllegalArgumentException(`Hours < 0 or > 23 can't be set. ${hours} is invalid.`);\n    }\n\n    if (minutes < 0 || minutes > 59) {\n      throw new IllegalArgumentException(`Minutes < 0 or > 59 can't be set. ${minutes} is invalid.`);\n    }\n\n    if (chalakim < 0 || chalakim > 17) {\n      throw new IllegalArgumentException(`Chalakim/parts < 0 or > 17 can't be set. ${chalakim} is invalid. For larger numbers such as 793 (TaShTzaG) break the chalakim into minutes (18 chalakim per minutes, so it would be 44 minutes and 1 chelek in the case of 793 (TaShTzaG)`);\n    }\n  }\n  /**\r\n   * Validates the components of a Gregorian date for validity. It will throw an {@link IllegalArgumentException} if a\r\n   * year of < 1, a month < 0 or > 11 or a day of month < 1 is passed in.\r\n   *\r\n   * @param year\r\n   *            the Gregorian year to validate. It will reject any year < 1.\r\n   * @param month\r\n   *            the Gregorian month number to validate. It will enforce that the month is between 0 - 11 like a\r\n   *            {@link GregorianCalendar}, where {@link Calendar#JANUARY} has a value of 0.\r\n   * @param dayOfMonth\r\n   *            the day of the Gregorian month to validate. It will reject any value < 1, but will allow values > 31\r\n   *            since calling methods will simply set it to the maximum for that month. TODO: check calling methods to\r\n   *            see if there is any reason that the class needs days > the maximum.\r\n   * @throws IllegalArgumentException\r\n   *             if a year of < 1, a month < 0 or > 11 or a day of month < 1 is passed in\r\n   * @see #validateGregorianYear(int)\r\n   * @see #validateGregorianMonth(int)\r\n   * @see #validateGregorianDayOfMonth(int)\r\n   */\n\n\n  static validateGregorianDate(year, month, dayOfMonth) {\n    JewishDate.validateGregorianMonth(month);\n    JewishDate.validateGregorianDayOfMonth(dayOfMonth);\n    JewishDate.validateGregorianYear(year);\n  }\n  /**\r\n   * Validates a Gregorian month for validity.\r\n   *\r\n   * @param month\r\n   *            the Gregorian month number to validate. It will enforce that the month is between 0 - 11 like a\r\n   *            {@link GregorianCalendar}, where {@link Calendar#JANUARY} has a value of 0.\r\n   */\n\n\n  static validateGregorianMonth(month) {\n    if (month > 11 || month < 0) {\n      throw new IllegalArgumentException(`The Gregorian month has to be between 0 - 11. ${month} is invalid.`);\n    }\n  }\n  /**\r\n   * Validates a Gregorian day of month for validity.\r\n   *\r\n   * @param dayOfMonth\r\n   *            the day of the Gregorian month to validate. It will reject any value < 1, but will allow values > 31\r\n   *            since calling methods will simply set it to the maximum for that month. TODO: check calling methods to\r\n   *            see if there is any reason that the class needs days > the maximum.\r\n   */\n\n\n  static validateGregorianDayOfMonth(dayOfMonth) {\n    if (dayOfMonth <= 0) {\n      throw new IllegalArgumentException(`The day of month can't be less than 1. ${dayOfMonth} is invalid.`);\n    }\n  }\n  /**\r\n   * Validates a Gregorian year for validity.\r\n   *\r\n   * @param year\r\n   *            the Gregorian year to validate. It will reject any year < 1.\r\n   */\n\n\n  static validateGregorianYear(year) {\n    if (year < 1) {\n      throw new IllegalArgumentException(`Years < 1 can't be calculated. ${year} is invalid.`);\n    }\n  }\n  /**\r\n   * Returns the number of days for a given Jewish year. ND+ER\r\n   *\r\n   * @param year\r\n   *            the Jewish year\r\n   * @return the number of days for a given Jewish year.\r\n   * @see #isCheshvanLong()\r\n   * @see #isKislevShort()\r\n   */\n\n\n  static getDaysInJewishYear(year) {\n    return JewishDate.getJewishCalendarElapsedDays(year + 1) - JewishDate.getJewishCalendarElapsedDays(year);\n  }\n  /**\r\n   * Returns the number of days for the current year that the calendar is set to.\r\n   *\r\n   * @return the number of days for the Object's current Jewish year.\r\n   * @see #isCheshvanLong()\r\n   * @see #isKislevShort()\r\n   * @see #isJewishLeapYear()\r\n   */\n\n\n  getDaysInJewishYear() {\n    return JewishDate.getDaysInJewishYear(this.getJewishYear());\n  }\n  /**\r\n   * Returns if Cheshvan is long in a given Jewish year. The method name isLong is done since in a Kesidran (ordered)\r\n   * year Cheshvan is short. ND+ER\r\n   *\r\n   * @param year\r\n   *            the year\r\n   * @return true if Cheshvan is long in Jewish year.\r\n   * @see #isCheshvanLong()\r\n   * @see #getCheshvanKislevKviah()\r\n   */\n\n\n  static isCheshvanLong(year) {\n    return JewishDate.getDaysInJewishYear(year) % 10 === 5;\n  }\n  /**\r\n   * Returns if Cheshvan is long (30 days VS 29 days) for the current year that the calendar is set to. The method\r\n   * name isLong is done since in a Kesidran (ordered) year Cheshvan is short.\r\n   *\r\n   * @return true if Cheshvan is long for the current year that the calendar is set to\r\n   * @see #isCheshvanLong()\r\n   */\n\n\n  isCheshvanLong() {\n    return JewishDate.isCheshvanLong(this.getJewishYear());\n  }\n  /**\r\n   * Returns if Kislev is short (29 days VS 30 days) in a given Jewish year. The method name isShort is done since in\r\n   * a Kesidran (ordered) year Kislev is long. ND+ER\r\n   *\r\n   * @param year\r\n   *            the Jewish year\r\n   * @return true if Kislev is short for the given Jewish year.\r\n   * @see #isKislevShort()\r\n   * @see #getCheshvanKislevKviah()\r\n   */\n\n\n  static isKislevShort(year) {\n    return JewishDate.getDaysInJewishYear(year) % 10 === 3;\n  }\n  /**\r\n   * Returns if the Kislev is short for the year that this class is set to. The method name isShort is done since in a\r\n   * Kesidran (ordered) year Kislev is long.\r\n   *\r\n   * @return true if Kislev is short for the year that this class is set to\r\n   */\n\n\n  isKislevShort() {\n    return JewishDate.isKislevShort(this.getJewishYear());\n  }\n  /**\r\n   * Returns the Cheshvan and Kislev kviah (whether a Jewish year is short, regular or long). It will return\r\n   * {@link #SHELAIMIM} if both cheshvan and kislev are 30 days, {@link #KESIDRAN} if Cheshvan is 29 days and Kislev\r\n   * is 30 days and {@link #CHASERIM} if both are 29 days.\r\n   *\r\n   * @return {@link #SHELAIMIM} if both cheshvan and kislev are 30 days, {@link #KESIDRAN} if Cheshvan is 29 days and\r\n   *         Kislev is 30 days and {@link #CHASERIM} if both are 29 days.\r\n   * @see #isCheshvanLong()\r\n   * @see #isKislevShort()\r\n   */\n\n\n  getCheshvanKislevKviah() {\n    if (this.isCheshvanLong() && !this.isKislevShort()) {\n      return JewishDate.SHELAIMIM;\n    } else if (!this.isCheshvanLong() && this.isKislevShort()) {\n      return JewishDate.CHASERIM;\n    }\n\n    return JewishDate.KESIDRAN;\n  }\n  /**\r\n   * Returns the number of days of a Jewish month for a given month and year.\r\n   *\r\n   * @param month\r\n   *            the Jewish month\r\n   * @param year\r\n   *            the Jewish Year\r\n   * @return the number of days for a given Jewish month\r\n   */\n\n\n  static getDaysInJewishMonth(month, year) {\n    const shortMonths = [JewishDate.IYAR, JewishDate.TAMMUZ, JewishDate.ELUL, JewishDate.ADAR_II];\n\n    if (shortMonths.includes(month) || month === JewishDate.CHESHVAN && !JewishDate.isCheshvanLong(year) || month === JewishDate.KISLEV && JewishDate.isKislevShort(year) || month === JewishDate.TEVES || month === JewishDate.ADAR && !JewishDate.isJewishLeapYear(year)) {\n      return 29;\n    }\n\n    return 30;\n  }\n  /**\r\n   * Returns the number of days of the Jewish month that the calendar is currently set to.\r\n   *\r\n   * @return the number of days for the Jewish month that the calendar is currently set to.\r\n   */\n\n\n  getDaysInJewishMonth() {\n    return JewishDate.getDaysInJewishMonth(this.getJewishMonth(), this.getJewishYear());\n  }\n  /**\r\n   * Computes the Jewish date from the absolute date. ND+ER\r\n   */\n\n\n  absDateToJewishDate() {\n    // Approximation from below\n    this.jewishYear = Math.trunc((this.gregorianAbsDate - JewishDate.JEWISH_EPOCH) / 366); // Search forward for year from the approximation\n\n    while (this.gregorianAbsDate >= JewishDate.jewishDateToAbsDate(this.jewishYear + 1, JewishDate.TISHREI, 1)) {\n      this.jewishYear++;\n    } // Search forward for month from either Tishri or Nisan.\n\n\n    if (this.gregorianAbsDate < JewishDate.jewishDateToAbsDate(this.jewishYear, JewishDate.NISSAN, 1)) {\n      this.jewishMonth = JewishDate.TISHREI; // Start at Tishri\n    } else {\n      this.jewishMonth = JewishDate.NISSAN; // Start at Nisan\n    }\n\n    while (this.gregorianAbsDate > JewishDate.jewishDateToAbsDate(this.jewishYear, this.jewishMonth, this.getDaysInJewishMonth())) {\n      this.jewishMonth++;\n    } // Calculate the day by subtraction\n\n\n    this.jewishDay = this.gregorianAbsDate - JewishDate.jewishDateToAbsDate(this.jewishYear, this.jewishMonth, 1) + 1;\n  }\n  /**\r\n   * Returns the absolute date of Jewish date. ND+ER\r\n   *\r\n   * @param year\r\n   *            the Jewish year. The year can't be negative\r\n   * @param month\r\n   *            the Jewish month starting with Nisan. Nisan expects a value of 1 etc till Adar with a value of 12. For\r\n   *            a leap year, 13 will be the expected value for Adar II. Use the constants {@link JewishDate#NISSAN}\r\n   *            etc.\r\n   * @param dayOfMonth\r\n   *            the Jewish day of month. valid values are 1-30. If the day of month is set to 30 for a month that only\r\n   *            has 29 days, the day will be set as 29.\r\n   * @return the absolute date of the Jewish date.\r\n   */\n\n\n  static jewishDateToAbsDate(year, month, dayOfMonth) {\n    const elapsed = JewishDate.getDaysSinceStartOfJewishYear(year, month, dayOfMonth); // add elapsed days this year + Days in prior years + Days elapsed before absolute year 1\n\n    return elapsed + JewishDate.getJewishCalendarElapsedDays(year) + JewishDate.JEWISH_EPOCH;\n  }\n  /**\r\n   * Returns the molad for a given year and month. Returns a JewishDate {@link Object} set to the date of the molad\r\n   * with the {@link #getMoladHours() hours}, {@link #getMoladMinutes() minutes} and {@link #getMoladChalakim()\r\n     * chalakim} set. In the current implementation, it sets the molad time based on a midnight date rollover. This\r\n   * means that Rosh Chodesh Adar II, 5771 with a molad of 7 chalakim past midnight on Shabbos 29 Adar I / March 5,\r\n   * 2011 12:00 AM and 7 chalakim, will have the following values: hours: 0, minutes: 0, Chalakim: 7.\r\n   *\r\n   * @return a JewishDate {@link Object} set to the date of the molad with the {@link #getMoladHours() hours},\r\n   *         {@link #getMoladMinutes() minutes} and {@link #getMoladChalakim() chalakim} set.\r\n   */\n\n\n  getMolad() {\n    const moladDate = new JewishDate(this.getChalakimSinceMoladTohu());\n\n    if (moladDate.getMoladHours() >= 6) {\n      moladDate.forward(Calendar.DATE, 1);\n    }\n\n    moladDate.setMoladHours((moladDate.getMoladHours() + 18) % 24);\n    return moladDate;\n  }\n  /**\r\n   * Returns the number of days from the Jewish epoch from the number of chalakim from the epoch passed in.\r\n   *\r\n   * @param chalakim\r\n   *            the number of chalakim since the beginning of Sunday prior to BaHaRaD\r\n   * @return the number of days from the Jewish epoch\r\n   */\n\n\n  static moladToAbsDate(chalakim) {\n    return Math.trunc(chalakim / JewishDate.CHALAKIM_PER_DAY) + JewishDate.JEWISH_EPOCH;\n  }\n  /**\r\n   * Constructor that creates a JewishDate based on a molad passed in. The molad would be the number of chalakim/parts\r\n   * starting at the beginning of Sunday prior to the molad Tohu BeHaRaD (Be = Monday, Ha= 5 hours and Rad =204\r\n   * chalakim/parts) - prior to the start of the Jewish calendar. BeHaRaD is 23:11:20 on Sunday night(5 hours 204/1080\r\n   * chalakim after sunset on Sunday evening).\r\n   *\r\n   * @param molad the number of chalakim since the beginning of Sunday prior to BaHaRaD\r\n   */\n\n  /*\r\n      public JewishDate(molad: number) {\r\n          this.absDateToDate(JewishDate.moladToAbsDate(molad));\r\n          // long chalakimSince = getChalakimSinceMoladTohu(year, JewishDate.TISHREI);// tishrei\r\n          const conjunctionDay: number = Math.trunc(molad / JewishDate.CHALAKIM_PER_DAY);\r\n          const conjunctionParts: number = Math.trunc(molad - conjunctionDay * JewishDate.CHALAKIM_PER_DAY);\r\n          this.setMoladTime(conjunctionParts);\r\n      }\r\n  */\n\n  /**\r\n   * Sets the molad time (hours minutes and chalakim) based on the number of chalakim since the start of the day.\r\n   *\r\n   * @param chalakim\r\n   *            the number of chalakim since the start of the day.\r\n   */\n\n\n  setMoladTime(chalakim) {\n    let adjustedChalakim = chalakim;\n    this.setMoladHours(Math.trunc(adjustedChalakim / JewishDate.CHALAKIM_PER_HOUR));\n    adjustedChalakim = adjustedChalakim - this.getMoladHours() * JewishDate.CHALAKIM_PER_HOUR;\n    this.setMoladMinutes(Math.trunc(adjustedChalakim / JewishDate.CHALAKIM_PER_MINUTE));\n    this.setMoladChalakim(adjustedChalakim - this.moladMinutes * JewishDate.CHALAKIM_PER_MINUTE);\n  }\n  /**\r\n   * returns the number of days from Rosh Hashana of the date passed in, to the full date passed in.\r\n   *\r\n   * @return the number of days\r\n   */\n\n\n  getDaysSinceStartOfJewishYear() {\n    return JewishDate.getDaysSinceStartOfJewishYear(this.getJewishYear(), this.getJewishMonth(), this.getJewishDayOfMonth());\n  }\n  /**\r\n   * returns the number of days from Rosh Hashana of the date passed in, to the full date passed in.\r\n   *\r\n   * @param year\r\n   *            the Jewish year\r\n   * @param month\r\n   *            the Jewish month\r\n   * @param dayOfMonth\r\n   *            the day in the Jewish month\r\n   * @return the number of days\r\n   */\n\n\n  static getDaysSinceStartOfJewishYear(year, month, dayOfMonth) {\n    let elapsedDays = dayOfMonth; // Before Tishrei (from Nissan to Tishrei), add days in prior months\n\n    if (month < JewishDate.TISHREI) {\n      // this year before and after Nisan.\n      for (let m = JewishDate.TISHREI; m <= JewishDate.getLastMonthOfJewishYear(year); m++) {\n        elapsedDays += JewishDate.getDaysInJewishMonth(m, year);\n      }\n\n      for (let m = JewishDate.NISSAN; m < month; m++) {\n        elapsedDays += JewishDate.getDaysInJewishMonth(m, year);\n      }\n    } else {\n      // Add days in prior months this year\n      for (let m = JewishDate.TISHREI; m < month; m++) {\n        elapsedDays += JewishDate.getDaysInJewishMonth(m, year);\n      }\n    }\n\n    return elapsedDays;\n  }\n  /**\r\n   * Creates a Jewish date based on a Jewish year, month and day of month.\r\n   *\r\n   * @param jewishYear\r\n   *            the Jewish year\r\n   * @param jewishMonth\r\n   *            the Jewish month. The method expects a 1 for Nissan ... 12 for Adar and 13 for Adar II. Use the\r\n   *            constants {@link #NISSAN} ... {@link #ADAR} (or {@link #ADAR_II} for a leap year Adar II) to avoid any\r\n   *            confusion.\r\n   * @param jewishDayOfMonth\r\n   *            the Jewish day of month. If 30 is passed in for a month with only 29 days (for example {@link #IYAR},\r\n   *            or {@link #KISLEV} in a year that {@link #isKislevShort()}), the 29th (last valid date of the month)\r\n   *            will be set\r\n   * @throws IllegalArgumentException\r\n   *             if the day of month is &lt; 1 or &gt; 30, or a year of &lt; 0 is passed in.\r\n   */\n\n  /*\r\n      public JewishDate(jewishYear: number, jewishMonth: number, jewishDayOfMonth: number) {\r\n          this.setJewishDate(jewishYear, jewishMonth, jewishDayOfMonth);\r\n      }\r\n  */\n\n  /**\r\n   * Default constructor will set a default date to the current system date.\r\n   */\n\n  /*\r\n      public JewishDate() {\r\n          this.resetDate();\r\n      }\r\n  */\n\n  /**\r\n   * A constructor that initializes the date to the {@link java.util.Date Date} paremeter.\r\n   *\r\n   * @param date\r\n   *            the <code>Date</code> to set the calendar to\r\n   * @throws IllegalArgumentException\r\n   *             if the date would fall prior to the January 1, 1 AD\r\n   */\n\n  /*\r\n      public JewishDate(date: Date) {\r\n          this.setDate(date);\r\n      }\r\n  */\n\n  /**\r\n   * A constructor that initializes the date to the {@link java.util.Calendar Calendar} paremeter.\r\n   *\r\n   * @param calendar\r\n   *            the <code>Calendar</code> to set the calendar to\r\n   * @throws IllegalArgumentException\r\n   *             if the {@link Calendar#ERA} is {@link GregorianCalendar#BC}\r\n   */\n\n  /*\r\n      public JewishDate(calendar: GregorianCalendar) {\r\n          this.setDate(calendar);\r\n      }\r\n  */\n\n  /**\r\n   * Sets the date based on a {@link java.util.Calendar Calendar} object. Modifies the Jewish date as well.\r\n   *\r\n   * @param date\r\n   *            the <code>Calendar</code> to set the calendar to\r\n   * @throws IllegalArgumentException\r\n   *             if the {@link Calendar#ERA} is {@link GregorianCalendar#BC}\r\n   */\n\n\n  setDate(date) {\n    if (date.year < 1) {\n      throw new IllegalArgumentException(`Dates with a BC era are not supported. The year ${date.year} is invalid.`);\n    }\n\n    this.gregorianMonth = date.month;\n    this.gregorianDayOfMonth = date.day;\n    this.gregorianYear = date.year;\n    this.gregorianAbsDate = JewishDate.gregorianDateToAbsDate(this.gregorianYear, this.gregorianMonth, this.gregorianDayOfMonth); // init the date\n\n    this.absDateToJewishDate();\n    this.dayOfWeek = Math.abs(this.gregorianAbsDate % 7) + 1; // set day of week\n  }\n  /**\r\n   * Sets the date based on a {@link java.util.Date Date} object. Modifies the Jewish date as well.\r\n   *\r\n   * @param date\r\n   *            the <code>Date</code> to set the calendar to\r\n   * @throws IllegalArgumentException\r\n   *             if the date would fall prior to the year 1 AD\r\n   */\n\n  /*\r\n      public setDate(date: Date): void {\r\n          const cal: GregorianCalendar = new GregorianCalendar();\r\n          cal.setTime(date);\r\n          this.setDate(cal);\r\n      }\r\n  */\n\n  /**\r\n   * Sets the Gregorian Date, and updates the Jewish date accordingly. Like the Java Calendar A value of 0 is expected\r\n   * for January.\r\n   *\r\n   * @param year\r\n   *            the Gregorian year\r\n   * @param month\r\n   *            the Gregorian month. Like the Java Calendar, this class expects 0 for January\r\n   * @param dayOfMonth\r\n   *            the Gregorian day of month. If this is &gt; the number of days in the month/year, the last valid date of\r\n   *            the month will be set\r\n   * @throws IllegalArgumentException\r\n   *             if a year of &lt; 1, a month &lt; 0 or &gt; 11 or a day of month &lt; 1 is passed in\r\n   */\n\n\n  setGregorianDate(year, month, dayOfMonth) {\n    JewishDate.validateGregorianDate(year, month, dayOfMonth);\n    this.setInternalGregorianDate(year, month + 1, dayOfMonth);\n  }\n  /**\r\n   * Sets the hidden internal representation of the Gregorian date , and updates the Jewish date accordingly. While\r\n   * public getters and setters have 0 based months matching the Java Calendar classes, This class internally\r\n   * represents the Gregorian month starting at 1. When this is called it will not adjust the month to match the Java\r\n   * Calendar classes.\r\n   *\r\n   * @param year - the year\r\n   * @param month - the month\r\n   * @param dayOfMonth - the day of month\r\n   */\n\n\n  setInternalGregorianDate(year, month, dayOfMonth) {\n    // make sure date is a valid date for the given month, if not, set to last day of month\n    if (dayOfMonth > JewishDate.getLastDayOfGregorianMonth(month, year)) {\n      dayOfMonth = JewishDate.getLastDayOfGregorianMonth(month, year);\n    } // init month, date, year\n\n\n    this.gregorianMonth = month;\n    this.gregorianDayOfMonth = dayOfMonth;\n    this.gregorianYear = year;\n    this.gregorianAbsDate = JewishDate.gregorianDateToAbsDate(this.gregorianYear, this.gregorianMonth, this.gregorianDayOfMonth); // init date\n\n    this.absDateToJewishDate();\n    this.dayOfWeek = Math.abs(this.gregorianAbsDate % 7) + 1; // set day of week\n  }\n\n  setJewishDate(year, month, dayOfMonth, hours = 0, minutes = 0, chalakim = 0) {\n    JewishDate.validateJewishDate(year, month, dayOfMonth, hours, minutes, chalakim); // if 30 is passed for a month that only has 29 days (for example by rolling the month from a month that had 30\n    // days to a month that only has 29) set the date to 29th\n\n    if (dayOfMonth > JewishDate.getDaysInJewishMonth(month, year)) {\n      dayOfMonth = JewishDate.getDaysInJewishMonth(month, year);\n    }\n\n    this.jewishMonth = month;\n    this.jewishDay = dayOfMonth;\n    this.jewishYear = year;\n    this.moladHours = hours;\n    this.moladMinutes = minutes;\n    this.moladChalakim = chalakim;\n    this.gregorianAbsDate = JewishDate.jewishDateToAbsDate(this.jewishYear, this.jewishMonth, this.jewishDay); // reset Gregorian date\n\n    this.absDateToDate(this.gregorianAbsDate);\n    this.dayOfWeek = Math.abs(this.gregorianAbsDate % 7) + 1; // reset day of week\n  }\n  /**\r\n   * Returns this object's date as a {@link java.util.Calendar} object.\r\n   *\r\n   * @return The {@link java.util.Calendar}\r\n   */\n\n\n  getDate() {\n    return DateTime.fromObject({\n      year: this.gregorianYear,\n      month: this.gregorianMonth,\n      day: this.gregorianDayOfMonth\n    });\n  }\n  /**\r\n   * Resets this date to the current system date.\r\n   */\n\n\n  resetDate() {\n    this.setDate(DateTime.local());\n  }\n  /**\r\n   * Returns a string containing the Jewish date in the form, \"day Month, year\" e.g. \"21 Shevat, 5729\". For more\r\n   * complex formatting, use the formatter classes.\r\n   *\r\n   * This functionality is duplicated from {@link HebrewDateFormatter} to avoid circular dependencies.\r\n   *\r\n   * @return the Jewish date in the form \"day Month, year\" e.g. \"21 Shevat, 5729\"\r\n   * @see HebrewDateFormatter#format(JewishDate)\r\n   */\n\n\n  toString() {\n    const transliteratedMonths = ['Nissan', 'Iyar', 'Sivan', 'Tammuz', 'Av', 'Elul', 'Tishrei', 'Cheshvan', 'Kislev', 'Teves', 'Shevat', 'Adar', 'Adar II', 'Adar I'];\n    let formattedMonth;\n\n    if (this.isJewishLeapYear() && this.jewishMonth === JewishDate.ADAR) {\n      formattedMonth = transliteratedMonths[13]; // return Adar I, not Adar in a leap year\n    } else {\n      formattedMonth = transliteratedMonths[this.jewishMonth - 1];\n    }\n\n    return `${this.getJewishDayOfMonth()} ${formattedMonth}, ${this.getJewishYear()}`;\n  }\n  /**\r\n   * Rolls the date, month or year forward by the amount passed in. It modifies both the Gregorian and Jewish dates\r\n   * accordingly. If manipulation beyond the fields supported here is required, use the {@link Calendar} class\r\n   * {@link Calendar#add(int, int)} or {@link Calendar#roll(int, int)} methods in the following manner.\r\n   *\r\n   * <pre>\r\n   * <code>\r\n   *     Calendar cal = jewishDate.getTime(); // get a java.util.Calendar representation of the JewishDate\r\n   *     cal.add(Calendar.MONTH, 3); // add 3 Gregorian months\r\n   *     jewishDate.setDate(cal); // set the updated calendar back to this class\r\n   * </code>\r\n   * </pre>\r\n   *\r\n   * @param field the calendar field to be forwarded. The must be {@link Calendar#DATE}, {@link Calendar#MONTH} or {@link Calendar#YEAR}\r\n   * @param amount the positive amount to move forward\r\n   * @throws IllegalArgumentException if the field is anything besides {@link Calendar#DATE}, {@link Calendar#MONTH}\r\n   * or {@link Calendar#YEAR} or if the amount is less than 1\r\n   *\r\n   * @see #back()\r\n   * @see Calendar#add(int, int)\r\n   * @see Calendar#roll(int, int)\r\n   */\n\n\n  forward(field, amount) {\n    if (field !== Calendar.DATE && field !== Calendar.MONTH && field !== Calendar.YEAR) {\n      throw new IllegalArgumentException('Unsupported field was passed to Forward. Only Calendar.DATE, Calendar.MONTH or Calendar.YEAR are supported.');\n    }\n\n    if (amount < 1) {\n      throw new IllegalArgumentException('JewishDate.forward() does not support amounts less than 1. See JewishDate.back()');\n    }\n\n    if (field === Calendar.DATE) {\n      // Change Gregorian date\n      for (let i = 0; i < amount; i++) {\n        if (this.gregorianDayOfMonth === JewishDate.getLastDayOfGregorianMonth(this.gregorianMonth, this.gregorianYear)) {\n          this.gregorianDayOfMonth = 1; // if last day of year\n\n          if (this.gregorianMonth === 12) {\n            this.gregorianYear++;\n          } else {\n            this.gregorianMonth++;\n          }\n        } else {\n          // if not last day of month\n          this.gregorianDayOfMonth++;\n        } // Change the Jewish Date\n\n\n        if (this.jewishDay === this.getDaysInJewishMonth()) {\n          // if it last day of elul (i.e. last day of Jewish year)\n          if (this.jewishMonth === JewishDate.ELUL) {\n            this.jewishYear++;\n            this.jewishMonth++;\n            this.jewishDay = 1;\n          } else if (this.jewishMonth === JewishDate.getLastMonthOfJewishYear(this.jewishYear)) {\n            // if it is the last day of Adar, or Adar II as case may be\n            this.jewishMonth = JewishDate.NISSAN;\n            this.jewishDay = 1;\n          } else {\n            this.jewishMonth++;\n            this.jewishDay = 1;\n          }\n        } else {\n          // if not last date of month\n          this.jewishDay++;\n        }\n\n        if (this.dayOfWeek === 7) {\n          // if last day of week, loop back to Sunday\n          this.dayOfWeek = 1;\n        } else {\n          this.dayOfWeek++;\n        } // increment the absolute date\n\n\n        this.gregorianAbsDate++;\n      }\n    } else if (field === Calendar.MONTH) {\n      this.forwardJewishMonth(amount);\n    } else if (field === Calendar.YEAR) {\n      this.setJewishYear(this.getJewishYear() + amount);\n    }\n  }\n  /**\r\n   * Forward the Jewish date by the number of months passed in.\r\n   * FIXME: Deal with forwarding a date such as 30 Nisan by a month. 30 Iyar does not exist. This should be dealt with similar to\r\n   * the way that the Java Calendar behaves (not that simple since there is a difference between add() or roll().\r\n   *\r\n   * @throws IllegalArgumentException if the amount is less than 1\r\n   * @param amount the number of months to roll the month forward\r\n   */\n\n\n  forwardJewishMonth(amount) {\n    if (amount < 1) {\n      throw new IllegalArgumentException('the amount of months to forward has to be greater than zero.');\n    }\n\n    for (let i = 0; i < amount; i++) {\n      if (this.getJewishMonth() === JewishDate.ELUL) {\n        this.setJewishMonth(JewishDate.TISHREI);\n        this.setJewishYear(this.getJewishYear() + 1);\n      } else if (!this.isJewishLeapYear() && this.getJewishMonth() === JewishDate.ADAR || this.isJewishLeapYear() && this.getJewishMonth() === JewishDate.ADAR_II) {\n        this.setJewishMonth(JewishDate.NISSAN);\n      } else {\n        this.setJewishMonth(this.getJewishMonth() + 1);\n      }\n    }\n  }\n  /**\r\n   * Rolls the date back by 1 day. It modifies both the Gregorian and Jewish dates accordingly. The API does not\r\n   * currently offer the ability to forward more than one day t a time, or to forward by month or year. If such\r\n   * manipulation is required use the {@link Calendar} class {@link Calendar#add(int, int)} or\r\n   * {@link Calendar#roll(int, int)} methods in the following manner.\r\n   *\r\n   * <pre>\r\n   * <code>\r\n   *     Calendar cal = jewishDate.getTime(); // get a java.util.Calendar representation of the JewishDate\r\n   *     cal.add(Calendar.MONTH, -3); // subtract 3 Gregorian months\r\n   *     jewishDate.setDate(cal); // set the updated calendar back to this class\r\n   * </code>\r\n   * </pre>\r\n   *\r\n   * @see #back()\r\n   * @see Calendar#add(int, int)\r\n   * @see Calendar#roll(int, int)\r\n   */\n\n\n  back() {\n    // Change Gregorian date\n    if (this.gregorianDayOfMonth === 1) {\n      // if first day of month\n      if (this.gregorianMonth === 1) {\n        // if first day of year\n        this.gregorianMonth = 12;\n        this.gregorianYear--;\n      } else {\n        this.gregorianMonth--;\n      } // change to last day of previous month\n\n\n      this.gregorianDayOfMonth = JewishDate.getLastDayOfGregorianMonth(this.gregorianMonth, this.gregorianYear);\n    } else {\n      this.gregorianDayOfMonth--;\n    } // change Jewish date\n\n\n    if (this.jewishDay === 1) {\n      // if first day of the Jewish month\n      if (this.jewishMonth === JewishDate.NISSAN) {\n        this.jewishMonth = JewishDate.getLastMonthOfJewishYear(this.jewishYear);\n      } else if (this.jewishMonth === JewishDate.TISHREI) {\n        // if Rosh Hashana\n        this.jewishYear--;\n        this.jewishMonth--;\n      } else {\n        this.jewishMonth--;\n      }\n\n      this.jewishDay = this.getDaysInJewishMonth();\n    } else {\n      this.jewishDay--;\n    }\n\n    if (this.dayOfWeek === 1) {\n      // if first day of week, loop back to Saturday\n      this.dayOfWeek = 7;\n    } else {\n      this.dayOfWeek--;\n    }\n\n    this.gregorianAbsDate--; // change the absolute date\n  }\n  /**\r\n   * @see Object#equals(Object)\r\n   */\n\n\n  equals(object) {\n    if (this === object) {\n      return true;\n    }\n\n    if (!(object instanceof JewishDate)) {\n      return false;\n    }\n\n    const jewishDate = object;\n    return this.gregorianAbsDate === jewishDate.getAbsDate();\n  }\n  /**\r\n   * Compares two dates as per the compareTo() method in the Comparable interface. Returns a value less than 0 if this\r\n   * date is \"less than\" (before) the date, greater than 0 if this date is \"greater than\" (after) the date, or 0 if\r\n   * they are equal.\r\n   */\n\n\n  compareTo(jewishDate) {\n    return IntegerUtils.compare(this.gregorianAbsDate, jewishDate.getAbsDate());\n  }\n  /**\r\n   * Returns the Gregorian month (between 0-11).\r\n   *\r\n   * @return the Gregorian month (between 0-11). Like the java.util.Calendar, months are 0 based.\r\n   */\n\n\n  getGregorianMonth() {\n    return this.gregorianMonth - 1;\n  }\n  /**\r\n   * Returns the Gregorian day of the month.\r\n   *\r\n   * @return the Gregorian day of the mont\r\n   */\n\n\n  getGregorianDayOfMonth() {\n    return this.gregorianDayOfMonth;\n  }\n  /**\r\n   * Returns the Gregotian year.\r\n   *\r\n   * @return the Gregorian year\r\n   */\n\n\n  getGregorianYear() {\n    return this.gregorianYear;\n  }\n  /**\r\n   * Returns the Jewish month 1-12 (or 13 years in a leap year). The month count starts with 1 for Nisan and goes to\r\n   * 13 for Adar II\r\n   *\r\n   * @return the Jewish month from 1 to 12 (or 13 years in a leap year). The month count starts with 1 for Nisan and\r\n   *         goes to 13 for Adar II\r\n   */\n\n\n  getJewishMonth() {\n    return this.jewishMonth;\n  }\n  /**\r\n   * Returns the Jewish day of month.\r\n   *\r\n   * @return the Jewish day of the month\r\n   */\n\n\n  getJewishDayOfMonth() {\n    return this.jewishDay;\n  }\n  /**\r\n   * Returns the Jewish year.\r\n   *\r\n   * @return the Jewish year\r\n   */\n\n\n  getJewishYear() {\n    return this.jewishYear;\n  }\n  /**\r\n   * Returns the day of the week as a number between 1-7.\r\n   *\r\n   * @return the day of the week as a number between 1-7.\r\n   */\n\n\n  getDayOfWeek() {\n    return this.dayOfWeek;\n  }\n  /**\r\n   * Sets the Gregorian month.\r\n   *\r\n   * @param month\r\n   *            the Gregorian month\r\n   *\r\n   * @throws IllegalArgumentException\r\n   *             if a month &lt; 0 or &gt; 11 is passed in\r\n   */\n\n\n  setGregorianMonth(month) {\n    JewishDate.validateGregorianMonth(month);\n    this.setInternalGregorianDate(this.gregorianYear, month + 1, this.gregorianDayOfMonth);\n  }\n  /**\r\n   * sets the Gregorian year.\r\n   *\r\n   * @param year\r\n   *            the Gregorian year.\r\n   * @throws IllegalArgumentException\r\n   *             if a year of &lt; 1 is passed in\r\n   */\n\n\n  setGregorianYear(year) {\n    JewishDate.validateGregorianYear(year);\n    this.setInternalGregorianDate(year, this.gregorianMonth, this.gregorianDayOfMonth);\n  }\n  /**\r\n   * sets the Gregorian Day of month.\r\n   *\r\n   * @param dayOfMonth\r\n   *            the Gregorian Day of month.\r\n   * @throws IllegalArgumentException\r\n   *             if the day of month of &lt; 1 is passed in\r\n   */\n\n\n  setGregorianDayOfMonth(dayOfMonth) {\n    JewishDate.validateGregorianDayOfMonth(dayOfMonth);\n    this.setInternalGregorianDate(this.gregorianYear, this.gregorianMonth, dayOfMonth);\n  }\n  /**\r\n   * sets the Jewish month.\r\n   *\r\n   * @param month\r\n   *            the Jewish month from 1 to 12 (or 13 years in a leap year). The month count starts with 1 for Nisan\r\n   *            and goes to 13 for Adar II\r\n   * @throws IllegalArgumentException\r\n   *             if a month &lt; 1 or &gt; 12 (or 13 on a leap year) is passed in\r\n   */\n\n\n  setJewishMonth(month) {\n    this.setJewishDate(this.jewishYear, month, this.jewishDay);\n  }\n  /**\r\n   * sets the Jewish year.\r\n   *\r\n   * @param year\r\n   *            the Jewish year\r\n   * @throws IllegalArgumentException\r\n   *             if a year of &lt; 3761 is passed in. The same will happen if the year is 3761 and the month and day\r\n   *             previously set are &lt; 18 Teves (preior to Jan 1, 1 AD)\r\n   */\n\n\n  setJewishYear(year) {\n    this.setJewishDate(year, this.jewishMonth, this.jewishDay);\n  }\n  /**\r\n   * sets the Jewish day of month.\r\n   *\r\n   * @param dayOfMonth\r\n   *            the Jewish day of month\r\n   * @throws IllegalArgumentException\r\n   *             if the day of month is &lt; 1 or &gt; 30 is passed in\r\n   */\n\n\n  setJewishDayOfMonth(dayOfMonth) {\n    this.setJewishDate(this.jewishYear, this.jewishMonth, dayOfMonth);\n  }\n  /**\r\n   * A method that creates a <a href=\"http://en.wikipedia.org/wiki/Object_copy#Deep_copy\">deep copy</a> of the object.\r\n   *\r\n   * @see Object#clone()\r\n   */\n\n\n  clone() {\n    const clone = new JewishDate(this.jewishYear, this.jewishMonth, this.jewishDay);\n    clone.setMoladHours(this.moladHours);\n    clone.setMoladMinutes(this.moladMinutes);\n    clone.setMoladChalakim(this.moladChalakim);\n    return clone;\n  }\n\n}\n/**\r\n * Value of the month field indicating Nissan, the first numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 7th (or 8th in a {@link #isJewishLeapYear() leap\r\n   * year}) month of the year.\r\n */\n\nJewishDate.NISSAN = 1;\n/**\r\n * Value of the month field indicating Iyar, the second numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 8th (or 9th in a {@link #isJewishLeapYear() leap\r\n   * year}) month of the year.\r\n */\n\nJewishDate.IYAR = 2;\n/**\r\n * Value of the month field indicating Sivan, the third numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 9th (or 10th in a {@link #isJewishLeapYear() leap\r\n   * year}) month of the year.\r\n */\n\nJewishDate.SIVAN = 3;\n/**\r\n * Value of the month field indicating Tammuz, the fourth numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 10th (or 11th in a {@link #isJewishLeapYear() leap\r\n   * year}) month of the year.\r\n */\n\nJewishDate.TAMMUZ = 4;\n/**\r\n * Value of the month field indicating Av, the fifth numeric month of the year in the Jewish calendar. With the year\r\n * starting at {@link #TISHREI}, it would actually be the 11th (or 12th in a {@link #isJewishLeapYear() leap year})\r\n * month of the year.\r\n */\n\nJewishDate.AV = 5;\n/**\r\n * Value of the month field indicating Elul, the sixth numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 12th (or 13th in a {@link #isJewishLeapYear() leap\r\n   * year}) month of the year.\r\n */\n\nJewishDate.ELUL = 6;\n/**\r\n * Value of the month field indicating Tishrei, the seventh numeric month of the year in the Jewish calendar. With\r\n * the year starting at this month, it would actually be the 1st month of the year.\r\n */\n\nJewishDate.TISHREI = 7;\n/**\r\n * Value of the month field indicating Cheshvan/marcheshvan, the eighth numeric month of the year in the Jewish\r\n * calendar. With the year starting at {@link #TISHREI}, it would actually be the 2nd month of the year.\r\n */\n\nJewishDate.CHESHVAN = 8;\n/**\r\n * Value of the month field indicating Kislev, the ninth numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 3rd month of the year.\r\n */\n\nJewishDate.KISLEV = 9;\n/**\r\n * Value of the month field indicating Teves, the tenth numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 4th month of the year.\r\n */\n\nJewishDate.TEVES = 10;\n/**\r\n * Value of the month field indicating Shevat, the eleventh numeric month of the year in the Jewish calendar. With\r\n * the year starting at {@link #TISHREI}, it would actually be the 5th month of the year.\r\n */\n\nJewishDate.SHEVAT = 11;\n/**\r\n * Value of the month field indicating Adar (or Adar I in a {@link #isJewishLeapYear() leap year}), the twelfth\r\n * numeric month of the year in the Jewish calendar. With the year starting at {@link #TISHREI}, it would actually\r\n * be the 6th month of the year.\r\n */\n\nJewishDate.ADAR = 12;\n/**\r\n * Value of the month field indicating Adar II, the leap (intercalary or embolismic) thirteenth (Undecimber) numeric\r\n * month of the year added in Jewish {@link #isJewishLeapYear() leap year}). The leap years are years 3, 6, 8, 11,\r\n * 14, 17 and 19 of a 19 year cycle. With the year starting at {@link #TISHREI}, it would actually be the 7th month\r\n * of the year.\r\n */\n\nJewishDate.ADAR_II = 13;\n/**\r\n * the Jewish epoch using the RD (Rata Die/Fixed Date or Reingold Dershowitz) day used in Calendrical Calculations.\r\n * Day 1 is January 1, 0001 Gregorian\r\n */\n\nJewishDate.JEWISH_EPOCH = -1373429;\nJewishDate.CHALAKIM_PER_MINUTE = 18;\nJewishDate.CHALAKIM_PER_HOUR = 1080;\nJewishDate.CHALAKIM_PER_DAY = 25920; // 24 * 1080\n\nJewishDate.CHALAKIM_PER_MONTH = 765433; // (29 * 24 + 12) * 1080 + 793\n\n/**\r\n * Days from the beginning of Sunday till molad BaHaRaD. Calculated as 1 day, 5 hours and 204 chalakim = (24 + 5) *\r\n * 1080 + 204 = 31524\r\n */\n\nJewishDate.CHALAKIM_MOLAD_TOHU = 31524;\n/**\r\n * A short year where both {@link #CHESHVAN} and {@link #KISLEV} are 29 days.\r\n *\r\n * @see #getCheshvanKislevKviah()\r\n * @see HebrewDateFormatter#getFormattedKviah(int)\r\n */\n\nJewishDate.CHASERIM = 0;\n/**\r\n * An ordered year where {@link #CHESHVAN} is 29 days and {@link #KISLEV} is 30 days.\r\n *\r\n * @see #getCheshvanKislevKviah()\r\n * @see HebrewDateFormatter#getFormattedKviah(int)\r\n */\n\nJewishDate.KESIDRAN = 1;\n/**\r\n * A long year where both {@link #CHESHVAN} and {@link #KISLEV} are 30 days.\r\n *\r\n * @see #getCheshvanKislevKviah()\r\n * @see HebrewDateFormatter#getFormattedKviah(int)\r\n */\n\nJewishDate.SHELAIMIM = 2;","map":{"version":3,"sources":["../../../src/hebrewcalendar/JewishDate.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { DateTime } from 'luxon';\r\nimport { Calendar, IntegerUtils } from '../polyfills/Utils';\r\nimport { IllegalArgumentException } from '../polyfills/errors';\r\n/**\r\n * The JewishDate is the base calendar class, that supports maintenance of a {@link java.util.GregorianCalendar}\r\n * instance along with the corresponding Jewish date. This class can use the standard Java Date and Calendar\r\n * classes for setting and maintaining the dates, but it does not subclass these classes or use them internally\r\n * in any calculations. This class also does not have a concept of a time (which the Date class does). Please\r\n * note that the calendar does not currently support dates prior to 1/1/1 Gregorian. Also keep in mind that the\r\n * Gregorian calendar started on October 15, 1582, so any calculations prior to that are suspect (at least from\r\n * a Gregorian perspective). While 1/1/1 Gregorian and forward are technically supported, any calculations prior to <a\r\n * href=\"http://en.wikipedia.org/wiki/Hillel_II\">Hillel II's (Hakatan's</a>) calendar (4119 in the Jewish Calendar / 359\r\n * CE Julian as recorded by <a href=\"http://en.wikipedia.org/wiki/Hai_Gaon\">Rav Hai Gaon</a>) would be just an\r\n * approximation.\r\n *\r\n * This open source Java code was written by <a href=\"http://www.facebook.com/avromf\">Avrom Finkelstien</a> from his C++\r\n * code. It was refactored to fit the KosherJava Zmanim API with simplification of the code, enhancements and some bug\r\n * fixing.\r\n *\r\n * Some of Avrom's original C++ code was translated from <a href=\"https://web.archive.org/web/20120124134148/http://emr.cs.uiuc.edu/~reingold/calendar.C\">C/C++\r\n * code</a> in <a href=\"http://www.calendarists.com\">Calendrical Calculations</a> by Nachum Dershowitz and Edward M.\r\n * Reingold, Software-- Practice &amp; Experience, vol. 20, no. 9 (September, 1990), pp. 899- 928. Any method with the mark\r\n * \"ND+ER\" indicates that the method was taken from this source with minor modifications.\r\n *\r\n * If you are looking for a class that implements a Jewish calendar version of the Calendar class, one is available from\r\n * the <a href=\"http://site.icu-project.org/\" >ICU (International Components for Unicode)</a> project, formerly part of\r\n * IBM's DeveloperWorks.\r\n *\r\n * @see net.sourceforge.zmanim.hebrewcalendar.JewishCalendar\r\n * @see net.sourceforge.zmanim.hebrewcalendar.HebrewDateFormatter\r\n * @see java.util.Date\r\n * @see java.util.Calendar\r\n * @author &copy; Avrom Finkelstien 2002\r\n * @author &copy; Eliyahu Hershfeld 2011 - 2015\r\n */\r\nexport class JewishDate {\r\n    constructor(jewishYearOrDateTimeOrDateOrMolad, jewishMonth, jewishDayOfMonth) {\r\n        if (!jewishYearOrDateTimeOrDateOrMolad) {\r\n            this.resetDate();\r\n        }\r\n        else if (jewishMonth) {\r\n            this.setJewishDate(jewishYearOrDateTimeOrDateOrMolad, jewishMonth, jewishDayOfMonth);\r\n        }\r\n        else if (jewishYearOrDateTimeOrDateOrMolad instanceof Date) {\r\n            this.setDate(DateTime.fromJSDate(jewishYearOrDateTimeOrDateOrMolad));\r\n        }\r\n        else if (DateTime.isDateTime(jewishYearOrDateTimeOrDateOrMolad)) {\r\n            this.setDate(jewishYearOrDateTimeOrDateOrMolad);\r\n        }\r\n        else if (typeof jewishYearOrDateTimeOrDateOrMolad === 'number') {\r\n            const molad = jewishYearOrDateTimeOrDateOrMolad;\r\n            this.absDateToDate(JewishDate.moladToAbsDate(molad));\r\n            // long chalakimSince = getChalakimSinceMoladTohu(year, JewishDate.TISHREI);// tishrei\r\n            const conjunctionDay = Math.trunc(molad / JewishDate.CHALAKIM_PER_DAY);\r\n            const conjunctionParts = Math.trunc(molad - conjunctionDay * JewishDate.CHALAKIM_PER_DAY);\r\n            this.setMoladTime(conjunctionParts);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the molad hours. Only a JewishDate object populated with {@link #getMolad()},\r\n     * {@link #setJewishDate(int, int, int, int, int, int)} or {@link #setMoladHours(int)} will have this field\r\n     * populated. A regular JewishDate object will have this field set to 0.\r\n     *\r\n     * @return the molad hours\r\n     * @see #setMoladHours(int)\r\n     * @see #getMolad()\r\n     * @see #setJewishDate(int, int, int, int, int, int)\r\n     */\r\n    getMoladHours() {\r\n        return this.moladHours;\r\n    }\r\n    /**\r\n     * Sets the molad hours.\r\n     *\r\n     * @param moladHours\r\n     *            the molad hours to set\r\n     * @see #getMoladHours()\r\n     * @see #getMolad()\r\n     * @see #setJewishDate(int, int, int, int, int, int)\r\n     *\r\n     */\r\n    setMoladHours(moladHours) {\r\n        this.moladHours = moladHours;\r\n    }\r\n    /**\r\n     * Returns the molad minutes. Only an object populated with {@link #getMolad()},\r\n     * {@link #setJewishDate(int, int, int, int, int, int)} or or {@link #setMoladMinutes(int)} will have these fields\r\n     * populated. A regular JewishDate object will have this field set to 0.\r\n     *\r\n     * @return the molad minutes\r\n     * @see #setMoladMinutes(int)\r\n     * @see #getMolad()\r\n     * @see #setJewishDate(int, int, int, int, int, int)\r\n     */\r\n    getMoladMinutes() {\r\n        return this.moladMinutes;\r\n    }\r\n    /**\r\n     * Sets the molad minutes. The expectation is that the traditional minute-less chalakim will be broken out to\r\n     * minutes and {@link #setMoladChalakim(int) chalakim/parts} , so 793 (TaShTZaG) parts would have the minutes set to\r\n     * 44 and chalakim to 1.\r\n     *\r\n     * @param moladMinutes\r\n     *            the molad minutes to set\r\n     * @see #getMoladMinutes()\r\n     * @see #setMoladChalakim(int)\r\n     * @see #getMolad()\r\n     * @see #setJewishDate(int, int, int, int, int, int)\r\n     *\r\n     */\r\n    setMoladMinutes(moladMinutes) {\r\n        this.moladMinutes = moladMinutes;\r\n    }\r\n    /**\r\n     * Sets the molad chalakim/parts. The expectation is that the traditional minute-less chalakim will be broken out to\r\n     * {@link #setMoladMinutes(int) minutes} and chalakim, so 793 (TaShTZaG) parts would have the minutes set to 44 and\r\n     * chalakim to 1.\r\n     *\r\n     * @param moladChalakim\r\n     *            the molad chalakim/parts to set\r\n     * @see #getMoladChalakim()\r\n     * @see #setMoladMinutes(int)\r\n     * @see #getMolad()\r\n     * @see #setJewishDate(int, int, int, int, int, int)\r\n     *\r\n     */\r\n    setMoladChalakim(moladChalakim) {\r\n        this.moladChalakim = moladChalakim;\r\n    }\r\n    /**\r\n     * Returns the molad chalakim/parts. Only an object populated with {@link #getMolad()},\r\n     * {@link #setJewishDate(int, int, int, int, int, int)} or or {@link #setMoladChalakim(int)} will have these fields\r\n     * populated. A regular JewishDate object will have this field set to 0.\r\n     *\r\n     * @return the molad chalakim/parts\r\n     * @see #setMoladChalakim(int)\r\n     * @see #getMolad()\r\n     * @see #setJewishDate(int, int, int, int, int, int)\r\n     */\r\n    getMoladChalakim() {\r\n        return this.moladChalakim;\r\n    }\r\n    /**\r\n     * Returns the last day in a gregorian month\r\n     *\r\n     * @param month\r\n     *            the Gregorian month\r\n     * @return the last day of the Gregorian month\r\n     */\r\n    getLastDayOfGregorianMonth(month) {\r\n        return JewishDate.getLastDayOfGregorianMonth(month, this.gregorianYear);\r\n    }\r\n    /**\r\n     * Returns the number of days in a given month in a given month and year.\r\n     *\r\n     * @param month\r\n     *            the month. As with other cases in this class, this is 1-based, not zero-based.\r\n     * @param year\r\n     *            the year (only impacts February)\r\n     * @return the number of days in the month in the given year\r\n     */\r\n    static getLastDayOfGregorianMonth(month, year) {\r\n        switch (month) {\r\n            case 2:\r\n                if ((year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0)) {\r\n                    return 29;\r\n                }\r\n                return 28;\r\n            case 4:\r\n            case 6:\r\n            case 9:\r\n            case 11:\r\n                return 30;\r\n            default:\r\n                return 31;\r\n        }\r\n    }\r\n    /**\r\n     * Computes the Gregorian date from the absolute date. ND+ER\r\n     * @param absDate - the absolute date\r\n     */\r\n    absDateToDate(absDate) {\r\n        let year = Math.trunc(absDate / 366); // Search forward year by year from approximate year\r\n        while (absDate >= JewishDate.gregorianDateToAbsDate(year + 1, 1, 1)) {\r\n            year++;\r\n        }\r\n        let month = 1; // Search forward month by month from January\r\n        while (absDate > JewishDate.gregorianDateToAbsDate(year, month, JewishDate.getLastDayOfGregorianMonth(month, year))) {\r\n            month++;\r\n        }\r\n        const dayOfMonth = absDate - JewishDate.gregorianDateToAbsDate(year, month, 1) + 1;\r\n        this.setInternalGregorianDate(year, month, dayOfMonth);\r\n    }\r\n    /**\r\n     * Returns the absolute date (days since January 1, 0001 on the Gregorian calendar).\r\n     *\r\n     * @return the number of days since January 1, 1\r\n     */\r\n    getAbsDate() {\r\n        return this.gregorianAbsDate;\r\n    }\r\n    /**\r\n     * Computes the absolute date from a Gregorian date. ND+ER\r\n     *\r\n     * @param year\r\n     *            the Gregorian year\r\n     * @param month\r\n     *            the Gregorian month. Unlike the Java Calendar where January has the value of 0,This expects a 1 for\r\n     *            January\r\n     * @param dayOfMonth\r\n     *            the day of the month (1st, 2nd, etc...)\r\n     * @return the absolute Gregorian day\r\n     */\r\n    static gregorianDateToAbsDate(year, month, dayOfMonth) {\r\n        let absDate = dayOfMonth;\r\n        for (let m = month - 1; m > 0; m--) {\r\n            absDate += JewishDate.getLastDayOfGregorianMonth(m, year); // days in prior months of the year\r\n        }\r\n        return (absDate // days this year\r\n            + 365 * (year - 1) // days in previous years ignoring leap days\r\n            + Math.trunc((year - 1) / 4) // Julian leap days before this year\r\n            - Math.trunc((year - 1) / 100) // minus prior century years\r\n            + Math.trunc((year - 1) / 400)); // plus prior years divisible by 400\r\n    }\r\n    /**\r\n     * Returns if the year is a Jewish leap year. Years 3, 6, 8, 11, 14, 17 and 19 in the 19 year cycle are leap years.\r\n     *\r\n     * @param year\r\n     *            the Jewish year.\r\n     * @return true if it is a leap year\r\n     * @see #isJewishLeapYear()\r\n     */\r\n    static isJewishLeapYear(year) {\r\n        return ((7 * year) + 1) % 19 < 7;\r\n    }\r\n    /**\r\n     * Returns if the year the calendar is set to is a Jewish leap year. Years 3, 6, 8, 11, 14, 17 and 19 in the 19 year\r\n     * cycle are leap years.\r\n     *\r\n     * @return true if it is a leap year\r\n     * @see #isJewishLeapYear(int)\r\n     */\r\n    isJewishLeapYear() {\r\n        return JewishDate.isJewishLeapYear(this.getJewishYear());\r\n    }\r\n    /**\r\n     * Returns the last month of a given Jewish year. This will be 12 on a non {@link #isJewishLeapYear(int) leap year}\r\n     * or 13 on a leap year.\r\n     *\r\n     * @param year\r\n     *            the Jewish year.\r\n     * @return 12 on a non leap year or 13 on a leap year\r\n     * @see #isJewishLeapYear(int)\r\n     */\r\n    static getLastMonthOfJewishYear(year) {\r\n        return JewishDate.isJewishLeapYear(year) ? JewishDate.ADAR_II : JewishDate.ADAR;\r\n    }\r\n    /**\r\n     * Returns the number of days elapsed from the Sunday prior to the start of the Jewish calendar to the mean\r\n     * conjunction of Tishri of the Jewish year.\r\n     *\r\n     * @param year\r\n     *            the Jewish year\r\n     * @return the number of days elapsed from prior to the molad Tohu BaHaRaD (Be = Monday, Ha= 5 hours and Rad =204\r\n     *         chalakim/parts) prior to the start of the Jewish calendar, to the mean conjunction of Tishri of the\r\n     *         Jewish year. BeHaRaD is 23:11:20 on Sunday night(5 hours 204/1080 chalakim after sunset on Sunday\r\n     *         evening).\r\n     */\r\n    static getJewishCalendarElapsedDays(year) {\r\n        const chalakimSince = JewishDate.getChalakimSinceMoladTohu(year, JewishDate.TISHREI);\r\n        const moladDay = Math.trunc(chalakimSince / JewishDate.CHALAKIM_PER_DAY);\r\n        const moladParts = Math.trunc(chalakimSince - moladDay * JewishDate.CHALAKIM_PER_DAY);\r\n        // delay Rosh Hashana for the 4 dechiyos\r\n        return JewishDate.addDechiyos(year, moladDay, moladParts);\r\n    }\r\n    // private static int getJewishCalendarElapsedDaysOLD(int year) {\r\n    // // Jewish lunar month = 29 days, 12 hours and 793 chalakim\r\n    // // Molad Tohu = BeHaRaD - Monday, 5 hours (11 PM) and 204 chalakim\r\n    // final int chalakimTashTZag = 793; // chalakim in a lunar month\r\n    // final int chalakimTohuRaD = 204; // chalakim from original molad Tohu BeHaRaD\r\n    // final int hoursTohuHa = 5; // hours from original molad Tohu BeHaRaD\r\n    // final int dayTohu = 1; // Monday (0 based)\r\n    //\r\n    // int monthsElapsed = (235 * ((year - 1) / 19)) // Months in complete 19 year lunar (Metonic) cycles so far\r\n    // + (12 * ((year - 1) % 19)) // Regular months in this cycle\r\n    // + ((7 * ((year - 1) % 19) + 1) / 19); // Leap months this cycle\r\n    // // start with Molad Tohu BeHaRaD\r\n    // // start with RaD of BeHaRaD and add TaShTzaG (793) chalakim plus elapsed chalakim\r\n    // int partsElapsed = chalakimTohuRaD + chalakimTashTZag * (monthsElapsed % 1080);\r\n    // // start with Ha hours of BeHaRaD, add 12 hour remainder of lunar month add hours elapsed\r\n    // int hoursElapsed = hoursTohuHa + 12 * monthsElapsed + 793 * (monthsElapsed / 1080) + partsElapsed / 1080;\r\n    // // start with Monday of BeHaRaD = 1 (0 based), add 29 days of the lunar months elapsed\r\n    // int conjunctionDay = dayTohu + 29 * monthsElapsed + hoursElapsed / 24;\r\n    // int conjunctionParts = 1080 * (hoursElapsed % 24) + partsElapsed % 1080;\r\n    // return addDechiyos(year, conjunctionDay, conjunctionParts);\r\n    // }\r\n    /**\r\n     * Adds the 4 dechiyos for molad Tishrei. These are:\r\n     * <ol>\r\n     * <li>Lo ADU Rosh - Rosh Hashana can't fall on a Sunday, Wednesday or Friday. If the molad fell on one of these\r\n     * days, Rosh Hashana is delayed to the following day.</li>\r\n     * <li>Molad Zaken - If the molad of Tishrei falls after 12 noon, Rosh Hashana is delayed to the following day. If\r\n     * the following day is ADU, it will be delayed an additional day.</li>\r\n     * <li>GaTRaD - If on a non leap year the molad of Tishrei falls on a Tuesday (Ga) on or after 9 hours (T) and 204\r\n     * chalakim (TRaD) it is delayed till Thursday (one day delay, plus one day for Lo ADU Rosh)</li>\r\n     * <li>BeTuTaKFoT - if the year following a leap year falls on a Monday (Be) on or after 15 hours (Tu) and 589\r\n     * chalakim (TaKFoT) it is delayed till Tuesday</li>\r\n     * </ol>\r\n     *\r\n     * @param year - the year\r\n     * @param moladDay - the molad day\r\n     * @param moladParts - the molad parts\r\n     * @return the number of elapsed days in the JewishCalendar adjusted for the 4 dechiyos.\r\n     */\r\n    static addDechiyos(year, moladDay, moladParts) {\r\n        let roshHashanaDay = moladDay; // if no dechiyos\r\n        // delay Rosh Hashana for the dechiyos of the Molad - new moon 1 - Molad Zaken, 2- GaTRaD 3- BeTuTaKFoT\r\n        if ((moladParts >= 19440) // Dechiya of Molad Zaken - molad is >= midday (18 hours * 1080 chalakim)\r\n            || (((moladDay % 7) === 2) // start Dechiya of GaTRaD - Ga = is a Tuesday\r\n                && (moladParts >= 9924) // TRaD = 9 hours, 204 parts or later (9 * 1080 + 204)\r\n                && !JewishDate.isJewishLeapYear(year)) // of a non-leap year - end Dechiya of GaTRaD\r\n            || (((moladDay % 7) === 1) // start Dechiya of BeTuTaKFoT - Be = is on a Monday\r\n                && (moladParts >= 16789) // TRaD = 15 hours, 589 parts or later (15 * 1080 + 589)\r\n                && (JewishDate.isJewishLeapYear(year - 1)))) { // in a year following a leap year - end Dechiya of BeTuTaKFoT\r\n            roshHashanaDay += 1; // Then postpone Rosh HaShanah one day\r\n        }\r\n        // start 4th Dechiya - Lo ADU Rosh - Rosh Hashana can't occur on A- sunday, D- Wednesday, U - Friday\r\n        if (((roshHashanaDay % 7) === 0) // If Rosh HaShanah would occur on Sunday,\r\n            || ((roshHashanaDay % 7) === 3) // or Wednesday,\r\n            || ((roshHashanaDay % 7) === 5)) { // or Friday - end 4th Dechiya - Lo ADU Rosh\r\n            roshHashanaDay++; // Then postpone it one (more) day\r\n        }\r\n        return roshHashanaDay;\r\n    }\r\n    /**\r\n     * Returns the number of chalakim (parts - 1080 to the hour) from the original hypothetical Molad Tohu to the year\r\n     * and month passed in.\r\n     *\r\n     * @param year\r\n     *            the Jewish year\r\n     * @param month\r\n     *            the Jewish month the Jewish month, with the month numbers starting from Nisan. Use the JewishDate\r\n     *            constants such as {@link JewishDate#TISHREI}.\r\n     * @return the number of chalakim (parts - 1080 to the hour) from the original hypothetical Molad Tohu\r\n     */\r\n    static getChalakimSinceMoladTohu(year, month) {\r\n        // Jewish lunar month = 29 days, 12 hours and 793 chalakim\r\n        // chalakim since Molad Tohu BeHaRaD - 1 day, 5 hours and 204 chalakim\r\n        const monthOfYear = JewishDate.getJewishMonthOfYear(year, month);\r\n        const monthsElapsed = (235 * Math.trunc((year - 1) / 19)) // Months in complete 19 year lunar (Metonic) cycles so far\r\n            + (12 * ((year - 1) % 19)) // Regular months in this cycle\r\n            + Math.trunc((7 * ((year - 1) % 19) + 1) / 19) // Leap months this cycle\r\n            + (monthOfYear - 1); // add elapsed months till the start of the molad of the month\r\n        // return chalakim prior to BeHaRaD + number of chalakim since\r\n        return JewishDate.CHALAKIM_MOLAD_TOHU + (JewishDate.CHALAKIM_PER_MONTH * monthsElapsed);\r\n    }\r\n    /**\r\n     * Returns the number of chalakim (parts - 1080 to the hour) from the original hypothetical Molad Tohu to the Jewish\r\n     * year and month that this Object is set to.\r\n     *\r\n     * @return the number of chalakim (parts - 1080 to the hour) from the original hypothetical Molad Tohu\r\n     */\r\n    getChalakimSinceMoladTohu() {\r\n        return JewishDate.getChalakimSinceMoladTohu(this.jewishYear, this.jewishMonth);\r\n    }\r\n    /**\r\n     * Converts the {@link JewishDate#NISSAN} based constants used by this class to numeric month starting from\r\n     * {@link JewishDate#TISHREI}. This is required for Molad claculations.\r\n     *\r\n     * @param year\r\n     *            The Jewish year\r\n     * @param month\r\n     *            The Jewish Month\r\n     * @return the Jewish month of the year starting with Tishrei\r\n     */\r\n    static getJewishMonthOfYear(year, month) {\r\n        const isLeapYear = JewishDate.isJewishLeapYear(year);\r\n        return ((month + (isLeapYear ? 6 : 5)) % (isLeapYear ? 13 : 12)) + 1;\r\n    }\r\n    /**\r\n     * Validates the components of a Jewish date for validity. It will throw an {@link IllegalArgumentException} if the\r\n     * Jewish date is earlier than 18 Teves, 3761 (1/1/1 Gregorian), a month < 1 or > 12 (or 13 on a\r\n     * {@link #isJewishLeapYear(int) leap year}), the day of month is < 1 or > 30, an hour < 0 or > 23, a minute < 0 >\r\n     * 59 or chalakim < 0 > 17. For larger a larger number of chalakim such as 793 (TaShTzaG) break the chalakim into\r\n     * minutes (18 chalakim per minutes, so it would be 44 minutes and 1 chelek in the case of 793/TaShTzaG).\r\n     *\r\n     * @param year\r\n     *            the Jewish year to validate. It will reject any year <= 3761 (lower than the year 1 Gregorian).\r\n     * @param month\r\n     *            the Jewish month to validate. It will reject a month < 1 or > 12 (or 13 on a leap year) .\r\n     * @param dayOfMonth\r\n     *            the day of the Jewish month to validate. It will reject any value < 1 or > 30 TODO: check calling\r\n     *            methods to see if there is any reason that the class can validate that 30 is invalid for some months.\r\n     * @param hours\r\n     *            the hours (for molad calculations). It will reject an hour < 0 or > 23\r\n     * @param minutes\r\n     *            the minutes (for molad calculations). It will reject a minute < 0 or > 59\r\n     * @param chalakim\r\n     *            the chalakim/parts (for molad calculations). It will reject a chalakim < 0 or > 17. For larger numbers\r\n     *            such as 793 (TaShTzaG) break the chalakim into minutes (18 chalakim per minutes, so it would be 44\r\n     *            minutes and 1 chelek in the case of 793/TaShTzaG)\r\n     *\r\n     * @throws IllegalArgumentException\r\n     *             if a A Jewish date earlier than 18 Teves, 3761 (1/1/1 Gregorian), a month < 1 or > 12 (or 13 on a\r\n     *             leap year), the day of month is < 1 or > 30, an hour < 0 or > 23, a minute < 0 > 59 or chalakim < 0 >\r\n     *             17. For larger a larger number of chalakim such as 793 (TaShTzaG) break the chalakim into minutes (18\r\n     *             chalakim per minutes, so it would be 44 minutes and 1 chelek in the case of 793 (TaShTzaG).\r\n     */\r\n    static validateJewishDate(year, month, dayOfMonth, hours, minutes, chalakim) {\r\n        if (month < JewishDate.NISSAN || month > JewishDate.getLastMonthOfJewishYear(year)) {\r\n            throw new IllegalArgumentException(`The Jewish month has to be between 1 and 12 (or 13 on a leap year). ${month} is invalid for the year ${year}.`);\r\n        }\r\n        if (dayOfMonth < 1 || dayOfMonth > 30) {\r\n            throw new IllegalArgumentException(`The Jewish day of month can't be < 1 or > 30. ${dayOfMonth} is invalid.`);\r\n        }\r\n        // reject dates prior to 18 Teves, 3761 (1/1/1 AD). This restriction can be relaxed if the date coding is\r\n        // changed/corrected\r\n        if ((year < 3761) || (year === 3761 && (month >= JewishDate.TISHREI && month < JewishDate.TEVES))\r\n            || (year === 3761 && month === JewishDate.TEVES && dayOfMonth < 18)) {\r\n            throw new IllegalArgumentException(`A Jewish date earlier than 18 Teves, 3761 (1/1/1 Gregorian) can't be set. ${year}, ${month}, ${dayOfMonth} is invalid.`);\r\n        }\r\n        if (hours < 0 || hours > 23) {\r\n            throw new IllegalArgumentException(`Hours < 0 or > 23 can't be set. ${hours} is invalid.`);\r\n        }\r\n        if (minutes < 0 || minutes > 59) {\r\n            throw new IllegalArgumentException(`Minutes < 0 or > 59 can't be set. ${minutes} is invalid.`);\r\n        }\r\n        if (chalakim < 0 || chalakim > 17) {\r\n            throw new IllegalArgumentException(`Chalakim/parts < 0 or > 17 can't be set. ${chalakim} is invalid. For larger numbers such as 793 (TaShTzaG) break the chalakim into minutes (18 chalakim per minutes, so it would be 44 minutes and 1 chelek in the case of 793 (TaShTzaG)`);\r\n        }\r\n    }\r\n    /**\r\n     * Validates the components of a Gregorian date for validity. It will throw an {@link IllegalArgumentException} if a\r\n     * year of < 1, a month < 0 or > 11 or a day of month < 1 is passed in.\r\n     *\r\n     * @param year\r\n     *            the Gregorian year to validate. It will reject any year < 1.\r\n     * @param month\r\n     *            the Gregorian month number to validate. It will enforce that the month is between 0 - 11 like a\r\n     *            {@link GregorianCalendar}, where {@link Calendar#JANUARY} has a value of 0.\r\n     * @param dayOfMonth\r\n     *            the day of the Gregorian month to validate. It will reject any value < 1, but will allow values > 31\r\n     *            since calling methods will simply set it to the maximum for that month. TODO: check calling methods to\r\n     *            see if there is any reason that the class needs days > the maximum.\r\n     * @throws IllegalArgumentException\r\n     *             if a year of < 1, a month < 0 or > 11 or a day of month < 1 is passed in\r\n     * @see #validateGregorianYear(int)\r\n     * @see #validateGregorianMonth(int)\r\n     * @see #validateGregorianDayOfMonth(int)\r\n     */\r\n    static validateGregorianDate(year, month, dayOfMonth) {\r\n        JewishDate.validateGregorianMonth(month);\r\n        JewishDate.validateGregorianDayOfMonth(dayOfMonth);\r\n        JewishDate.validateGregorianYear(year);\r\n    }\r\n    /**\r\n     * Validates a Gregorian month for validity.\r\n     *\r\n     * @param month\r\n     *            the Gregorian month number to validate. It will enforce that the month is between 0 - 11 like a\r\n     *            {@link GregorianCalendar}, where {@link Calendar#JANUARY} has a value of 0.\r\n     */\r\n    static validateGregorianMonth(month) {\r\n        if (month > 11 || month < 0) {\r\n            throw new IllegalArgumentException(`The Gregorian month has to be between 0 - 11. ${month} is invalid.`);\r\n        }\r\n    }\r\n    /**\r\n     * Validates a Gregorian day of month for validity.\r\n     *\r\n     * @param dayOfMonth\r\n     *            the day of the Gregorian month to validate. It will reject any value < 1, but will allow values > 31\r\n     *            since calling methods will simply set it to the maximum for that month. TODO: check calling methods to\r\n     *            see if there is any reason that the class needs days > the maximum.\r\n     */\r\n    static validateGregorianDayOfMonth(dayOfMonth) {\r\n        if (dayOfMonth <= 0) {\r\n            throw new IllegalArgumentException(`The day of month can't be less than 1. ${dayOfMonth} is invalid.`);\r\n        }\r\n    }\r\n    /**\r\n     * Validates a Gregorian year for validity.\r\n     *\r\n     * @param year\r\n     *            the Gregorian year to validate. It will reject any year < 1.\r\n     */\r\n    static validateGregorianYear(year) {\r\n        if (year < 1) {\r\n            throw new IllegalArgumentException(`Years < 1 can't be calculated. ${year} is invalid.`);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the number of days for a given Jewish year. ND+ER\r\n     *\r\n     * @param year\r\n     *            the Jewish year\r\n     * @return the number of days for a given Jewish year.\r\n     * @see #isCheshvanLong()\r\n     * @see #isKislevShort()\r\n     */\r\n    static getDaysInJewishYear(year) {\r\n        return JewishDate.getJewishCalendarElapsedDays(year + 1) - JewishDate.getJewishCalendarElapsedDays(year);\r\n    }\r\n    /**\r\n     * Returns the number of days for the current year that the calendar is set to.\r\n     *\r\n     * @return the number of days for the Object's current Jewish year.\r\n     * @see #isCheshvanLong()\r\n     * @see #isKislevShort()\r\n     * @see #isJewishLeapYear()\r\n     */\r\n    getDaysInJewishYear() {\r\n        return JewishDate.getDaysInJewishYear(this.getJewishYear());\r\n    }\r\n    /**\r\n     * Returns if Cheshvan is long in a given Jewish year. The method name isLong is done since in a Kesidran (ordered)\r\n     * year Cheshvan is short. ND+ER\r\n     *\r\n     * @param year\r\n     *            the year\r\n     * @return true if Cheshvan is long in Jewish year.\r\n     * @see #isCheshvanLong()\r\n     * @see #getCheshvanKislevKviah()\r\n     */\r\n    static isCheshvanLong(year) {\r\n        return JewishDate.getDaysInJewishYear(year) % 10 === 5;\r\n    }\r\n    /**\r\n     * Returns if Cheshvan is long (30 days VS 29 days) for the current year that the calendar is set to. The method\r\n     * name isLong is done since in a Kesidran (ordered) year Cheshvan is short.\r\n     *\r\n     * @return true if Cheshvan is long for the current year that the calendar is set to\r\n     * @see #isCheshvanLong()\r\n     */\r\n    isCheshvanLong() {\r\n        return JewishDate.isCheshvanLong(this.getJewishYear());\r\n    }\r\n    /**\r\n     * Returns if Kislev is short (29 days VS 30 days) in a given Jewish year. The method name isShort is done since in\r\n     * a Kesidran (ordered) year Kislev is long. ND+ER\r\n     *\r\n     * @param year\r\n     *            the Jewish year\r\n     * @return true if Kislev is short for the given Jewish year.\r\n     * @see #isKislevShort()\r\n     * @see #getCheshvanKislevKviah()\r\n     */\r\n    static isKislevShort(year) {\r\n        return JewishDate.getDaysInJewishYear(year) % 10 === 3;\r\n    }\r\n    /**\r\n     * Returns if the Kislev is short for the year that this class is set to. The method name isShort is done since in a\r\n     * Kesidran (ordered) year Kislev is long.\r\n     *\r\n     * @return true if Kislev is short for the year that this class is set to\r\n     */\r\n    isKislevShort() {\r\n        return JewishDate.isKislevShort(this.getJewishYear());\r\n    }\r\n    /**\r\n     * Returns the Cheshvan and Kislev kviah (whether a Jewish year is short, regular or long). It will return\r\n     * {@link #SHELAIMIM} if both cheshvan and kislev are 30 days, {@link #KESIDRAN} if Cheshvan is 29 days and Kislev\r\n     * is 30 days and {@link #CHASERIM} if both are 29 days.\r\n     *\r\n     * @return {@link #SHELAIMIM} if both cheshvan and kislev are 30 days, {@link #KESIDRAN} if Cheshvan is 29 days and\r\n     *         Kislev is 30 days and {@link #CHASERIM} if both are 29 days.\r\n     * @see #isCheshvanLong()\r\n     * @see #isKislevShort()\r\n     */\r\n    getCheshvanKislevKviah() {\r\n        if (this.isCheshvanLong() && !this.isKislevShort()) {\r\n            return JewishDate.SHELAIMIM;\r\n        }\r\n        else if (!this.isCheshvanLong() && this.isKislevShort()) {\r\n            return JewishDate.CHASERIM;\r\n        }\r\n        return JewishDate.KESIDRAN;\r\n    }\r\n    /**\r\n     * Returns the number of days of a Jewish month for a given month and year.\r\n     *\r\n     * @param month\r\n     *            the Jewish month\r\n     * @param year\r\n     *            the Jewish Year\r\n     * @return the number of days for a given Jewish month\r\n     */\r\n    static getDaysInJewishMonth(month, year) {\r\n        const shortMonths = [\r\n            JewishDate.IYAR,\r\n            JewishDate.TAMMUZ,\r\n            JewishDate.ELUL,\r\n            JewishDate.ADAR_II,\r\n        ];\r\n        if (shortMonths.includes(month)\r\n            || ((month === JewishDate.CHESHVAN) && !(JewishDate.isCheshvanLong(year)))\r\n            || ((month === JewishDate.KISLEV) && JewishDate.isKislevShort(year)) || (month === JewishDate.TEVES)\r\n            || ((month === JewishDate.ADAR) && !(JewishDate.isJewishLeapYear(year)))) {\r\n            return 29;\r\n        }\r\n        return 30;\r\n    }\r\n    /**\r\n     * Returns the number of days of the Jewish month that the calendar is currently set to.\r\n     *\r\n     * @return the number of days for the Jewish month that the calendar is currently set to.\r\n     */\r\n    getDaysInJewishMonth() {\r\n        return JewishDate.getDaysInJewishMonth(this.getJewishMonth(), this.getJewishYear());\r\n    }\r\n    /**\r\n     * Computes the Jewish date from the absolute date. ND+ER\r\n     */\r\n    absDateToJewishDate() {\r\n        // Approximation from below\r\n        this.jewishYear = Math.trunc((this.gregorianAbsDate - JewishDate.JEWISH_EPOCH) / 366);\r\n        // Search forward for year from the approximation\r\n        while (this.gregorianAbsDate >= JewishDate.jewishDateToAbsDate(this.jewishYear + 1, JewishDate.TISHREI, 1)) {\r\n            this.jewishYear++;\r\n        }\r\n        // Search forward for month from either Tishri or Nisan.\r\n        if (this.gregorianAbsDate < JewishDate.jewishDateToAbsDate(this.jewishYear, JewishDate.NISSAN, 1)) {\r\n            this.jewishMonth = JewishDate.TISHREI; // Start at Tishri\r\n        }\r\n        else {\r\n            this.jewishMonth = JewishDate.NISSAN; // Start at Nisan\r\n        }\r\n        while (this.gregorianAbsDate > JewishDate.jewishDateToAbsDate(this.jewishYear, this.jewishMonth, this.getDaysInJewishMonth())) {\r\n            this.jewishMonth++;\r\n        }\r\n        // Calculate the day by subtraction\r\n        this.jewishDay = this.gregorianAbsDate - JewishDate.jewishDateToAbsDate(this.jewishYear, this.jewishMonth, 1) + 1;\r\n    }\r\n    /**\r\n     * Returns the absolute date of Jewish date. ND+ER\r\n     *\r\n     * @param year\r\n     *            the Jewish year. The year can't be negative\r\n     * @param month\r\n     *            the Jewish month starting with Nisan. Nisan expects a value of 1 etc till Adar with a value of 12. For\r\n     *            a leap year, 13 will be the expected value for Adar II. Use the constants {@link JewishDate#NISSAN}\r\n     *            etc.\r\n     * @param dayOfMonth\r\n     *            the Jewish day of month. valid values are 1-30. If the day of month is set to 30 for a month that only\r\n     *            has 29 days, the day will be set as 29.\r\n     * @return the absolute date of the Jewish date.\r\n     */\r\n    static jewishDateToAbsDate(year, month, dayOfMonth) {\r\n        const elapsed = JewishDate.getDaysSinceStartOfJewishYear(year, month, dayOfMonth);\r\n        // add elapsed days this year + Days in prior years + Days elapsed before absolute year 1\r\n        return elapsed + JewishDate.getJewishCalendarElapsedDays(year) + JewishDate.JEWISH_EPOCH;\r\n    }\r\n    /**\r\n     * Returns the molad for a given year and month. Returns a JewishDate {@link Object} set to the date of the molad\r\n     * with the {@link #getMoladHours() hours}, {@link #getMoladMinutes() minutes} and {@link #getMoladChalakim()\r\n       * chalakim} set. In the current implementation, it sets the molad time based on a midnight date rollover. This\r\n     * means that Rosh Chodesh Adar II, 5771 with a molad of 7 chalakim past midnight on Shabbos 29 Adar I / March 5,\r\n     * 2011 12:00 AM and 7 chalakim, will have the following values: hours: 0, minutes: 0, Chalakim: 7.\r\n     *\r\n     * @return a JewishDate {@link Object} set to the date of the molad with the {@link #getMoladHours() hours},\r\n     *         {@link #getMoladMinutes() minutes} and {@link #getMoladChalakim() chalakim} set.\r\n     */\r\n    getMolad() {\r\n        const moladDate = new JewishDate(this.getChalakimSinceMoladTohu());\r\n        if (moladDate.getMoladHours() >= 6) {\r\n            moladDate.forward(Calendar.DATE, 1);\r\n        }\r\n        moladDate.setMoladHours((moladDate.getMoladHours() + 18) % 24);\r\n        return moladDate;\r\n    }\r\n    /**\r\n     * Returns the number of days from the Jewish epoch from the number of chalakim from the epoch passed in.\r\n     *\r\n     * @param chalakim\r\n     *            the number of chalakim since the beginning of Sunday prior to BaHaRaD\r\n     * @return the number of days from the Jewish epoch\r\n     */\r\n    static moladToAbsDate(chalakim) {\r\n        return Math.trunc(chalakim / JewishDate.CHALAKIM_PER_DAY) + JewishDate.JEWISH_EPOCH;\r\n    }\r\n    /**\r\n     * Constructor that creates a JewishDate based on a molad passed in. The molad would be the number of chalakim/parts\r\n     * starting at the beginning of Sunday prior to the molad Tohu BeHaRaD (Be = Monday, Ha= 5 hours and Rad =204\r\n     * chalakim/parts) - prior to the start of the Jewish calendar. BeHaRaD is 23:11:20 on Sunday night(5 hours 204/1080\r\n     * chalakim after sunset on Sunday evening).\r\n     *\r\n     * @param molad the number of chalakim since the beginning of Sunday prior to BaHaRaD\r\n     */\r\n    /*\r\n        public JewishDate(molad: number) {\r\n            this.absDateToDate(JewishDate.moladToAbsDate(molad));\r\n            // long chalakimSince = getChalakimSinceMoladTohu(year, JewishDate.TISHREI);// tishrei\r\n            const conjunctionDay: number = Math.trunc(molad / JewishDate.CHALAKIM_PER_DAY);\r\n            const conjunctionParts: number = Math.trunc(molad - conjunctionDay * JewishDate.CHALAKIM_PER_DAY);\r\n            this.setMoladTime(conjunctionParts);\r\n        }\r\n    */\r\n    /**\r\n     * Sets the molad time (hours minutes and chalakim) based on the number of chalakim since the start of the day.\r\n     *\r\n     * @param chalakim\r\n     *            the number of chalakim since the start of the day.\r\n     */\r\n    setMoladTime(chalakim) {\r\n        let adjustedChalakim = chalakim;\r\n        this.setMoladHours(Math.trunc(adjustedChalakim / JewishDate.CHALAKIM_PER_HOUR));\r\n        adjustedChalakim = adjustedChalakim - (this.getMoladHours() * JewishDate.CHALAKIM_PER_HOUR);\r\n        this.setMoladMinutes(Math.trunc(adjustedChalakim / JewishDate.CHALAKIM_PER_MINUTE));\r\n        this.setMoladChalakim(adjustedChalakim - this.moladMinutes * JewishDate.CHALAKIM_PER_MINUTE);\r\n    }\r\n    /**\r\n     * returns the number of days from Rosh Hashana of the date passed in, to the full date passed in.\r\n     *\r\n     * @return the number of days\r\n     */\r\n    getDaysSinceStartOfJewishYear() {\r\n        return JewishDate.getDaysSinceStartOfJewishYear(this.getJewishYear(), this.getJewishMonth(), this.getJewishDayOfMonth());\r\n    }\r\n    /**\r\n     * returns the number of days from Rosh Hashana of the date passed in, to the full date passed in.\r\n     *\r\n     * @param year\r\n     *            the Jewish year\r\n     * @param month\r\n     *            the Jewish month\r\n     * @param dayOfMonth\r\n     *            the day in the Jewish month\r\n     * @return the number of days\r\n     */\r\n    static getDaysSinceStartOfJewishYear(year, month, dayOfMonth) {\r\n        let elapsedDays = dayOfMonth;\r\n        // Before Tishrei (from Nissan to Tishrei), add days in prior months\r\n        if (month < JewishDate.TISHREI) {\r\n            // this year before and after Nisan.\r\n            for (let m = JewishDate.TISHREI; m <= JewishDate.getLastMonthOfJewishYear(year); m++) {\r\n                elapsedDays += JewishDate.getDaysInJewishMonth(m, year);\r\n            }\r\n            for (let m = JewishDate.NISSAN; m < month; m++) {\r\n                elapsedDays += JewishDate.getDaysInJewishMonth(m, year);\r\n            }\r\n        }\r\n        else { // Add days in prior months this year\r\n            for (let m = JewishDate.TISHREI; m < month; m++) {\r\n                elapsedDays += JewishDate.getDaysInJewishMonth(m, year);\r\n            }\r\n        }\r\n        return elapsedDays;\r\n    }\r\n    /**\r\n     * Creates a Jewish date based on a Jewish year, month and day of month.\r\n     *\r\n     * @param jewishYear\r\n     *            the Jewish year\r\n     * @param jewishMonth\r\n     *            the Jewish month. The method expects a 1 for Nissan ... 12 for Adar and 13 for Adar II. Use the\r\n     *            constants {@link #NISSAN} ... {@link #ADAR} (or {@link #ADAR_II} for a leap year Adar II) to avoid any\r\n     *            confusion.\r\n     * @param jewishDayOfMonth\r\n     *            the Jewish day of month. If 30 is passed in for a month with only 29 days (for example {@link #IYAR},\r\n     *            or {@link #KISLEV} in a year that {@link #isKislevShort()}), the 29th (last valid date of the month)\r\n     *            will be set\r\n     * @throws IllegalArgumentException\r\n     *             if the day of month is &lt; 1 or &gt; 30, or a year of &lt; 0 is passed in.\r\n     */\r\n    /*\r\n        public JewishDate(jewishYear: number, jewishMonth: number, jewishDayOfMonth: number) {\r\n            this.setJewishDate(jewishYear, jewishMonth, jewishDayOfMonth);\r\n        }\r\n    */\r\n    /**\r\n     * Default constructor will set a default date to the current system date.\r\n     */\r\n    /*\r\n        public JewishDate() {\r\n            this.resetDate();\r\n        }\r\n    */\r\n    /**\r\n     * A constructor that initializes the date to the {@link java.util.Date Date} paremeter.\r\n     *\r\n     * @param date\r\n     *            the <code>Date</code> to set the calendar to\r\n     * @throws IllegalArgumentException\r\n     *             if the date would fall prior to the January 1, 1 AD\r\n     */\r\n    /*\r\n        public JewishDate(date: Date) {\r\n            this.setDate(date);\r\n        }\r\n    */\r\n    /**\r\n     * A constructor that initializes the date to the {@link java.util.Calendar Calendar} paremeter.\r\n     *\r\n     * @param calendar\r\n     *            the <code>Calendar</code> to set the calendar to\r\n     * @throws IllegalArgumentException\r\n     *             if the {@link Calendar#ERA} is {@link GregorianCalendar#BC}\r\n     */\r\n    /*\r\n        public JewishDate(calendar: GregorianCalendar) {\r\n            this.setDate(calendar);\r\n        }\r\n    */\r\n    /**\r\n     * Sets the date based on a {@link java.util.Calendar Calendar} object. Modifies the Jewish date as well.\r\n     *\r\n     * @param date\r\n     *            the <code>Calendar</code> to set the calendar to\r\n     * @throws IllegalArgumentException\r\n     *             if the {@link Calendar#ERA} is {@link GregorianCalendar#BC}\r\n     */\r\n    setDate(date) {\r\n        if (date.year < 1) {\r\n            throw new IllegalArgumentException(`Dates with a BC era are not supported. The year ${date.year} is invalid.`);\r\n        }\r\n        this.gregorianMonth = date.month;\r\n        this.gregorianDayOfMonth = date.day;\r\n        this.gregorianYear = date.year;\r\n        this.gregorianAbsDate = JewishDate.gregorianDateToAbsDate(this.gregorianYear, this.gregorianMonth, this.gregorianDayOfMonth); // init the date\r\n        this.absDateToJewishDate();\r\n        this.dayOfWeek = Math.abs(this.gregorianAbsDate % 7) + 1; // set day of week\r\n    }\r\n    /**\r\n     * Sets the date based on a {@link java.util.Date Date} object. Modifies the Jewish date as well.\r\n     *\r\n     * @param date\r\n     *            the <code>Date</code> to set the calendar to\r\n     * @throws IllegalArgumentException\r\n     *             if the date would fall prior to the year 1 AD\r\n     */\r\n    /*\r\n        public setDate(date: Date): void {\r\n            const cal: GregorianCalendar = new GregorianCalendar();\r\n            cal.setTime(date);\r\n            this.setDate(cal);\r\n        }\r\n    */\r\n    /**\r\n     * Sets the Gregorian Date, and updates the Jewish date accordingly. Like the Java Calendar A value of 0 is expected\r\n     * for January.\r\n     *\r\n     * @param year\r\n     *            the Gregorian year\r\n     * @param month\r\n     *            the Gregorian month. Like the Java Calendar, this class expects 0 for January\r\n     * @param dayOfMonth\r\n     *            the Gregorian day of month. If this is &gt; the number of days in the month/year, the last valid date of\r\n     *            the month will be set\r\n     * @throws IllegalArgumentException\r\n     *             if a year of &lt; 1, a month &lt; 0 or &gt; 11 or a day of month &lt; 1 is passed in\r\n     */\r\n    setGregorianDate(year, month, dayOfMonth) {\r\n        JewishDate.validateGregorianDate(year, month, dayOfMonth);\r\n        this.setInternalGregorianDate(year, month + 1, dayOfMonth);\r\n    }\r\n    /**\r\n     * Sets the hidden internal representation of the Gregorian date , and updates the Jewish date accordingly. While\r\n     * public getters and setters have 0 based months matching the Java Calendar classes, This class internally\r\n     * represents the Gregorian month starting at 1. When this is called it will not adjust the month to match the Java\r\n     * Calendar classes.\r\n     *\r\n     * @param year - the year\r\n     * @param month - the month\r\n     * @param dayOfMonth - the day of month\r\n     */\r\n    setInternalGregorianDate(year, month, dayOfMonth) {\r\n        // make sure date is a valid date for the given month, if not, set to last day of month\r\n        if (dayOfMonth > JewishDate.getLastDayOfGregorianMonth(month, year)) {\r\n            dayOfMonth = JewishDate.getLastDayOfGregorianMonth(month, year);\r\n        }\r\n        // init month, date, year\r\n        this.gregorianMonth = month;\r\n        this.gregorianDayOfMonth = dayOfMonth;\r\n        this.gregorianYear = year;\r\n        this.gregorianAbsDate = JewishDate.gregorianDateToAbsDate(this.gregorianYear, this.gregorianMonth, this.gregorianDayOfMonth); // init date\r\n        this.absDateToJewishDate();\r\n        this.dayOfWeek = Math.abs(this.gregorianAbsDate % 7) + 1; // set day of week\r\n    }\r\n    setJewishDate(year, month, dayOfMonth, hours = 0, minutes = 0, chalakim = 0) {\r\n        JewishDate.validateJewishDate(year, month, dayOfMonth, hours, minutes, chalakim);\r\n        // if 30 is passed for a month that only has 29 days (for example by rolling the month from a month that had 30\r\n        // days to a month that only has 29) set the date to 29th\r\n        if (dayOfMonth > JewishDate.getDaysInJewishMonth(month, year)) {\r\n            dayOfMonth = JewishDate.getDaysInJewishMonth(month, year);\r\n        }\r\n        this.jewishMonth = month;\r\n        this.jewishDay = dayOfMonth;\r\n        this.jewishYear = year;\r\n        this.moladHours = hours;\r\n        this.moladMinutes = minutes;\r\n        this.moladChalakim = chalakim;\r\n        this.gregorianAbsDate = JewishDate.jewishDateToAbsDate(this.jewishYear, this.jewishMonth, this.jewishDay); // reset Gregorian date\r\n        this.absDateToDate(this.gregorianAbsDate);\r\n        this.dayOfWeek = Math.abs(this.gregorianAbsDate % 7) + 1; // reset day of week\r\n    }\r\n    /**\r\n     * Returns this object's date as a {@link java.util.Calendar} object.\r\n     *\r\n     * @return The {@link java.util.Calendar}\r\n     */\r\n    getDate() {\r\n        return DateTime.fromObject({\r\n            year: this.gregorianYear,\r\n            month: this.gregorianMonth,\r\n            day: this.gregorianDayOfMonth,\r\n        });\r\n    }\r\n    /**\r\n     * Resets this date to the current system date.\r\n     */\r\n    resetDate() {\r\n        this.setDate(DateTime.local());\r\n    }\r\n    /**\r\n     * Returns a string containing the Jewish date in the form, \"day Month, year\" e.g. \"21 Shevat, 5729\". For more\r\n     * complex formatting, use the formatter classes.\r\n     *\r\n     * This functionality is duplicated from {@link HebrewDateFormatter} to avoid circular dependencies.\r\n     *\r\n     * @return the Jewish date in the form \"day Month, year\" e.g. \"21 Shevat, 5729\"\r\n     * @see HebrewDateFormatter#format(JewishDate)\r\n     */\r\n    toString() {\r\n        const transliteratedMonths = ['Nissan', 'Iyar', 'Sivan', 'Tammuz', 'Av', 'Elul', 'Tishrei', 'Cheshvan',\r\n            'Kislev', 'Teves', 'Shevat', 'Adar', 'Adar II', 'Adar I'];\r\n        let formattedMonth;\r\n        if (this.isJewishLeapYear() && this.jewishMonth === JewishDate.ADAR) {\r\n            formattedMonth = transliteratedMonths[13]; // return Adar I, not Adar in a leap year\r\n        }\r\n        else {\r\n            formattedMonth = transliteratedMonths[this.jewishMonth - 1];\r\n        }\r\n        return `${this.getJewishDayOfMonth()} ${formattedMonth}, ${this.getJewishYear()}`;\r\n    }\r\n    /**\r\n     * Rolls the date, month or year forward by the amount passed in. It modifies both the Gregorian and Jewish dates\r\n     * accordingly. If manipulation beyond the fields supported here is required, use the {@link Calendar} class\r\n     * {@link Calendar#add(int, int)} or {@link Calendar#roll(int, int)} methods in the following manner.\r\n     *\r\n     * <pre>\r\n     * <code>\r\n     *     Calendar cal = jewishDate.getTime(); // get a java.util.Calendar representation of the JewishDate\r\n     *     cal.add(Calendar.MONTH, 3); // add 3 Gregorian months\r\n     *     jewishDate.setDate(cal); // set the updated calendar back to this class\r\n     * </code>\r\n     * </pre>\r\n     *\r\n     * @param field the calendar field to be forwarded. The must be {@link Calendar#DATE}, {@link Calendar#MONTH} or {@link Calendar#YEAR}\r\n     * @param amount the positive amount to move forward\r\n     * @throws IllegalArgumentException if the field is anything besides {@link Calendar#DATE}, {@link Calendar#MONTH}\r\n     * or {@link Calendar#YEAR} or if the amount is less than 1\r\n     *\r\n     * @see #back()\r\n     * @see Calendar#add(int, int)\r\n     * @see Calendar#roll(int, int)\r\n     */\r\n    forward(field, amount) {\r\n        if (field !== Calendar.DATE && field !== Calendar.MONTH && field !== Calendar.YEAR) {\r\n            throw new IllegalArgumentException('Unsupported field was passed to Forward. Only Calendar.DATE, Calendar.MONTH or Calendar.YEAR are supported.');\r\n        }\r\n        if (amount < 1) {\r\n            throw new IllegalArgumentException('JewishDate.forward() does not support amounts less than 1. See JewishDate.back()');\r\n        }\r\n        if (field === Calendar.DATE) {\r\n            // Change Gregorian date\r\n            for (let i = 0; i < amount; i++) {\r\n                if (this.gregorianDayOfMonth === JewishDate.getLastDayOfGregorianMonth(this.gregorianMonth, this.gregorianYear)) {\r\n                    this.gregorianDayOfMonth = 1;\r\n                    // if last day of year\r\n                    if (this.gregorianMonth === 12) {\r\n                        this.gregorianYear++;\r\n                    }\r\n                    else {\r\n                        this.gregorianMonth++;\r\n                    }\r\n                }\r\n                else {\r\n                    // if not last day of month\r\n                    this.gregorianDayOfMonth++;\r\n                }\r\n                // Change the Jewish Date\r\n                if (this.jewishDay === this.getDaysInJewishMonth()) {\r\n                    // if it last day of elul (i.e. last day of Jewish year)\r\n                    if (this.jewishMonth === JewishDate.ELUL) {\r\n                        this.jewishYear++;\r\n                        this.jewishMonth++;\r\n                        this.jewishDay = 1;\r\n                    }\r\n                    else if (this.jewishMonth === JewishDate.getLastMonthOfJewishYear(this.jewishYear)) {\r\n                        // if it is the last day of Adar, or Adar II as case may be\r\n                        this.jewishMonth = JewishDate.NISSAN;\r\n                        this.jewishDay = 1;\r\n                    }\r\n                    else {\r\n                        this.jewishMonth++;\r\n                        this.jewishDay = 1;\r\n                    }\r\n                }\r\n                else {\r\n                    // if not last date of month\r\n                    this.jewishDay++;\r\n                }\r\n                if (this.dayOfWeek === 7) {\r\n                    // if last day of week, loop back to Sunday\r\n                    this.dayOfWeek = 1;\r\n                }\r\n                else {\r\n                    this.dayOfWeek++;\r\n                }\r\n                // increment the absolute date\r\n                this.gregorianAbsDate++;\r\n            }\r\n        }\r\n        else if (field === Calendar.MONTH) {\r\n            this.forwardJewishMonth(amount);\r\n        }\r\n        else if (field === Calendar.YEAR) {\r\n            this.setJewishYear(this.getJewishYear() + amount);\r\n        }\r\n    }\r\n    /**\r\n     * Forward the Jewish date by the number of months passed in.\r\n     * FIXME: Deal with forwarding a date such as 30 Nisan by a month. 30 Iyar does not exist. This should be dealt with similar to\r\n     * the way that the Java Calendar behaves (not that simple since there is a difference between add() or roll().\r\n     *\r\n     * @throws IllegalArgumentException if the amount is less than 1\r\n     * @param amount the number of months to roll the month forward\r\n     */\r\n    forwardJewishMonth(amount) {\r\n        if (amount < 1) {\r\n            throw new IllegalArgumentException('the amount of months to forward has to be greater than zero.');\r\n        }\r\n        for (let i = 0; i < amount; i++) {\r\n            if (this.getJewishMonth() === JewishDate.ELUL) {\r\n                this.setJewishMonth(JewishDate.TISHREI);\r\n                this.setJewishYear(this.getJewishYear() + 1);\r\n            }\r\n            else if ((!this.isJewishLeapYear() && this.getJewishMonth() === JewishDate.ADAR)\r\n                || (this.isJewishLeapYear() && this.getJewishMonth() === JewishDate.ADAR_II)) {\r\n                this.setJewishMonth(JewishDate.NISSAN);\r\n            }\r\n            else {\r\n                this.setJewishMonth(this.getJewishMonth() + 1);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Rolls the date back by 1 day. It modifies both the Gregorian and Jewish dates accordingly. The API does not\r\n     * currently offer the ability to forward more than one day t a time, or to forward by month or year. If such\r\n     * manipulation is required use the {@link Calendar} class {@link Calendar#add(int, int)} or\r\n     * {@link Calendar#roll(int, int)} methods in the following manner.\r\n     *\r\n     * <pre>\r\n     * <code>\r\n     *     Calendar cal = jewishDate.getTime(); // get a java.util.Calendar representation of the JewishDate\r\n     *     cal.add(Calendar.MONTH, -3); // subtract 3 Gregorian months\r\n     *     jewishDate.setDate(cal); // set the updated calendar back to this class\r\n     * </code>\r\n     * </pre>\r\n     *\r\n     * @see #back()\r\n     * @see Calendar#add(int, int)\r\n     * @see Calendar#roll(int, int)\r\n     */\r\n    back() {\r\n        // Change Gregorian date\r\n        if (this.gregorianDayOfMonth === 1) { // if first day of month\r\n            if (this.gregorianMonth === 1) { // if first day of year\r\n                this.gregorianMonth = 12;\r\n                this.gregorianYear--;\r\n            }\r\n            else {\r\n                this.gregorianMonth--;\r\n            }\r\n            // change to last day of previous month\r\n            this.gregorianDayOfMonth = JewishDate.getLastDayOfGregorianMonth(this.gregorianMonth, this.gregorianYear);\r\n        }\r\n        else {\r\n            this.gregorianDayOfMonth--;\r\n        }\r\n        // change Jewish date\r\n        if (this.jewishDay === 1) { // if first day of the Jewish month\r\n            if (this.jewishMonth === JewishDate.NISSAN) {\r\n                this.jewishMonth = JewishDate.getLastMonthOfJewishYear(this.jewishYear);\r\n            }\r\n            else if (this.jewishMonth === JewishDate.TISHREI) { // if Rosh Hashana\r\n                this.jewishYear--;\r\n                this.jewishMonth--;\r\n            }\r\n            else {\r\n                this.jewishMonth--;\r\n            }\r\n            this.jewishDay = this.getDaysInJewishMonth();\r\n        }\r\n        else {\r\n            this.jewishDay--;\r\n        }\r\n        if (this.dayOfWeek === 1) { // if first day of week, loop back to Saturday\r\n            this.dayOfWeek = 7;\r\n        }\r\n        else {\r\n            this.dayOfWeek--;\r\n        }\r\n        this.gregorianAbsDate--; // change the absolute date\r\n    }\r\n    /**\r\n     * @see Object#equals(Object)\r\n     */\r\n    equals(object) {\r\n        if (this === object) {\r\n            return true;\r\n        }\r\n        if (!(object instanceof JewishDate)) {\r\n            return false;\r\n        }\r\n        const jewishDate = object;\r\n        return this.gregorianAbsDate === jewishDate.getAbsDate();\r\n    }\r\n    /**\r\n     * Compares two dates as per the compareTo() method in the Comparable interface. Returns a value less than 0 if this\r\n     * date is \"less than\" (before) the date, greater than 0 if this date is \"greater than\" (after) the date, or 0 if\r\n     * they are equal.\r\n     */\r\n    compareTo(jewishDate) {\r\n        return IntegerUtils.compare(this.gregorianAbsDate, jewishDate.getAbsDate());\r\n    }\r\n    /**\r\n     * Returns the Gregorian month (between 0-11).\r\n     *\r\n     * @return the Gregorian month (between 0-11). Like the java.util.Calendar, months are 0 based.\r\n     */\r\n    getGregorianMonth() {\r\n        return this.gregorianMonth - 1;\r\n    }\r\n    /**\r\n     * Returns the Gregorian day of the month.\r\n     *\r\n     * @return the Gregorian day of the mont\r\n     */\r\n    getGregorianDayOfMonth() {\r\n        return this.gregorianDayOfMonth;\r\n    }\r\n    /**\r\n     * Returns the Gregotian year.\r\n     *\r\n     * @return the Gregorian year\r\n     */\r\n    getGregorianYear() {\r\n        return this.gregorianYear;\r\n    }\r\n    /**\r\n     * Returns the Jewish month 1-12 (or 13 years in a leap year). The month count starts with 1 for Nisan and goes to\r\n     * 13 for Adar II\r\n     *\r\n     * @return the Jewish month from 1 to 12 (or 13 years in a leap year). The month count starts with 1 for Nisan and\r\n     *         goes to 13 for Adar II\r\n     */\r\n    getJewishMonth() {\r\n        return this.jewishMonth;\r\n    }\r\n    /**\r\n     * Returns the Jewish day of month.\r\n     *\r\n     * @return the Jewish day of the month\r\n     */\r\n    getJewishDayOfMonth() {\r\n        return this.jewishDay;\r\n    }\r\n    /**\r\n     * Returns the Jewish year.\r\n     *\r\n     * @return the Jewish year\r\n     */\r\n    getJewishYear() {\r\n        return this.jewishYear;\r\n    }\r\n    /**\r\n     * Returns the day of the week as a number between 1-7.\r\n     *\r\n     * @return the day of the week as a number between 1-7.\r\n     */\r\n    getDayOfWeek() {\r\n        return this.dayOfWeek;\r\n    }\r\n    /**\r\n     * Sets the Gregorian month.\r\n     *\r\n     * @param month\r\n     *            the Gregorian month\r\n     *\r\n     * @throws IllegalArgumentException\r\n     *             if a month &lt; 0 or &gt; 11 is passed in\r\n     */\r\n    setGregorianMonth(month) {\r\n        JewishDate.validateGregorianMonth(month);\r\n        this.setInternalGregorianDate(this.gregorianYear, month + 1, this.gregorianDayOfMonth);\r\n    }\r\n    /**\r\n     * sets the Gregorian year.\r\n     *\r\n     * @param year\r\n     *            the Gregorian year.\r\n     * @throws IllegalArgumentException\r\n     *             if a year of &lt; 1 is passed in\r\n     */\r\n    setGregorianYear(year) {\r\n        JewishDate.validateGregorianYear(year);\r\n        this.setInternalGregorianDate(year, this.gregorianMonth, this.gregorianDayOfMonth);\r\n    }\r\n    /**\r\n     * sets the Gregorian Day of month.\r\n     *\r\n     * @param dayOfMonth\r\n     *            the Gregorian Day of month.\r\n     * @throws IllegalArgumentException\r\n     *             if the day of month of &lt; 1 is passed in\r\n     */\r\n    setGregorianDayOfMonth(dayOfMonth) {\r\n        JewishDate.validateGregorianDayOfMonth(dayOfMonth);\r\n        this.setInternalGregorianDate(this.gregorianYear, this.gregorianMonth, dayOfMonth);\r\n    }\r\n    /**\r\n     * sets the Jewish month.\r\n     *\r\n     * @param month\r\n     *            the Jewish month from 1 to 12 (or 13 years in a leap year). The month count starts with 1 for Nisan\r\n     *            and goes to 13 for Adar II\r\n     * @throws IllegalArgumentException\r\n     *             if a month &lt; 1 or &gt; 12 (or 13 on a leap year) is passed in\r\n     */\r\n    setJewishMonth(month) {\r\n        this.setJewishDate(this.jewishYear, month, this.jewishDay);\r\n    }\r\n    /**\r\n     * sets the Jewish year.\r\n     *\r\n     * @param year\r\n     *            the Jewish year\r\n     * @throws IllegalArgumentException\r\n     *             if a year of &lt; 3761 is passed in. The same will happen if the year is 3761 and the month and day\r\n     *             previously set are &lt; 18 Teves (preior to Jan 1, 1 AD)\r\n     */\r\n    setJewishYear(year) {\r\n        this.setJewishDate(year, this.jewishMonth, this.jewishDay);\r\n    }\r\n    /**\r\n     * sets the Jewish day of month.\r\n     *\r\n     * @param dayOfMonth\r\n     *            the Jewish day of month\r\n     * @throws IllegalArgumentException\r\n     *             if the day of month is &lt; 1 or &gt; 30 is passed in\r\n     */\r\n    setJewishDayOfMonth(dayOfMonth) {\r\n        this.setJewishDate(this.jewishYear, this.jewishMonth, dayOfMonth);\r\n    }\r\n    /**\r\n     * A method that creates a <a href=\"http://en.wikipedia.org/wiki/Object_copy#Deep_copy\">deep copy</a> of the object.\r\n     *\r\n     * @see Object#clone()\r\n     */\r\n    clone() {\r\n        const clone = new JewishDate(this.jewishYear, this.jewishMonth, this.jewishDay);\r\n        clone.setMoladHours(this.moladHours);\r\n        clone.setMoladMinutes(this.moladMinutes);\r\n        clone.setMoladChalakim(this.moladChalakim);\r\n        return clone;\r\n    }\r\n}\r\n/**\r\n * Value of the month field indicating Nissan, the first numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 7th (or 8th in a {@link #isJewishLeapYear() leap\r\n   * year}) month of the year.\r\n */\r\nJewishDate.NISSAN = 1;\r\n/**\r\n * Value of the month field indicating Iyar, the second numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 8th (or 9th in a {@link #isJewishLeapYear() leap\r\n   * year}) month of the year.\r\n */\r\nJewishDate.IYAR = 2;\r\n/**\r\n * Value of the month field indicating Sivan, the third numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 9th (or 10th in a {@link #isJewishLeapYear() leap\r\n   * year}) month of the year.\r\n */\r\nJewishDate.SIVAN = 3;\r\n/**\r\n * Value of the month field indicating Tammuz, the fourth numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 10th (or 11th in a {@link #isJewishLeapYear() leap\r\n   * year}) month of the year.\r\n */\r\nJewishDate.TAMMUZ = 4;\r\n/**\r\n * Value of the month field indicating Av, the fifth numeric month of the year in the Jewish calendar. With the year\r\n * starting at {@link #TISHREI}, it would actually be the 11th (or 12th in a {@link #isJewishLeapYear() leap year})\r\n * month of the year.\r\n */\r\nJewishDate.AV = 5;\r\n/**\r\n * Value of the month field indicating Elul, the sixth numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 12th (or 13th in a {@link #isJewishLeapYear() leap\r\n   * year}) month of the year.\r\n */\r\nJewishDate.ELUL = 6;\r\n/**\r\n * Value of the month field indicating Tishrei, the seventh numeric month of the year in the Jewish calendar. With\r\n * the year starting at this month, it would actually be the 1st month of the year.\r\n */\r\nJewishDate.TISHREI = 7;\r\n/**\r\n * Value of the month field indicating Cheshvan/marcheshvan, the eighth numeric month of the year in the Jewish\r\n * calendar. With the year starting at {@link #TISHREI}, it would actually be the 2nd month of the year.\r\n */\r\nJewishDate.CHESHVAN = 8;\r\n/**\r\n * Value of the month field indicating Kislev, the ninth numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 3rd month of the year.\r\n */\r\nJewishDate.KISLEV = 9;\r\n/**\r\n * Value of the month field indicating Teves, the tenth numeric month of the year in the Jewish calendar. With the\r\n * year starting at {@link #TISHREI}, it would actually be the 4th month of the year.\r\n */\r\nJewishDate.TEVES = 10;\r\n/**\r\n * Value of the month field indicating Shevat, the eleventh numeric month of the year in the Jewish calendar. With\r\n * the year starting at {@link #TISHREI}, it would actually be the 5th month of the year.\r\n */\r\nJewishDate.SHEVAT = 11;\r\n/**\r\n * Value of the month field indicating Adar (or Adar I in a {@link #isJewishLeapYear() leap year}), the twelfth\r\n * numeric month of the year in the Jewish calendar. With the year starting at {@link #TISHREI}, it would actually\r\n * be the 6th month of the year.\r\n */\r\nJewishDate.ADAR = 12;\r\n/**\r\n * Value of the month field indicating Adar II, the leap (intercalary or embolismic) thirteenth (Undecimber) numeric\r\n * month of the year added in Jewish {@link #isJewishLeapYear() leap year}). The leap years are years 3, 6, 8, 11,\r\n * 14, 17 and 19 of a 19 year cycle. With the year starting at {@link #TISHREI}, it would actually be the 7th month\r\n * of the year.\r\n */\r\nJewishDate.ADAR_II = 13;\r\n/**\r\n * the Jewish epoch using the RD (Rata Die/Fixed Date or Reingold Dershowitz) day used in Calendrical Calculations.\r\n * Day 1 is January 1, 0001 Gregorian\r\n */\r\nJewishDate.JEWISH_EPOCH = -1373429;\r\nJewishDate.CHALAKIM_PER_MINUTE = 18;\r\nJewishDate.CHALAKIM_PER_HOUR = 1080;\r\nJewishDate.CHALAKIM_PER_DAY = 25920; // 24 * 1080\r\nJewishDate.CHALAKIM_PER_MONTH = 765433; // (29 * 24 + 12) * 1080 + 793\r\n/**\r\n * Days from the beginning of Sunday till molad BaHaRaD. Calculated as 1 day, 5 hours and 204 chalakim = (24 + 5) *\r\n * 1080 + 204 = 31524\r\n */\r\nJewishDate.CHALAKIM_MOLAD_TOHU = 31524;\r\n/**\r\n * A short year where both {@link #CHESHVAN} and {@link #KISLEV} are 29 days.\r\n *\r\n * @see #getCheshvanKislevKviah()\r\n * @see HebrewDateFormatter#getFormattedKviah(int)\r\n */\r\nJewishDate.CHASERIM = 0;\r\n/**\r\n * An ordered year where {@link #CHESHVAN} is 29 days and {@link #KISLEV} is 30 days.\r\n *\r\n * @see #getCheshvanKislevKviah()\r\n * @see HebrewDateFormatter#getFormattedKviah(int)\r\n */\r\nJewishDate.KESIDRAN = 1;\r\n/**\r\n * A long year where both {@link #CHESHVAN} and {@link #KISLEV} are 30 days.\r\n *\r\n * @see #getCheshvanKislevKviah()\r\n * @see HebrewDateFormatter#getFormattedKviah(int)\r\n */\r\nJewishDate.SHELAIMIM = 2;\r\n//# sourceMappingURL=JewishDate.js.map"]},"metadata":{},"sourceType":"module"}