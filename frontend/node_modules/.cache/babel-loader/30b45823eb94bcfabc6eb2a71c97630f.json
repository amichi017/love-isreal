{"ast":null,"code":"import { DateTime } from 'luxon';\nimport * as numeral from 'numeral';\nimport { TimeZone, Utils } from '../polyfills/Utils';\nimport { Time } from './Time';\nimport { AstronomicalCalendar } from '../AstronomicalCalendar';\nimport { ZmanimCalendar } from '../ZmanimCalendar';\nimport { ComplexZmanimCalendar } from '../ComplexZmanimCalendar';\nimport { Zman } from './Zman';\nimport { UnsupportedError } from '../polyfills/errors';\nconst methodNamesToExclude = ['getAdjustedDate', 'getDate', 'getElevationAdjustedSunrise', 'getElevationAdjustedSunset', 'getMidnightLastNight', 'getMidnightTonight', 'getSunriseBaalHatanya', 'getSunsetBaalHatanya'];\n/**\r\n * A class used to format both non {@link java.util.Date} times generated by the Zmanim package as well as Dates. For\r\n * example the {@link net.sourceforge.zmanim.AstronomicalCalendar#getTemporalHour()} returns the length of the hour in\r\n * milliseconds. This class can format this time.\r\n *\r\n * @author &copy; Eliyahu Hershfeld 2004 - 2019\r\n * @version 1.2\r\n */\n\nexport class ZmanimFormatter {\n  constructor(formatOrTimeZone, dateFormat, timeZoneId) {\n    this.prependZeroHours = false;\n    this.useSeconds = false;\n    this.useMillis = false;\n    this.timeFormat = ZmanimFormatter.SEXAGESIMAL_XSD_FORMAT;\n    let format;\n\n    if (dateFormat) {\n      format = formatOrTimeZone;\n    } else {\n      format = 0;\n      dateFormat = 'h:mm:ss';\n      timeZoneId = formatOrTimeZone;\n    }\n\n    this.setTimeZone(timeZoneId);\n\n    if (this.prependZeroHours) {\n      this.hourNF = '00';\n    }\n\n    this.setTimeFormat(format);\n    this.setDateFormat(dateFormat);\n  }\n  /**\r\n   * @return the timeZone\r\n   */\n\n\n  getTimeZone() {\n    return this.timeZoneId;\n  }\n  /**\r\n   * @param timeZoneId\r\n   *            the timeZone to set\r\n   */\n\n\n  setTimeZone(timeZoneId) {\n    this.timeZoneId = timeZoneId;\n  }\n  /**\r\n   * Sets the format to use for formatting.\r\n   *\r\n   * @param format\r\n   *            int the format constant to use.\r\n   */\n\n\n  setTimeFormat(format) {\n    this.timeFormat = format;\n\n    switch (format) {\n      case ZmanimFormatter.SEXAGESIMAL_XSD_FORMAT:\n        this.setSettings(true, true, true);\n        break;\n\n      case ZmanimFormatter.SEXAGESIMAL_FORMAT:\n        this.setSettings(false, false, false);\n        break;\n\n      case ZmanimFormatter.SEXAGESIMAL_SECONDS_FORMAT:\n        this.setSettings(false, true, false);\n        break;\n\n      case ZmanimFormatter.SEXAGESIMAL_MILLIS_FORMAT:\n        this.setSettings(false, true, true);\n        break;\n      // case DECIMAL_FORMAT:\n      // default:\n    }\n  }\n  /**\r\n   * Sets the SimpleDateFormat Object\r\n   * @param dateFormat the SimpleDateFormat Object to set\r\n   */\n\n\n  setDateFormat(dateFormat) {\n    this.dateFormat = dateFormat;\n  }\n  /**\r\n   * returns the SimpleDateFormat Object\r\n   * @return the SimpleDateFormat Object\r\n   */\n\n\n  getDateFormat() {\n    return this.dateFormat;\n  }\n\n  setSettings(prependZeroHours, useSeconds, useMillis) {\n    this.prependZeroHours = prependZeroHours;\n    this.useSeconds = useSeconds;\n    this.useMillis = useMillis;\n  }\n  /**\r\n   * A method that formats milliseconds into a time format.\r\n   *\r\n   * @param milliseconds\r\n   *            The time in milliseconds.\r\n   * @return String The formatted <code>String</code>\r\n   */\n\n  /*\r\n      public format(milliseconds: number): string {\r\n          return this.format(milliseconds);\r\n      }\r\n  */\n\n  /**\r\n   * A method that formats milliseconds into a time format.\r\n   *\r\n   * @param millis\r\n   *            The time in milliseconds.\r\n   * @return String The formatted <code>String</code>\r\n   */\n\n  /*\r\n      public format(millis: number): string {\r\n          return format(new Time(millis));\r\n      }\r\n  */\n\n  /**\r\n   * A method that formats {@link Time}objects.\r\n   *\r\n   * @param time\r\n   *            The time <code>Object</code> to be formatted.\r\n   * @return String The formatted <code>String</code>\r\n   */\n\n\n  format(timeOrMillis) {\n    let time;\n\n    if (timeOrMillis instanceof Time) {\n      time = timeOrMillis;\n    } else {\n      time = new Time(timeOrMillis);\n    }\n\n    if (this.timeFormat === ZmanimFormatter.XSD_DURATION_FORMAT) {\n      return ZmanimFormatter.formatXSDDurationTime(time);\n    }\n\n    let sb = numeral(time.getHours()).format(this.hourNF).concat(':').concat(numeral(time.getMinutes()).format(ZmanimFormatter.minuteSecondNF).toString());\n\n    if (this.useSeconds) {\n      sb = sb.concat(':').concat(numeral(time.getSeconds()).format(ZmanimFormatter.minuteSecondNF).toString());\n    }\n\n    if (this.useMillis) {\n      sb = sb.concat('.').concat(numeral(time.getMilliseconds()).format(ZmanimFormatter.milliNF).toString());\n    }\n\n    return sb;\n  }\n  /**\r\n   * Formats a date using this class's {@link #getDateFormat() date format}.\r\n   *\r\n   * @param dateTime - the date to format\r\n   * @return the formatted String\r\n   */\n\n\n  formatDateTime(dateTime) {\n    const _dateTime = dateTime.setZone(this.getTimeZone());\n\n    if (this.dateFormat === ZmanimFormatter.XSD_DATE_FORMAT) {\n      return this.getXSDateTime(_dateTime);\n    }\n\n    return _dateTime.toFormat(this.dateFormat);\n  }\n  /**\r\n   * The date:date-time function returns the current date and time as a date/time string. The date/time string that's\r\n   * returned must be a string in the format defined as the lexical representation of xs:dateTime in <a\r\n   * href=\"http://www.w3.org/TR/xmlschema11-2/#dateTime\">[3.3.8 dateTime]</a> of <a\r\n   * href=\"http://www.w3.org/TR/xmlschema11-2/\">[XML Schema 1.1 Part 2: Datatypes]</a>. The date/time format is\r\n   * basically CCYY-MM-DDThh:mm:ss, although implementers should consult <a\r\n   * href=\"http://www.w3.org/TR/xmlschema11-2/\">[XML Schema 1.1 Part 2: Datatypes]</a> and <a\r\n   * href=\"http://www.iso.ch/markete/8601.pdf\">[ISO 8601]</a> for details. The date/time string format must include a\r\n   * time zone, either a Z to indicate Coordinated Universal Time or a + or - followed by the difference between the\r\n   * difference from UTC represented as hh:mm.\r\n   * @param dateTime - the UTC Date Object\r\n   * @return the XSD dateTime\r\n   */\n\n\n  getXSDateTime(dateTime) {\n    return dateTime.setZone(this.getTimeZone()).toFormat(ZmanimFormatter.XSD_DATE_FORMAT.concat('ZZ'));\n  }\n  /**\r\n   * Represent the hours and minutes with two-digit strings.\r\n   *\r\n   * @param digits\r\n   *            hours or minutes.\r\n   * @return two-digit String representation of hrs or minutes.\r\n   */\n\n\n  static formatDigits(digits) {\n    const dd = Math.abs(digits).toString();\n    return dd.length === 1 ? `0${dd}` : dd;\n  }\n  /**\r\n   * This returns the xml representation of an xsd:duration object.\r\n   *\r\n   * @param millis\r\n   *            the duration in milliseconds\r\n   * @return the xsd:duration formatted String\r\n   */\n\n  /*\r\n      public formatXSDDurationTime(millis: number): string {\r\n          return formatXSDDurationTime(new Time(millis));\r\n      }\r\n  */\n\n  /**\r\n   * This returns the xml representation of an xsd:duration object.\r\n   *\r\n   * @param time\r\n   *            the duration as a Time object\r\n   * @return the xsd:duration formatted String\r\n   */\n\n\n  static formatXSDDurationTime(timeOrMillis) {\n    let time;\n\n    if (timeOrMillis instanceof Time) {\n      time = timeOrMillis;\n    } else {\n      time = new Time(timeOrMillis);\n    }\n\n    let duration;\n\n    if (time.getHours() !== 0 || time.getMinutes() !== 0 || time.getSeconds() !== 0 || time.getMilliseconds() !== 0) {\n      duration = 'P'.concat('T');\n      if (time.getHours() !== 0) duration = duration.concat(`${time.getHours()}H`);\n      if (time.getMinutes() !== 0) duration = duration.concat(`${time.getMinutes()}M`);\n\n      if (time.getSeconds() !== 0 || time.getMilliseconds() !== 0) {\n        duration = duration.concat(`${time.getSeconds()}.${numeral(time.getMilliseconds()).format(ZmanimFormatter.milliNF)}`);\n        duration = duration.concat('S');\n      }\n\n      if (duration.length === 1) duration.concat('T0S'); // zero seconds\n\n      if (time.isNegative()) {\n        duration = duration.substr(0, 0).concat('-').concat(duration.substr(0, duration.length));\n      }\n    }\n\n    return duration.toString();\n  }\n\n  static formatDecimal(num) {\n    return num - Math.trunc(num) > 0 ? num.toString() : numeral(num).format('0.0');\n  }\n  /**\r\n   * A method that returns an XML formatted <code>String</code> representing the serialized <code>Object</code>. The\r\n   * format used is:\r\n   *\r\n   * <pre>\r\n   *  &lt;AstronomicalTimes date=&quot;1969-02-08&quot; type=&quot;net.sourceforge.zmanim.AstronomicalCalendar algorithm=&quot;US Naval Almanac Algorithm&quot; location=&quot;Lakewood, NJ&quot; latitude=&quot;40.095965&quot; longitude=&quot;-74.22213&quot; elevation=&quot;31.0&quot; timeZoneName=&quot;Eastern Standard Time&quot; timeZoneID=&quot;America/New_York&quot; timeZoneOffset=&quot;-5&quot;&gt;\r\n   *     &lt;Sunrise&gt;2007-02-18T06:45:27-05:00&lt;/Sunrise&gt;\r\n   *     &lt;TemporalHour&gt;PT54M17.529S&lt;/TemporalHour&gt;\r\n   *     ...\r\n   *   &lt;/AstronomicalTimes&gt;\r\n   * </pre>\r\n   *\r\n   * Note that the output uses the <a href=\"http://www.w3.org/TR/xmlschema11-2/#dateTime\">xsd:dateTime</a> format for\r\n   * times such as sunrise, and <a href=\"http://www.w3.org/TR/xmlschema11-2/#duration\">xsd:duration</a> format for\r\n   * times that are a duration such as the length of a\r\n   * {@link net.sourceforge.zmanim.AstronomicalCalendar#getTemporalHour() temporal hour}. The output of this method is\r\n   * returned by the {@link #toString() toString}.\r\n   *\r\n   * @param astronomicalCalendar the AstronomicalCalendar Object\r\n   *\r\n   * @return The XML formatted <code>String</code>. The format will be:\r\n   *\r\n   *         <pre>\r\n   *  &lt;AstronomicalTimes date=&quot;1969-02-08&quot; type=&quot;net.sourceforge.zmanim.AstronomicalCalendar algorithm=&quot;US Naval Almanac Algorithm&quot; location=&quot;Lakewood, NJ&quot; latitude=&quot;40.095965&quot; longitude=&quot;-74.22213&quot; elevation=&quot;31.0&quot; timeZoneName=&quot;Eastern Standard Time&quot; timeZoneID=&quot;America/New_York&quot; timeZoneOffset=&quot;-5&quot;&gt;\r\n   *     &lt;Sunrise&gt;2007-02-18T06:45:27-05:00&lt;/Sunrise&gt;\r\n   *     &lt;TemporalHour&gt;PT54M17.529S&lt;/TemporalHour&gt;\r\n   *     ...\r\n   *  &lt;/AstronomicalTimes&gt;\r\n   * </pre>\r\n   *\r\n   *         TODO: add proper schema, and support for nulls. XSD duration (for solar hours), should probably return\r\n   *         nil and not P\r\n   * @deprecated\r\n   */\n\n\n  static toXML() {\n    throw new UnsupportedError('This method is not supported.');\n  }\n  /**\r\n   * A method that returns a JSON formatted <code>String</code> representing the serialized <code>Object</code>. The\r\n   * format used is:\r\n   * <pre>\r\n   * {\r\n   *    &quot;metadata&quot;:{\r\n   *      &quot;date&quot;:&quot;1969-02-08&quot;,\r\n   *      &quot;type&quot;:&quot;net.sourceforge.zmanim.AstronomicalCalendar&quot;,\r\n   *      &quot;algorithm&quot;:&quot;US Naval Almanac Algorithm&quot;,\r\n   *      &quot;location&quot;:&quot;Lakewood, NJ&quot;,\r\n   *      &quot;latitude&quot;:&quot;40.095965&quot;,\r\n   *      &quot;longitude&quot;:&quot;-74.22213&quot;,\r\n   *      &quot;elevation:&quot;31.0&quot;,\r\n   *      &quot;timeZoneName&quot;:&quot;Eastern Standard Time&quot;,\r\n   *      &quot;timeZoneID&quot;:&quot;America/New_York&quot;,\r\n   *      &quot;timeZoneOffset&quot;:&quot;-5&quot;},\r\n   *    &quot;AstronomicalTimes&quot;:{\r\n   *     &quot;Sunrise&quot;:&quot;2007-02-18T06:45:27-05:00&quot;,\r\n   *     &quot;TemporalHour&quot;:&quot;PT54M17.529S&quot;\r\n   *     ...\r\n   *     }\r\n   * }\r\n   * </pre>\r\n   *\r\n   * Note that the output uses the <a href=\"http://www.w3.org/TR/xmlschema11-2/#dateTime\">xsd:dateTime</a> format for\r\n   * times such as sunrise, and <a href=\"http://www.w3.org/TR/xmlschema11-2/#duration\">xsd:duration</a> format for\r\n   * times that are a duration such as the length of a\r\n   * {@link net.sourceforge.zmanim.AstronomicalCalendar#getTemporalHour() temporal hour}.\r\n   *\r\n   * @param astronomicalCalendar the AstronomicalCalendar Object\r\n   *\r\n   * @return The JSON formatted <code>String</code>. The format will be:\r\n   * <pre>\r\n   * {\r\n   *    &quot;metadata&quot;:{\r\n   *      &quot;date&quot;:&quot;1969-02-08&quot;,\r\n   *      &quot;type&quot;:&quot;net.sourceforge.zmanim.AstronomicalCalendar&quot;,\r\n   *      &quot;algorithm&quot;:&quot;US Naval Almanac Algorithm&quot;,\r\n   *      &quot;location&quot;:&quot;Lakewood, NJ&quot;,\r\n   *      &quot;latitude&quot;:&quot;40.095965&quot;,\r\n   *      &quot;longitude&quot;:&quot;-74.22213&quot;,\r\n   *      &quot;elevation:&quot;31.0&quot;,\r\n   *      &quot;timeZoneName&quot;:&quot;Eastern Standard Time&quot;,\r\n   *      &quot;timeZoneID&quot;:&quot;America/New_York&quot;,\r\n   *      &quot;timeZoneOffset&quot;:&quot;-5&quot;},\r\n   *    &quot;AstronomicalTimes&quot;:{\r\n   *     &quot;Sunrise&quot;:&quot;2007-02-18T06:45:27-05:00&quot;,\r\n   *     &quot;TemporalHour&quot;:&quot;PT54M17.529S&quot;\r\n   *     ...\r\n   *     }\r\n   * }\r\n   * </pre>\r\n   */\n\n\n  static toJSON(astronomicalCalendar) {\n    const json = {\n      metadata: ZmanimFormatter.getOutputMetadata(astronomicalCalendar)\n    };\n    const key = ZmanimFormatter.getOutputKey(astronomicalCalendar);\n    json[key] = ZmanimFormatter.getZmanimOutput(astronomicalCalendar);\n    return json;\n  } // @ts-ignore\n\n\n  static getOutputKey(astronomicalCalendar) {\n    switch (true) {\n      case astronomicalCalendar instanceof ComplexZmanimCalendar:\n        return 'Zmanim';\n\n      case astronomicalCalendar instanceof ZmanimCalendar:\n        return 'BasicZmanim';\n\n      case astronomicalCalendar instanceof AstronomicalCalendar:\n        return 'AstronomicalTimes';\n    }\n  }\n\n  static getOutputMetadata(astronomicalCalendar) {\n    const df = 'yyyy-MM-dd';\n    return {\n      date: astronomicalCalendar.getDate().toFormat(df),\n      type: astronomicalCalendar.getClassName(),\n      algorithm: astronomicalCalendar.getAstronomicalCalculator().getCalculatorName(),\n      location: astronomicalCalendar.getGeoLocation().getLocationName(),\n      latitude: astronomicalCalendar.getGeoLocation().getLatitude().toString(),\n      longitude: astronomicalCalendar.getGeoLocation().getLongitude().toString(),\n      elevation: ZmanimFormatter.formatDecimal(astronomicalCalendar.getGeoLocation().getElevation()),\n      timeZoneName: TimeZone.getDisplayName(astronomicalCalendar.getGeoLocation().getTimeZone(), astronomicalCalendar.getDate()),\n      timeZoneID: astronomicalCalendar.getGeoLocation().getTimeZone(),\n      timeZoneOffset: ZmanimFormatter.formatDecimal(TimeZone.getOffset(astronomicalCalendar.getGeoLocation().getTimeZone(), astronomicalCalendar.getDate().valueOf()) / ZmanimFormatter.HOUR_MILLIS)\n    };\n  }\n\n  static getZmanimOutput(astronomicalCalendar) {\n    const formatter = new ZmanimFormatter(ZmanimFormatter.XSD_DURATION_FORMAT, ZmanimFormatter.XSD_DATE_FORMAT, astronomicalCalendar.getGeoLocation().getTimeZone());\n    /*\r\n        let dateList: Set<Date> = new Set();\r\n        let durationList: Set<number> = new Set();\r\n    */\n\n    const dateList = [];\n    let durationList = [];\n    const otherList = []; // Get al the methods in the calendar\n\n    Utils.getAllMethodNames(astronomicalCalendar, true) // Filter out methods that we don't want\n    .filter(method => includeMethod(method, astronomicalCalendar)) // Call each method and get the return values\n    .map(method => ({\n      methodName: method,\n      value: astronomicalCalendar[method].call(astronomicalCalendar)\n    })) // Filter for return values of type Date or number\n    .filter(methodObj => DateTime.isDateTime(methodObj.value) || typeof methodObj.value === 'number' || methodObj.value === null) // Separate the Dates and numbers\n    .forEach(methodObj => {\n      const tagName = methodObj.methodName.substring(3);\n\n      if (DateTime.isDateTime(methodObj.value)) {\n        // dateList.add(new KosherZmanim.Zman(methodObj.value, tagName));\n        const zman = {\n          zman: methodObj.value,\n          label: tagName\n        };\n        dateList.push(zman);\n      } else if (typeof methodObj.value === 'number') {\n        // durationList.add(new KosherZmanim.Zman(methodObj.value, tagName));\n        const zman = {\n          duration: methodObj.value,\n          label: tagName\n        };\n        durationList.push(zman);\n      } else {\n        otherList.push(tagName);\n      }\n    });\n    dateList.sort(Zman.compareDateOrder); // Filter for values in milliseconds, and not values in minutes\n\n    durationList = durationList.filter(zman => zman.duration > 1000).sort(Zman.compareDurationOrder);\n    const timesData = {};\n    dateList.forEach(zman => {\n      timesData[zman.label] = formatter.formatDateTime(zman.zman);\n    });\n    durationList.forEach(zman => {\n      timesData[zman.label] = formatter.format(Math.trunc(zman.duration));\n    });\n    otherList.forEach(tagName => {\n      timesData[tagName] = 'N/A';\n    });\n    return timesData;\n  }\n\n}\nZmanimFormatter.minuteSecondNF = '00';\nZmanimFormatter.milliNF = '000';\n/**\r\n * Format using hours, minutes, seconds and milliseconds using the xsd:time format. This format will return\r\n * 00.00.00.0 when formatting 0.\r\n */\n\nZmanimFormatter.SEXAGESIMAL_XSD_FORMAT = 0;\n/**\r\n * Format using standard decimal format with 5 positions after the decimal.\r\n */\n\nZmanimFormatter.DECIMAL_FORMAT = 1;\n/** Format using hours and minutes. */\n\nZmanimFormatter.SEXAGESIMAL_FORMAT = 2;\n/** Format using hours, minutes and seconds. */\n\nZmanimFormatter.SEXAGESIMAL_SECONDS_FORMAT = 3;\n/** Format using hours, minutes, seconds and milliseconds. */\n\nZmanimFormatter.SEXAGESIMAL_MILLIS_FORMAT = 4;\n/** constant for milliseconds in a minute (60,000) */\n\nZmanimFormatter.MINUTE_MILLIS = 60 * 1000;\n/** constant for milliseconds in an hour (3,600,000) */\n\nZmanimFormatter.HOUR_MILLIS = ZmanimFormatter.MINUTE_MILLIS * 60;\n/**\r\n * Format using the XSD Duration format. This is in the format of PT1H6M7.869S (P for period (duration), T for time,\r\n * H, M and S indicate hours, minutes and seconds.\r\n */\n\nZmanimFormatter.XSD_DURATION_FORMAT = 5;\nZmanimFormatter.XSD_DATE_FORMAT = 'yyyy-LL-dd\\'T\\'HH:mm:ss';\n/**\r\n * Determines if a method should be output by the {@link #toJSON(AstronomicalCalendar)}\r\n *\r\n * @param {string} method - the method in question\r\n * @param {AstronomicalCalendar} astronomicalCalendar - The astronomical calendar, to be able to\r\n * check the parameterlist\r\n * @return if the method should be included in serialization\r\n */\n\nfunction includeMethod(method, astronomicalCalendar) {\n  // Filter out methods with parameters\n  return astronomicalCalendar[method].length === 0 // Filter out methods that don't start with \"get\"\n  && method.startsWith('get') // Filter out excluded methods\n  && !methodNamesToExclude.includes(method);\n}","map":{"version":3,"sources":["../../../src/util/ZmanimFormatter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { DateTime } from 'luxon';\r\nimport * as numeral from 'numeral';\r\nimport { TimeZone, Utils } from '../polyfills/Utils';\r\nimport { Time } from './Time';\r\nimport { AstronomicalCalendar } from '../AstronomicalCalendar';\r\nimport { ZmanimCalendar } from '../ZmanimCalendar';\r\nimport { ComplexZmanimCalendar } from '../ComplexZmanimCalendar';\r\nimport { Zman } from './Zman';\r\nimport { UnsupportedError } from '../polyfills/errors';\r\nconst methodNamesToExclude = [\r\n    'getAdjustedDate',\r\n    'getDate',\r\n    'getElevationAdjustedSunrise',\r\n    'getElevationAdjustedSunset',\r\n    'getMidnightLastNight',\r\n    'getMidnightTonight',\r\n    'getSunriseBaalHatanya',\r\n    'getSunsetBaalHatanya',\r\n];\r\n/**\r\n * A class used to format both non {@link java.util.Date} times generated by the Zmanim package as well as Dates. For\r\n * example the {@link net.sourceforge.zmanim.AstronomicalCalendar#getTemporalHour()} returns the length of the hour in\r\n * milliseconds. This class can format this time.\r\n *\r\n * @author &copy; Eliyahu Hershfeld 2004 - 2019\r\n * @version 1.2\r\n */\r\nexport class ZmanimFormatter {\r\n    constructor(formatOrTimeZone, dateFormat, timeZoneId) {\r\n        this.prependZeroHours = false;\r\n        this.useSeconds = false;\r\n        this.useMillis = false;\r\n        this.timeFormat = ZmanimFormatter.SEXAGESIMAL_XSD_FORMAT;\r\n        let format;\r\n        if (dateFormat) {\r\n            format = formatOrTimeZone;\r\n        }\r\n        else {\r\n            format = 0;\r\n            dateFormat = 'h:mm:ss';\r\n            timeZoneId = formatOrTimeZone;\r\n        }\r\n        this.setTimeZone(timeZoneId);\r\n        if (this.prependZeroHours) {\r\n            this.hourNF = '00';\r\n        }\r\n        this.setTimeFormat(format);\r\n        this.setDateFormat(dateFormat);\r\n    }\r\n    /**\r\n     * @return the timeZone\r\n     */\r\n    getTimeZone() {\r\n        return this.timeZoneId;\r\n    }\r\n    /**\r\n     * @param timeZoneId\r\n     *            the timeZone to set\r\n     */\r\n    setTimeZone(timeZoneId) {\r\n        this.timeZoneId = timeZoneId;\r\n    }\r\n    /**\r\n     * Sets the format to use for formatting.\r\n     *\r\n     * @param format\r\n     *            int the format constant to use.\r\n     */\r\n    setTimeFormat(format) {\r\n        this.timeFormat = format;\r\n        switch (format) {\r\n            case ZmanimFormatter.SEXAGESIMAL_XSD_FORMAT:\r\n                this.setSettings(true, true, true);\r\n                break;\r\n            case ZmanimFormatter.SEXAGESIMAL_FORMAT:\r\n                this.setSettings(false, false, false);\r\n                break;\r\n            case ZmanimFormatter.SEXAGESIMAL_SECONDS_FORMAT:\r\n                this.setSettings(false, true, false);\r\n                break;\r\n            case ZmanimFormatter.SEXAGESIMAL_MILLIS_FORMAT:\r\n                this.setSettings(false, true, true);\r\n                break;\r\n            // case DECIMAL_FORMAT:\r\n            // default:\r\n        }\r\n    }\r\n    /**\r\n     * Sets the SimpleDateFormat Object\r\n     * @param dateFormat the SimpleDateFormat Object to set\r\n     */\r\n    setDateFormat(dateFormat) {\r\n        this.dateFormat = dateFormat;\r\n    }\r\n    /**\r\n     * returns the SimpleDateFormat Object\r\n     * @return the SimpleDateFormat Object\r\n     */\r\n    getDateFormat() {\r\n        return this.dateFormat;\r\n    }\r\n    setSettings(prependZeroHours, useSeconds, useMillis) {\r\n        this.prependZeroHours = prependZeroHours;\r\n        this.useSeconds = useSeconds;\r\n        this.useMillis = useMillis;\r\n    }\r\n    /**\r\n     * A method that formats milliseconds into a time format.\r\n     *\r\n     * @param milliseconds\r\n     *            The time in milliseconds.\r\n     * @return String The formatted <code>String</code>\r\n     */\r\n    /*\r\n        public format(milliseconds: number): string {\r\n            return this.format(milliseconds);\r\n        }\r\n    */\r\n    /**\r\n     * A method that formats milliseconds into a time format.\r\n     *\r\n     * @param millis\r\n     *            The time in milliseconds.\r\n     * @return String The formatted <code>String</code>\r\n     */\r\n    /*\r\n        public format(millis: number): string {\r\n            return format(new Time(millis));\r\n        }\r\n    */\r\n    /**\r\n     * A method that formats {@link Time}objects.\r\n     *\r\n     * @param time\r\n     *            The time <code>Object</code> to be formatted.\r\n     * @return String The formatted <code>String</code>\r\n     */\r\n    format(timeOrMillis) {\r\n        let time;\r\n        if (timeOrMillis instanceof Time) {\r\n            time = timeOrMillis;\r\n        }\r\n        else {\r\n            time = new Time(timeOrMillis);\r\n        }\r\n        if (this.timeFormat === ZmanimFormatter.XSD_DURATION_FORMAT) {\r\n            return ZmanimFormatter.formatXSDDurationTime(time);\r\n        }\r\n        let sb = (numeral(time.getHours()).format(this.hourNF)).concat(':')\r\n            .concat(numeral(time.getMinutes()).format(ZmanimFormatter.minuteSecondNF).toString());\r\n        if (this.useSeconds) {\r\n            sb = sb.concat(':').concat(numeral(time.getSeconds()).format(ZmanimFormatter.minuteSecondNF).toString());\r\n        }\r\n        if (this.useMillis) {\r\n            sb = sb.concat('.').concat(numeral(time.getMilliseconds()).format(ZmanimFormatter.milliNF).toString());\r\n        }\r\n        return sb;\r\n    }\r\n    /**\r\n     * Formats a date using this class's {@link #getDateFormat() date format}.\r\n     *\r\n     * @param dateTime - the date to format\r\n     * @return the formatted String\r\n     */\r\n    formatDateTime(dateTime) {\r\n        const _dateTime = dateTime.setZone(this.getTimeZone());\r\n        if (this.dateFormat === ZmanimFormatter.XSD_DATE_FORMAT) {\r\n            return this.getXSDateTime(_dateTime);\r\n        }\r\n        return _dateTime.toFormat(this.dateFormat);\r\n    }\r\n    /**\r\n     * The date:date-time function returns the current date and time as a date/time string. The date/time string that's\r\n     * returned must be a string in the format defined as the lexical representation of xs:dateTime in <a\r\n     * href=\"http://www.w3.org/TR/xmlschema11-2/#dateTime\">[3.3.8 dateTime]</a> of <a\r\n     * href=\"http://www.w3.org/TR/xmlschema11-2/\">[XML Schema 1.1 Part 2: Datatypes]</a>. The date/time format is\r\n     * basically CCYY-MM-DDThh:mm:ss, although implementers should consult <a\r\n     * href=\"http://www.w3.org/TR/xmlschema11-2/\">[XML Schema 1.1 Part 2: Datatypes]</a> and <a\r\n     * href=\"http://www.iso.ch/markete/8601.pdf\">[ISO 8601]</a> for details. The date/time string format must include a\r\n     * time zone, either a Z to indicate Coordinated Universal Time or a + or - followed by the difference between the\r\n     * difference from UTC represented as hh:mm.\r\n     * @param dateTime - the UTC Date Object\r\n     * @return the XSD dateTime\r\n     */\r\n    getXSDateTime(dateTime) {\r\n        return dateTime.setZone(this.getTimeZone())\r\n            .toFormat(ZmanimFormatter.XSD_DATE_FORMAT.concat('ZZ'));\r\n    }\r\n    /**\r\n     * Represent the hours and minutes with two-digit strings.\r\n     *\r\n     * @param digits\r\n     *            hours or minutes.\r\n     * @return two-digit String representation of hrs or minutes.\r\n     */\r\n    static formatDigits(digits) {\r\n        const dd = Math.abs(digits).toString();\r\n        return dd.length === 1 ? `0${dd}` : dd;\r\n    }\r\n    /**\r\n     * This returns the xml representation of an xsd:duration object.\r\n     *\r\n     * @param millis\r\n     *            the duration in milliseconds\r\n     * @return the xsd:duration formatted String\r\n     */\r\n    /*\r\n        public formatXSDDurationTime(millis: number): string {\r\n            return formatXSDDurationTime(new Time(millis));\r\n        }\r\n    */\r\n    /**\r\n     * This returns the xml representation of an xsd:duration object.\r\n     *\r\n     * @param time\r\n     *            the duration as a Time object\r\n     * @return the xsd:duration formatted String\r\n     */\r\n    static formatXSDDurationTime(timeOrMillis) {\r\n        let time;\r\n        if (timeOrMillis instanceof Time) {\r\n            time = timeOrMillis;\r\n        }\r\n        else {\r\n            time = new Time(timeOrMillis);\r\n        }\r\n        let duration;\r\n        if (time.getHours() !== 0 || time.getMinutes() !== 0 || time.getSeconds() !== 0 || time.getMilliseconds() !== 0) {\r\n            duration = ('P').concat('T');\r\n            if (time.getHours() !== 0)\r\n                duration = duration.concat(`${time.getHours()}H`);\r\n            if (time.getMinutes() !== 0)\r\n                duration = duration.concat(`${time.getMinutes()}M`);\r\n            if (time.getSeconds() !== 0 || time.getMilliseconds() !== 0) {\r\n                duration = duration.concat(`${time.getSeconds()}.${numeral(time.getMilliseconds()).format(ZmanimFormatter.milliNF)}`);\r\n                duration = duration.concat('S');\r\n            }\r\n            if (duration.length === 1)\r\n                duration.concat('T0S'); // zero seconds\r\n            if (time.isNegative()) {\r\n                duration = duration.substr(0, 0).concat('-').concat(duration.substr(0, duration.length));\r\n            }\r\n        }\r\n        return duration.toString();\r\n    }\r\n    static formatDecimal(num) {\r\n        return num - Math.trunc(num) > 0 ? num.toString() : numeral(num).format('0.0');\r\n    }\r\n    /**\r\n     * A method that returns an XML formatted <code>String</code> representing the serialized <code>Object</code>. The\r\n     * format used is:\r\n     *\r\n     * <pre>\r\n     *  &lt;AstronomicalTimes date=&quot;1969-02-08&quot; type=&quot;net.sourceforge.zmanim.AstronomicalCalendar algorithm=&quot;US Naval Almanac Algorithm&quot; location=&quot;Lakewood, NJ&quot; latitude=&quot;40.095965&quot; longitude=&quot;-74.22213&quot; elevation=&quot;31.0&quot; timeZoneName=&quot;Eastern Standard Time&quot; timeZoneID=&quot;America/New_York&quot; timeZoneOffset=&quot;-5&quot;&gt;\r\n     *     &lt;Sunrise&gt;2007-02-18T06:45:27-05:00&lt;/Sunrise&gt;\r\n     *     &lt;TemporalHour&gt;PT54M17.529S&lt;/TemporalHour&gt;\r\n     *     ...\r\n     *   &lt;/AstronomicalTimes&gt;\r\n     * </pre>\r\n     *\r\n     * Note that the output uses the <a href=\"http://www.w3.org/TR/xmlschema11-2/#dateTime\">xsd:dateTime</a> format for\r\n     * times such as sunrise, and <a href=\"http://www.w3.org/TR/xmlschema11-2/#duration\">xsd:duration</a> format for\r\n     * times that are a duration such as the length of a\r\n     * {@link net.sourceforge.zmanim.AstronomicalCalendar#getTemporalHour() temporal hour}. The output of this method is\r\n     * returned by the {@link #toString() toString}.\r\n     *\r\n     * @param astronomicalCalendar the AstronomicalCalendar Object\r\n     *\r\n     * @return The XML formatted <code>String</code>. The format will be:\r\n     *\r\n     *         <pre>\r\n     *  &lt;AstronomicalTimes date=&quot;1969-02-08&quot; type=&quot;net.sourceforge.zmanim.AstronomicalCalendar algorithm=&quot;US Naval Almanac Algorithm&quot; location=&quot;Lakewood, NJ&quot; latitude=&quot;40.095965&quot; longitude=&quot;-74.22213&quot; elevation=&quot;31.0&quot; timeZoneName=&quot;Eastern Standard Time&quot; timeZoneID=&quot;America/New_York&quot; timeZoneOffset=&quot;-5&quot;&gt;\r\n     *     &lt;Sunrise&gt;2007-02-18T06:45:27-05:00&lt;/Sunrise&gt;\r\n     *     &lt;TemporalHour&gt;PT54M17.529S&lt;/TemporalHour&gt;\r\n     *     ...\r\n     *  &lt;/AstronomicalTimes&gt;\r\n     * </pre>\r\n     *\r\n     *         TODO: add proper schema, and support for nulls. XSD duration (for solar hours), should probably return\r\n     *         nil and not P\r\n     * @deprecated\r\n     */\r\n    static toXML() {\r\n        throw new UnsupportedError('This method is not supported.');\r\n    }\r\n    /**\r\n     * A method that returns a JSON formatted <code>String</code> representing the serialized <code>Object</code>. The\r\n     * format used is:\r\n     * <pre>\r\n     * {\r\n     *    &quot;metadata&quot;:{\r\n     *      &quot;date&quot;:&quot;1969-02-08&quot;,\r\n     *      &quot;type&quot;:&quot;net.sourceforge.zmanim.AstronomicalCalendar&quot;,\r\n     *      &quot;algorithm&quot;:&quot;US Naval Almanac Algorithm&quot;,\r\n     *      &quot;location&quot;:&quot;Lakewood, NJ&quot;,\r\n     *      &quot;latitude&quot;:&quot;40.095965&quot;,\r\n     *      &quot;longitude&quot;:&quot;-74.22213&quot;,\r\n     *      &quot;elevation:&quot;31.0&quot;,\r\n     *      &quot;timeZoneName&quot;:&quot;Eastern Standard Time&quot;,\r\n     *      &quot;timeZoneID&quot;:&quot;America/New_York&quot;,\r\n     *      &quot;timeZoneOffset&quot;:&quot;-5&quot;},\r\n     *    &quot;AstronomicalTimes&quot;:{\r\n     *     &quot;Sunrise&quot;:&quot;2007-02-18T06:45:27-05:00&quot;,\r\n     *     &quot;TemporalHour&quot;:&quot;PT54M17.529S&quot;\r\n     *     ...\r\n     *     }\r\n     * }\r\n     * </pre>\r\n     *\r\n     * Note that the output uses the <a href=\"http://www.w3.org/TR/xmlschema11-2/#dateTime\">xsd:dateTime</a> format for\r\n     * times such as sunrise, and <a href=\"http://www.w3.org/TR/xmlschema11-2/#duration\">xsd:duration</a> format for\r\n     * times that are a duration such as the length of a\r\n     * {@link net.sourceforge.zmanim.AstronomicalCalendar#getTemporalHour() temporal hour}.\r\n     *\r\n     * @param astronomicalCalendar the AstronomicalCalendar Object\r\n     *\r\n     * @return The JSON formatted <code>String</code>. The format will be:\r\n     * <pre>\r\n     * {\r\n     *    &quot;metadata&quot;:{\r\n     *      &quot;date&quot;:&quot;1969-02-08&quot;,\r\n     *      &quot;type&quot;:&quot;net.sourceforge.zmanim.AstronomicalCalendar&quot;,\r\n     *      &quot;algorithm&quot;:&quot;US Naval Almanac Algorithm&quot;,\r\n     *      &quot;location&quot;:&quot;Lakewood, NJ&quot;,\r\n     *      &quot;latitude&quot;:&quot;40.095965&quot;,\r\n     *      &quot;longitude&quot;:&quot;-74.22213&quot;,\r\n     *      &quot;elevation:&quot;31.0&quot;,\r\n     *      &quot;timeZoneName&quot;:&quot;Eastern Standard Time&quot;,\r\n     *      &quot;timeZoneID&quot;:&quot;America/New_York&quot;,\r\n     *      &quot;timeZoneOffset&quot;:&quot;-5&quot;},\r\n     *    &quot;AstronomicalTimes&quot;:{\r\n     *     &quot;Sunrise&quot;:&quot;2007-02-18T06:45:27-05:00&quot;,\r\n     *     &quot;TemporalHour&quot;:&quot;PT54M17.529S&quot;\r\n     *     ...\r\n     *     }\r\n     * }\r\n     * </pre>\r\n     */\r\n    static toJSON(astronomicalCalendar) {\r\n        const json = {\r\n            metadata: ZmanimFormatter.getOutputMetadata(astronomicalCalendar),\r\n        };\r\n        const key = ZmanimFormatter.getOutputKey(astronomicalCalendar);\r\n        json[key] = ZmanimFormatter.getZmanimOutput(astronomicalCalendar);\r\n        return json;\r\n    }\r\n    // @ts-ignore\r\n    static getOutputKey(astronomicalCalendar) {\r\n        switch (true) {\r\n            case astronomicalCalendar instanceof ComplexZmanimCalendar:\r\n                return 'Zmanim';\r\n            case astronomicalCalendar instanceof ZmanimCalendar:\r\n                return 'BasicZmanim';\r\n            case astronomicalCalendar instanceof AstronomicalCalendar:\r\n                return 'AstronomicalTimes';\r\n        }\r\n    }\r\n    static getOutputMetadata(astronomicalCalendar) {\r\n        const df = 'yyyy-MM-dd';\r\n        return {\r\n            date: astronomicalCalendar.getDate().toFormat(df),\r\n            type: astronomicalCalendar.getClassName(),\r\n            algorithm: astronomicalCalendar.getAstronomicalCalculator().getCalculatorName(),\r\n            location: astronomicalCalendar.getGeoLocation().getLocationName(),\r\n            latitude: astronomicalCalendar.getGeoLocation().getLatitude().toString(),\r\n            longitude: astronomicalCalendar.getGeoLocation().getLongitude().toString(),\r\n            elevation: ZmanimFormatter.formatDecimal(astronomicalCalendar.getGeoLocation().getElevation()),\r\n            timeZoneName: TimeZone.getDisplayName(astronomicalCalendar.getGeoLocation().getTimeZone(), astronomicalCalendar.getDate()),\r\n            timeZoneID: astronomicalCalendar.getGeoLocation().getTimeZone(),\r\n            timeZoneOffset: ZmanimFormatter.formatDecimal(TimeZone.getOffset(astronomicalCalendar.getGeoLocation().getTimeZone(), astronomicalCalendar.getDate().valueOf()) / ZmanimFormatter.HOUR_MILLIS),\r\n        };\r\n    }\r\n    static getZmanimOutput(astronomicalCalendar) {\r\n        const formatter = new ZmanimFormatter(ZmanimFormatter.XSD_DURATION_FORMAT, ZmanimFormatter.XSD_DATE_FORMAT, astronomicalCalendar.getGeoLocation().getTimeZone());\r\n        /*\r\n            let dateList: Set<Date> = new Set();\r\n            let durationList: Set<number> = new Set();\r\n        */\r\n        const dateList = [];\r\n        let durationList = [];\r\n        const otherList = [];\r\n        // Get al the methods in the calendar\r\n        Utils.getAllMethodNames(astronomicalCalendar, true)\r\n            // Filter out methods that we don't want\r\n            .filter(method => includeMethod(method, astronomicalCalendar))\r\n            // Call each method and get the return values\r\n            .map(method => ({\r\n            methodName: method,\r\n            value: astronomicalCalendar[method].call(astronomicalCalendar),\r\n        }))\r\n            // Filter for return values of type Date or number\r\n            .filter(methodObj => DateTime.isDateTime(methodObj.value) || typeof methodObj.value === 'number' || methodObj.value === null)\r\n            // Separate the Dates and numbers\r\n            .forEach(methodObj => {\r\n            const tagName = methodObj.methodName.substring(3);\r\n            if (DateTime.isDateTime(methodObj.value)) {\r\n                // dateList.add(new KosherZmanim.Zman(methodObj.value, tagName));\r\n                const zman = {\r\n                    zman: methodObj.value,\r\n                    label: tagName,\r\n                };\r\n                dateList.push(zman);\r\n            }\r\n            else if (typeof methodObj.value === 'number') {\r\n                // durationList.add(new KosherZmanim.Zman(methodObj.value, tagName));\r\n                const zman = {\r\n                    duration: methodObj.value,\r\n                    label: tagName,\r\n                };\r\n                durationList.push(zman);\r\n            }\r\n            else {\r\n                otherList.push(tagName);\r\n            }\r\n        });\r\n        dateList.sort(Zman.compareDateOrder);\r\n        // Filter for values in milliseconds, and not values in minutes\r\n        durationList = durationList.filter((zman) => zman.duration > 1000)\r\n            .sort(Zman.compareDurationOrder);\r\n        const timesData = {};\r\n        dateList.forEach((zman) => {\r\n            timesData[zman.label] = formatter.formatDateTime(zman.zman);\r\n        });\r\n        durationList.forEach((zman) => {\r\n            timesData[zman.label] = formatter.format(Math.trunc(zman.duration));\r\n        });\r\n        otherList.forEach((tagName) => {\r\n            timesData[tagName] = 'N/A';\r\n        });\r\n        return timesData;\r\n    }\r\n}\r\nZmanimFormatter.minuteSecondNF = '00';\r\nZmanimFormatter.milliNF = '000';\r\n/**\r\n * Format using hours, minutes, seconds and milliseconds using the xsd:time format. This format will return\r\n * 00.00.00.0 when formatting 0.\r\n */\r\nZmanimFormatter.SEXAGESIMAL_XSD_FORMAT = 0;\r\n/**\r\n * Format using standard decimal format with 5 positions after the decimal.\r\n */\r\nZmanimFormatter.DECIMAL_FORMAT = 1;\r\n/** Format using hours and minutes. */\r\nZmanimFormatter.SEXAGESIMAL_FORMAT = 2;\r\n/** Format using hours, minutes and seconds. */\r\nZmanimFormatter.SEXAGESIMAL_SECONDS_FORMAT = 3;\r\n/** Format using hours, minutes, seconds and milliseconds. */\r\nZmanimFormatter.SEXAGESIMAL_MILLIS_FORMAT = 4;\r\n/** constant for milliseconds in a minute (60,000) */\r\nZmanimFormatter.MINUTE_MILLIS = 60 * 1000;\r\n/** constant for milliseconds in an hour (3,600,000) */\r\nZmanimFormatter.HOUR_MILLIS = ZmanimFormatter.MINUTE_MILLIS * 60;\r\n/**\r\n * Format using the XSD Duration format. This is in the format of PT1H6M7.869S (P for period (duration), T for time,\r\n * H, M and S indicate hours, minutes and seconds.\r\n */\r\nZmanimFormatter.XSD_DURATION_FORMAT = 5;\r\nZmanimFormatter.XSD_DATE_FORMAT = 'yyyy-LL-dd\\'T\\'HH:mm:ss';\r\n/**\r\n * Determines if a method should be output by the {@link #toJSON(AstronomicalCalendar)}\r\n *\r\n * @param {string} method - the method in question\r\n * @param {AstronomicalCalendar} astronomicalCalendar - The astronomical calendar, to be able to\r\n * check the parameterlist\r\n * @return if the method should be included in serialization\r\n */\r\nfunction includeMethod(method, astronomicalCalendar) {\r\n    // Filter out methods with parameters\r\n    return astronomicalCalendar[method].length === 0\r\n        // Filter out methods that don't start with \"get\"\r\n        && method.startsWith('get')\r\n        // Filter out excluded methods\r\n        && !methodNamesToExclude.includes(method);\r\n}\r\n//# sourceMappingURL=ZmanimFormatter.js.map"]},"metadata":{},"sourceType":"module"}